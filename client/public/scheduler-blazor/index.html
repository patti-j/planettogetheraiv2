<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scheduler Standalone (Blazor vanilla JS extracted)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body { 
      height: 100%; 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f5f5;
    }
    
    #app { 
      height: 100%;
      display: flex;
      flex-direction: column;
      background: white;
    }
    
    #scheduler-container {
      flex: 1;
      position: relative;
      min-height: 0;
      padding: 10px;
    }
    
    #scheduler { 
      height: 100%;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
    
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
      font-size: 18px;
    }
    
    .error-message {
      color: red;
      padding: 20px;
      text-align: center;
    }

    /* Bryntum scheduler overrides for better appearance */
    .b-grid-header {
      background: #f8f9fa !important;
      border-bottom: 2px solid #dee2e6 !important;
    }
    
    .b-grid-row:nth-child(even) {
      background: #f8f9fa;
    }
    
    .b-sch-event {
      border-radius: 4px !important;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12) !important;
    }
    
    .b-sch-event-content {
      padding: 4px 8px !important;
      font-size: 12px !important;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="scheduler-container">
      <div id="scheduler">
        <div class="loading">Loading scheduler...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { SchedulerPro } from './js/build/schedulerpro.wc.module.js';

    const A = p => Array.isArray(p) ? p : (Array.isArray(p?.data) ? p.data : (Array.isArray(p?.results) ? p.results : []));
    const S = v => (v==null ? undefined : (typeof v === 'string' ? v : String(v)));

    async function fetchJSON(url){ 
      const r = await fetch(url); 
      return r.ok ? r.json() : []; 
    }

    async function initScheduler() {
      try {
        console.log('Fetching data...');
        const [resourcesRaw, opsRaw, depsRaw] = await Promise.all([
          fetchJSON('/api/resources'),
          fetchJSON('/api/pt-operations'),
          fetchJSON('/api/pt-dependencies')
        ]);
        
        const resourcesSrc = A(resourcesRaw);
        const ops = A(opsRaw);
        const deps = A(depsRaw);
        
        console.log('Resources:', resourcesSrc.length);
        console.log('Operations:', ops.length);
        console.log('Dependencies:', deps.length);

        // Map resources with proper IDs
        const resources = resourcesSrc.map((r, i) => ({
          id: S(r.resource_id) ?? S(r.id) ?? `r${i}`,
          name: r.name || r.displayName || `Resource ${i+1}`,
          eventColor: r.bottleneck ? '#dc3545' : '#0066cc'
        }));

        // Filter and map operations
        const validOps = ops.filter(op => op.scheduled_start && op.resource_id);
        console.log('Valid operations with dates and resources:', validOps.length);
        
        const events = validOps.map((op, i) => {
          const start = new Date(op.scheduled_start);
          const end = op.scheduled_end ? new Date(op.scheduled_end) : new Date(start.getTime() + 4*60*60*1000);
          
          return {
            id: S(op.id) ?? `e${i}`,
            name: op.name || `Operation ${i+1}`,
            startDate: start,
            endDate: end,
            resourceId: S(op.resource_id),
            percentDone: op.percent_finished || 0,
            eventColor: op.job_priority === 1 ? '#dc3545' : '#0066cc'
          };
        });

        // Map dependencies
        const dependencies = deps.map((dep, i) => ({
          id: S(dep.id) ?? `d${i}`,
          from: S(dep.from),
          to: S(dep.to),
          type: dep.type || 2  // Finish-to-Start
        }));

        // Find date range from operations
        let minDate = new Date();
        let maxDate = new Date();
        
        if (events.length > 0) {
          const dates = events.flatMap(e => [e.startDate, e.endDate]).filter(d => d);
          minDate = new Date(Math.min(...dates));
          maxDate = new Date(Math.max(...dates));
        } else {
          // Default to current month if no operations
          minDate = new Date();
          minDate.setDate(1);
          maxDate = new Date(minDate);
          maxDate.setMonth(maxDate.getMonth() + 1);
        }
        
        // Add padding to dates
        minDate.setDate(minDate.getDate() - 7);
        maxDate.setDate(maxDate.getDate() + 7);

        console.log('Date range:', minDate, 'to', maxDate);
        console.log('Sample event:', events[0]);

        // Clear loading message
        document.getElementById('scheduler').innerHTML = '';

        // Create scheduler instance
        const scheduler = new SchedulerPro({
          appendTo: 'scheduler',
          startDate: minDate,
          endDate: maxDate,
          viewPreset: 'weekAndDayLetter',
          rowHeight: 45,
          barMargin: 5,
          eventStyle: 'rounded',
          
          columns: [
            { 
              type: 'rownumber', 
              width: 50,
              text: '#'
            },
            { 
              text: 'Resource', 
              field: 'name', 
              width: 200,
              cellCls: 'resource-name'
            }
          ],

          resources: resources,
          events: events,
          dependencies: dependencies,

          features: {
            stripe: true,
            sort: {
              disabled: false,
              multiSort: false
            },
            cellEdit: false,
            eventDrag: true,
            eventResize: true,
            eventEdit: {
              disabled: false
            },
            dependencies: {
              disabled: false,
              showTooltip: true
            },
            percentBar: true,
            timeRanges: {
              showHeaderElements: true,
              showCurrentTimeLine: true
            },
            nonWorkingTime: {
              disabled: false
            }
          },
          
          // Better scrolling
          infiniteScroll: false,
          
          // Event renderer for better display
          eventRenderer({ eventRecord, resourceRecord, renderData }) {
            renderData.eventColor = eventRecord.eventColor;
            
            return {
              class: 'custom-event',
              children: [
                {
                  tag: 'div',
                  class: 'event-name',
                  text: eventRecord.name
                }
              ]
            };
          }
        });

        console.log('Scheduler created successfully');
        
        // Fit to view after a short delay
        setTimeout(() => {
          if (scheduler.zoomToFit) {
            scheduler.zoomToFit({
              leftMargin: 50,
              rightMargin: 50
            });
          }
        }, 500);

      } catch (err) {
        console.error('Error initializing scheduler:', err);
        document.getElementById('scheduler').innerHTML = 
          `<div class="error-message">Error loading scheduler: ${err.message}<br>Check console for details.</div>`;
      }
    }

    // Initialize on page load
    initScheduler();
  </script>
</body>
</html>