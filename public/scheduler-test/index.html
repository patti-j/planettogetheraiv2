<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PlanetTogether Scheduler — Standalone Smoke Test</title>

  <!-- Bryntum theme CSS (adjust path if yours is different) -->
  <link rel="stylesheet" href="/schedulerpro.classic-light.css" />

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    #app { height: 100vh; display: flex; flex-direction: column; }
    #scheduler { flex: 1; overflow: auto; }
    .pt-scheduler-root { 
      height: 100%; 
      transform: none !important; 
      zoom: normal !important;
      min-height: 800px;
    }
    .pt-scheduler-root .b-grid,
    .pt-scheduler-root .b-grid-body,
    .pt-scheduler-root .b-grid-row,
    .pt-scheduler-root .b-grid-cell,
    .pt-scheduler-root .b-sch-timeaxis-cell { font-size: 13px; line-height: 1.2; }
    .loading { position:absolute; inset:0; display:grid; place-items:center; background: rgba(0,0,0,.03); font-family: system-ui, sans-serif; }
    .hidden { display:none; }
    /* Ensure scheduler has enough vertical space */
    .b-schedulerpro { min-height: 100%; }
  </style>
</head>
<body>
  <div id="app">
    <div id="loading" class="loading">Loading scheduler…</div>
    <div id="scheduler" class="pt-scheduler-root"></div>
  </div>

  <!-- Bryntum UMD bundle (adjust path if served elsewhere) -->
  <script src="/schedulerpro.umd.js"></script>

  <script>
  (function () {
    // === Configure your endpoints (or inject globals) ===
    const RESOURCES_ENDPOINT  = '/api/resources';
    const OPERATIONS_ENDPOINT = '/api/pt-operations';

    // Helpers
    const A = (p) => Array.isArray(p) ? p
              : (Array.isArray(p?.data) ? p.data
              : (Array.isArray(p?.results) ? p.results
              : (Array.isArray(p?.items) ? p.items : [])));
    const S = (v) => (v==null ? undefined : (typeof v === 'string' ? v : String(v)));

    const opColor = (name) => {
      const s = (name || '').toLowerCase();
      if (s.includes('whirlpool')) return 'blue';
      if (s.includes('boil')) return 'indigo';
      if (s.includes('mash')) return 'cyan';
      if (s.includes('ferment')) return 'green';
      if (s.includes('matur')) return 'purple';
      return 'teal';
    };

    async function loadData() {
      // MODE A: If you set globals in the page before this script, we use them
      if (Array.isArray(window.__RESOURCES__) || Array.isArray(window.__OPERATIONS__)) {
        return {
          resources: A(window.__RESOURCES__),
          operations: A(window.__OPERATIONS__)
        };
      }
      // MODE B: Default to API fetch
      const [r, o, c] = await Promise.all([ 
        fetch(RESOURCES_ENDPOINT), 
        fetch(OPERATIONS_ENDPOINT),
        fetch('/api/resource-capabilities')
      ]);
      const resources = r.ok ? await r.json() : [];
      const operations = o.ok ? await o.json() : [];
      const capabilities = c.ok ? await c.json() : {};
      return { resources: A(resources), operations: A(operations), capabilities };
    }

    function buildStores({ resources, operations, capabilities }) {
      // Resource canonical id = STRING resource_id
      const resourceRows = [
        { id: 'unscheduled', name: 'Unscheduled', category: 'Queue', eventColor: '#808080' },
        ...resources.map((r, i) => ({
          id: S(r.resource_id) ?? S(r.id) ?? `r${i}`,
          name: r.name ?? r.displayName ?? `Resource ${i + 1}`,
          category: r.category ?? r.plantName ?? r.area ?? 'Default',
          active: r.active !== false,
          eventColor: r.isBottleneck ? 'red' : (i % 2 ? 'green' : 'blue')
        }))
      ];

      // Events (no resourceId here if using assignments)
      const events = [];
      const seen = new Set();
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        const id = S(op.id) ?? `e${i}`;
        if (seen.has(id)) continue;
        seen.add(id);

        const start = op.startDate ? new Date(op.startDate)
                    : (op.scheduled_start ? new Date(op.scheduled_start) : null);
        let end = op.endDate ? new Date(op.endDate)
                : (op.scheduled_end ? new Date(op.scheduled_end) : null);
        if (start && !end && op.duration) {
          end = new Date(start);
          const hrs = op.durationUnit === 'day' ? (op.duration * 24) : (+op.duration || 0);
          end.setHours(end.getHours() + hrs);
        }

        events.push({
          id,
          name: op.name ?? op.operationName ?? `Op ${i + 1}`,
          startDate: start || null,
          endDate: end || null,
          duration: Math.min(op.duration || 4, 8), // Cap at 8 hours, default to 4
          durationUnit: op.durationUnit || 'hour',
          percentDone: op.percent_finished ?? op.percent_done ?? op.percentDone ?? 0,
          isUnscheduled: false,
          eventColor: opColor(op.name || op.operationName),
          draggable: true,
          resizable: true,
          jobName: op.jobName || op.job_name || '',
          jobId: op.jobId || op.job_id || ''
        });
      }

      // Assignments from op.resourceId -> resource.resource_id (string domain)
      const resSet = new Set(resourceRows.map(r => r.id));
      const assignments = [];
      for (const op of operations) {
        const eid = S(op.id);
        const rid = S(op.resourceId ?? op.resource_id);
        if (!eid) continue;
        if (rid && resSet.has(rid)) assignments.push({ id: `a_${eid}`, eventId: eid, resourceId: rid });
      }

      // Orphans → keep visible and gray on Unscheduled lane
      const assigned = new Set(assignments.map(a => a.eventId));
      for (const ev of events) if (!assigned.has(ev.id)) { ev.isUnscheduled = true; ev.eventColor = '#808080'; }

      // Dependencies - connect successive operations within the same job
      const dependencies = [];
      
      // Group operations by jobId
      const opsByJob = {};
      for (const op of operations) {
        const jobId = op.jobId || op.job_id;
        if (!jobId) continue;
        if (!opsByJob[jobId]) opsByJob[jobId] = [];
        opsByJob[jobId].push(op);
      }
      
      // Create dependencies for each job's operations
      let depId = 1;
      for (const jobId in opsByJob) {
        const jobOps = opsByJob[jobId];
        
        // Sort by start date to get proper sequence
        jobOps.sort((a, b) => {
          const aStart = a.scheduled_start || a.startDate;
          const bStart = b.scheduled_start || b.startDate;
          if (!aStart || !bStart) return 0;
          return new Date(aStart) - new Date(bStart);
        });
        
        // Create dependency chain
        for (let i = 0; i < jobOps.length - 1; i++) {
          const fromOp = jobOps[i];
          const toOp = jobOps[i + 1];
          
          dependencies.push({
            id: `dep_${depId++}`,
            from: S(fromOp.id),
            to: S(toOp.id),
            type: 2, // Finish-to-Start dependency
            lag: 0,
            lagUnit: 'hour'
          });
        }
      }
      
      console.log(`Created ${dependencies.length} dependencies across ${Object.keys(opsByJob).length} jobs`);
      console.log('Dependencies:', dependencies);

      return { resourceRows, events, assignments, dependencies, capabilities };
    }

    async function main() {
      const loading = document.getElementById('loading');
      try {
        const { SchedulerPro } = window.bryntum.schedulerpro;

        const start = new Date(); start.setHours(0,0,0,0);
        const end   = new Date(start); end.setDate(start.getDate() + 14); end.setHours(23,59,59,999);

        const raw = await loadData();
        const { resourceRows, events, assignments, dependencies, capabilities } = buildStores(raw);

        console.table(resourceRows.slice(0,10).map(r => ({ id: r.id, name: r.name })));
        console.table(assignments.slice(0,10));
        console.log('Resource Capabilities:', capabilities);

        const scheduler = new SchedulerPro({
          appendTo: document.getElementById('scheduler'),
          startDate: start,
          endDate: end,
          viewPreset: 'dayAndWeek',
          rowHeight: 50,  // Reduced height to fit more rows
          barMargin: 5,
          autoHeight: false,  // Don't auto-adjust height
          minHeight: 600,     // Minimum scheduler height
          
          // Combined toolbar with all controls
          tbar: [],
          
          project: {
            resourceStore:   { data: resourceRows },
            eventStore:      { data: events },
            assignmentStore: { data: assignments },
            dependencyStore: { data: dependencies }
          },
          features: {
            stripe: true,
            dependencies: {
              disabled: false,
              showTooltip: true,
              drawOnEventResize: true,
              markerStyle: 'arrow',  // Make sure arrow markers are visible
              lineStyle: 'solid'     // Use solid lines for better visibility
            },
            eventDrag: { 
              showTooltip: true, 
              constrainDragToResource: false
            },
            eventResize: { 
              showTooltip: true
            },
            eventTooltip: {
              template: ({ eventRecord, resourceRecord }) => `
                <div style="padding:10px">
                  <strong>${eventRecord.name}</strong><br>
                  ${eventRecord.jobName ? `Job: <strong>${eventRecord.jobName}</strong><br>` : ''}
                  ${eventRecord.jobId ? `Job #: ${eventRecord.jobId}<br>` : ''}
                  Resource: <em>${resourceRecord?.name ?? '—'}</em><br>
                  ${eventRecord.startDate ? `Start: ${eventRecord.startDate.toLocaleString()}<br>` : ''}
                  ${eventRecord.duration ? `Duration: ${eventRecord.duration} ${eventRecord.durationUnit || 'hour'}<br>` : ''}
                  Progress: ${eventRecord.percentDone ?? 0}%
                  ${eventRecord.isUnscheduled ? '<br><span style="color:orange;font-weight:bold;">⚠ Drag to a resource to schedule</span>' : ''}
                </div>
              `
            },
            timeRanges: { showCurrentTimeLine: true },
            percentBar: true,
            nonWorkingTime: true,
            eventMenu: true,
            scheduleMenu: true
          },
          columns: [
            { type: 'rownumber', width: 40 },
            { text: 'Resource', field: 'name', width: 220, flex: 1,
              renderer: ({ record }) => `${record.name} (${record.id})` },
            { text: 'Department', field: 'category', width: 120 }
          ],
          // show assigned rid on each chip for clarity
          eventRenderer: ({ eventRecord, assignmentRecord }) => {
            const rid = assignmentRecord?.resourceId ?? 'unassigned';
            return `${eventRecord.name} [${rid}]`;
          }
        });

        // Helper function to get operation type from event name
        const getOperationType = (eventName) => {
          if (!eventName) return 'Other';
          const name = eventName.toLowerCase();
          if (name.includes('mill')) return 'Milling';
          if (name.includes('mash') && name.includes('decoction')) return 'Decoction';
          if (name.includes('mash')) return 'Mashing';
          if (name.includes('lauter')) return 'Lautering';
          if (name.includes('boil')) return 'Boiling';
          if (name.includes('ferment')) return 'Fermentation';
          if (name.includes('lager')) return 'Lagering';
          if (name.includes('condition')) return 'Conditioning';
          if (name.includes('packag')) return 'Packaging';
          if (name.includes('dry hop')) return 'Dry Hopping';
          return 'Other';
        };

        // Enforce: Check both resource capabilities AND no overlaps
        const validateOperation = ({ resourceRecord, startDate, endDate, eventRecord }) => {
          // Skip validation for unscheduled lane
          if (!resourceRecord || resourceRecord.id === 'unscheduled') {
            return true;
          }

          // Check resource capabilities
          const operationType = getOperationType(eventRecord?.name);
          const resourceCapabilities = capabilities[resourceRecord.id] || [];
          
          if (!resourceCapabilities.includes(operationType)) {
            console.warn(`Resource ${resourceRecord.name} cannot perform ${operationType} operations`);
            return { 
              valid: false, 
              message: `${resourceRecord.name} cannot perform ${operationType} operations` 
            };
          }

          // Check for overlaps
          const available = scheduler.isDateRangeAvailable(startDate, endDate, resourceRecord, eventRecord);
          if (!available) {
            return { valid: false, message: `Time conflict on ${resourceRecord?.name}` };
          }

          return true;
        };

        // Apply validators including capability check
        scheduler.features.eventDrag.validatorFn   = validateOperation;
        scheduler.features.eventResize.validatorFn = validateOperation;

        // Validate ALL assignment changes (not just drag and drop)
        scheduler.project.assignmentStore.on('beforeAdd', ({ record, source }) => {
          const resource = scheduler.resourceStore.getById(record.resourceId);
          const event = scheduler.eventStore.getById(record.eventId);
          
          // Skip validation for unscheduled lane
          if (!resource || !event || resource.id === 'unscheduled') {
            return;
          }
          
          // Check resource capabilities
          const operationType = getOperationType(event.name);
          const resourceCapabilities = capabilities[resource.id] || [];
          
          if (!resourceCapabilities.includes(operationType)) {
            console.warn(`Blocking assignment: ${resource.name} cannot perform ${operationType}`);
            scheduler.toast?.(`${resource.name} cannot perform ${operationType} operations`);
            return false; // Block the assignment
          }
          
          // Check for time conflicts (if event has dates)
          if (event.startDate && event.endDate) {
            if (!scheduler.isDateRangeAvailable(event.startDate, event.endDate, resource, event)) {
              console.warn(`Blocking assignment: Resource ${resource.name} is busy at that time`);
              scheduler.toast?.('That resource is already busy for that time range.');
              return false;
            }
          }
        });

        // Also guard assignment changes created via DnD between rows
        scheduler.on('beforeEventDropFinalize', ({ context }) => {
          const { eventRecord, newResource, startDate, endDate } = context;
          
          // Skip validation for unscheduled lane
          if (newResource && newResource.id !== 'unscheduled') {
            // Check capabilities first
            const operationType = getOperationType(eventRecord?.name);
            const resourceCapabilities = capabilities[newResource.id] || [];
            
            if (!resourceCapabilities.includes(operationType)) {
              console.warn(`Blocking drop: ${newResource.name} cannot perform ${operationType}`);
              scheduler.toast?.(`${newResource.name} cannot perform ${operationType} operations`);
              // Cancel the drop operation
              context.valid = false;
              return false;
            }
            
            // Check for time conflicts
            if (!scheduler.isDateRangeAvailable(startDate, endDate, newResource, eventRecord)) {
              console.warn(`Blocking drop: Resource ${newResource?.name} is busy at that time`);
              scheduler.toast?.('That resource is already busy for that time range.');
              // Cancel the drop operation
              context.valid = false;
              return false;
            }
          }
        });

        // Also validate when events are dragged to different resources
        scheduler.on('beforeEventDrag', ({ eventRecord, resourceRecord, context }) => {
          if (resourceRecord && resourceRecord.id !== 'unscheduled') {
            const operationType = getOperationType(eventRecord?.name);
            const resourceCapabilities = capabilities[resourceRecord.id] || [];
            
            if (!resourceCapabilities.includes(operationType)) {
              // Show a visual indicator that this is not allowed
              context.external.invalid = true;
            }
          }
        });
        
        console.log('Overlap prevention and capability validation enabled for all operations');
        
        // Step 1 (optional): Smooth trackpad zoom with Ctrl + wheel
        scheduler.on('scheduleMouseWheel', ({ event }) => {
          if (event.ctrlKey) {
            event.preventDefault();
            event.deltaY < 0 ? scheduler.zoomIn() : scheduler.zoomOut();
          }
        });

        // Normalize API conflicts on load (move overlapping events to Unscheduled)
        const cleanupOverlaps = () => {
          const p = scheduler.project;
          const byRes = new Map();

          p.assignmentStore.forEach(a => {
            const ev = a.event, res = a.resource;
            if (!ev || !res || !ev.startDate || !ev.endDate) return;
            (byRes.get(res.id) ?? byRes.set(res.id, []).get(res.id)).push(ev);
          });

          for (const [rid, evs] of byRes) {
            evs.sort((a,b) => a.startDate - b.startDate);
            for (let i = 1; i < evs.length; i++) {
              const prev = evs[i-1], curr = evs[i];
              if (prev.endDate > curr.startDate) {
                const asg = p.assignmentStore.find(r => r.eventId === curr.id && r.resourceId === rid);
                if (asg) {
                  p.assignmentStore.remove(asg);
                  curr.isUnscheduled = true;
                  curr.eventColor = '#808080';
                  console.log(`Moved overlapping event "${curr.name}" from ${rid} to Unscheduled`);
                }
              }
            }
          }
        };

        // Run cleanup after a slight delay to ensure stores are populated
        setTimeout(() => {
          cleanupOverlaps();
          // Refresh the scheduler display after cleanup
          scheduler.refresh();
        }, 100);

        // Step 2: "Pack Unscheduled" - naive auto-pack for unscheduled events
        async function packUnscheduled() {
          const p = scheduler.project;
          await p.waitForPropagate?.(); // ensure calculations are up to date

          // Identify unscheduled events (no assignment or flagged during import)
          const evs = p.eventStore.query(ev => !p.assignmentStore.find(r => r.eventId === ev.id));

          // Cheap matcher: allow all resources. Replace with smarter filters when ready.
          const resources = p.resourceStore.records.filter(r => r.id !== 'unscheduled');

          let placed = 0;
          for (const ev of evs) {
            const durMs = ev.endDate && ev.startDate ? ev.endDate - ev.startDate : (ev.duration || 2) * 3600_000;
            // start searching from the scheduler start
            let candidateStart = ev.startDate || new Date(scheduler.startDate);
            let candidateEnd   = new Date(candidateStart.getTime() + durMs);

            outer:
            for (const res of resources) {
              // Check if resource can perform this operation
              const operationType = getOperationType(ev.name);
              const resourceCapabilities = capabilities[res.id] || [];
              if (!resourceCapabilities.includes(operationType)) {
                continue; // Skip resources that can't perform this operation
              }
              
              // shift forward until free
              for (let hop = 0; hop < 200; hop++) {
                if (scheduler.isDateRangeAvailable(candidateStart, candidateEnd, res, ev)) {
                  // assign & set dates
                  p.assignmentStore.add({ id : `a_${ev.id}_${res.id}`, eventId : ev.id, resourceId : res.id });
                  ev.set({ startDate : candidateStart, endDate : candidateEnd, isUnscheduled : false });
                  placed++;
                  break outer;
                }
                // move to the end of the next blocking event on this resource
                const blockers = p.eventStore.query(x =>
                  p.assignmentStore.find(a => a.eventId === x.id && a.resourceId === res.id) &&
                  x.endDate > candidateStart && x.startDate < candidateEnd
                ).sort((a,b) => a.endDate - b.endDate);
                candidateStart = blockers.length ? new Date(blockers[blockers.length-1].endDate) : new Date(candidateEnd);
                candidateEnd   = new Date(candidateStart.getTime() + durMs);
              }
            }
          }

          scheduler.toast?.(`${placed} event(s) scheduled`);
        }

        // Pack Unscheduled button will be added to toolbar later
        
        // Step 3: Save adjusted schedules (Option B - Manual collect and POST)
        function packStoreChanges(store) {
          const added   = store.added?.map(r => r.data) || [];
          const removed = store.removed?.map(r => ({ id : r.id })) || [];

          const updated = (store.modifiedRecords?.length ? store.modifiedRecords
                            : Array.from(store.modified || []))
                          .map(r => ({ id : r.id, ...r.changes }));

          return { added, updated, removed };
        }

        async function saveManual() {
          const p = scheduler.project;
          const payload = {
            resources   : packStoreChanges(p.resourceStore),
            events      : packStoreChanges(p.eventStore),
            assignments : packStoreChanges(p.assignmentStore),
            dependencies: packStoreChanges(p.dependencyStore)
          };

          console.log('Saving changes:', payload);
          
          const res = await fetch('/api/scheduler/sync', {
            method : 'POST',
            headers: { 'Content-Type':'application/json' },
            body   : JSON.stringify(payload)
          });
          if (!res.ok) throw new Error('Sync HTTP ' + res.status);
          
          // Commit changes on successful save
          p.resourceStore.commit();
          p.eventStore.commit();
          p.assignmentStore.commit();
          p.dependencyStore.commit();
        }

        // Step 4: Enable Undo/Redo (safety net)
        scheduler.project.stm.enable();
        
        // Set all toolbar items at once to avoid separator issues
        scheduler.tbar = {
          items: [
            '->',
            { type: 'button', 
              text: 'Today', 
              tooltip: 'Scroll to today or first event',
              onAction: () => {
                const today = new Date();
                const events = scheduler.eventStore.records;
                
                // Check if today is within the scheduler's time range
                if (today >= scheduler.startDate && today <= scheduler.endDate) {
                  scheduler.scrollToDate(today, { block : 'center', animate: true });
                  scheduler.toast?.('Scrolled to today');
                } else if (events.length > 0) {
                  // If today is outside range, scroll to the first event
                  const firstEvent = events.reduce((earliest, event) => {
                    if (!event.startDate) return earliest;
                    return !earliest || event.startDate < earliest.startDate ? event : earliest;
                  }, null);
                  
                  if (firstEvent?.startDate) {
                    scheduler.scrollToDate(firstEvent.startDate, { block : 'center', animate: true });
                    scheduler.toast?.('Scrolled to first scheduled event');
                  }
                } else {
                  scheduler.scrollToDate(scheduler.startDate, { block : 'center', animate: true });
                  scheduler.toast?.('Scrolled to schedule start');
                }
              }
            },
            { type: 'button', 
              text: 'Fit to View', 
              tooltip: 'Zoom to show all events',
              onAction: () => {
                // Get all events with dates
                const events = scheduler.eventStore.records.filter(e => e.startDate && e.endDate);
                
                if (events.length === 0) {
                  scheduler.toast?.('No scheduled events to fit');
                  return;
                }
                
                // Find the date range of all events
                let minDate = null;
                let maxDate = null;
                
                events.forEach(event => {
                  if (!minDate || event.startDate < minDate) {
                    minDate = event.startDate;
                  }
                  if (!maxDate || event.endDate > maxDate) {
                    maxDate = event.endDate;
                  }
                });
                
                if (minDate && maxDate) {
                  // Add some padding (5% on each side)
                  const range = maxDate - minDate;
                  const padding = range * 0.05;
                  const paddedStart = new Date(minDate.getTime() - padding);
                  const paddedEnd = new Date(maxDate.getTime() + padding);
                  
                  // Use zoomToSpan to fit the date range in view
                  scheduler.zoomToSpan({
                    startDate: paddedStart,
                    endDate: paddedEnd,
                    centerDate: new Date((minDate.getTime() + maxDate.getTime()) / 2)
                  });
                  
                  scheduler.toast?.('Zoomed to fit all events');
                }
              }
            },
            '|',
            { type: 'button', text: '–', tooltip: 'Zoom out', onAction: () => scheduler.zoomOut() },
            { type: 'slider', width: 120, min: 0, max: 20,
              value: 10,
              tooltip: 'Zoom level',
              onChange: ({ value }) => scheduler.zoomToLevel(value)
            },
            { type: 'button', text: '+', tooltip: 'Zoom in', onAction: () => scheduler.zoomIn() },
            '|',  // Use pipe separator instead of object separator
            { type: 'button', text: 'Pack Unscheduled', cls: 'b-raised', onAction: packUnscheduled },
            { type: 'button', 
              text: 'Save', 
              cls: 'b-raised b-green', 
              onAction: () => saveManual()
                .then(() => scheduler.toast?.('Changes saved successfully'))
                .catch((e) => {
                  console.error('Save failed:', e);
                  scheduler.toast?.('Save failed: ' + e.message);
                }) 
            },
            { type: 'button', text: 'Undo', onAction: () => scheduler.project.stm.undo() },
            { type: 'button', text: 'Redo', onAction: () => scheduler.project.stm.redo() }
          ]
        };

        // Expose for quick debugging
        window.scheduler = scheduler;
        window.cleanupOverlaps = cleanupOverlaps;
        window.packUnscheduled = packUnscheduled;
        window.saveManual = saveManual;
      } catch (e) {
        console.error(e);
        alert('Failed to initialize scheduler: ' + (e && e.message || e));
      } finally {
        loading?.classList.add('hidden');
      }
    }

    // Kick off
    main();
  })();
  </script>
</body>
</html>