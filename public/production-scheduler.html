<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Force refresh timestamp: 2025-10-01 21:40 v2 -->
    <title>Production Schedule - PlanetTogether</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <!-- Bryntum Scheduler Pro CSS -->
    <link rel="stylesheet" href="/schedulerpro.classic-light.css?v=633" id="scheduler-theme">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: auto;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 14px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .header h1 {
            color: #000000;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.9);
            padding: 0.75rem 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding-right: 0.75rem;
            border-right: 1px solid #e0e0e0;
            flex-shrink: 0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar label {
            font-size: 0.8125rem;
            color: #666;
            font-weight: 500;
            white-space: nowrap;
        }

        .toolbar select,
        .toolbar button {
            padding: 0.375rem 0.625rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar select:hover,
        .toolbar button:hover {
            background: #f5f5f5;
            border-color: #999;
        }

        .toolbar button {
            background: white;
            color: #333 !important;
            border: 1px solid #e0e0e0;
            font-weight: 400;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            transition: all 0.2s;
        }

        .toolbar button:hover {
            background: #e8f5e9;
            transform: translateY(-1px);
            border-color: #4CAF50;
            color: #2e7d32 !important;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.2);
        }
        
        .toolbar button.icon-only {
            padding: 0.375rem 0.5rem;
            min-width: 32px;
        }
        
        .toolbar button svg {
            width: 16px;
            height: 16px;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .toolbar {
                padding: 0.5rem 1rem;
                gap: 0.5rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .toolbar-group {
                padding-right: 0.75rem;
                flex-shrink: 0;
            }
            
            .toolbar label {
                display: none; /* Hide labels on mobile to save space */
            }
            
            .toolbar button span:not(.icon-text) {
                display: none; /* Hide button text on mobile, keep icons */
            }
            
            .toolbar button {
                padding: 0.5rem;
                min-width: 40px;
                min-height: 40px;
            }
            
            .toolbar select {
                max-width: 120px;
            }
            
            /* Make scheduler touch-friendly */
            .b-sch-event {
                min-height: 30px !important;
            }
            
            .b-grid-cell {
                padding: 4px !important;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1rem;
            }
            
            .toolbar {
                padding: 0.5rem;
            }
            
            /* Stack toolbar items vertically on very small screens */
            .toolbar-group {
                border-right: none;
                width: 100%;
                justify-content: space-between;
            }
        }

        .scheduler-container {
            flex: 1;
            margin: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #scheduler {
            flex: 1;
            min-height: 0;
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.95);
            padding: 0.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            color: #666;
            border-top: 1px solid #e0e0e0;
            flex-shrink: 0;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ff4444;
            color: white;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem;
            text-align: center;
        }
        
        /* Dark theme overrides */
        .dark-theme {
            background: #1a1a1a;
        }
        
        .dark-theme .header {
            background: rgba(30, 30, 30, 0.95);
            color: white;
        }
        
        .dark-theme .header h1 {
            color: #60a5fa;
        }
        
        .dark-theme .toolbar {
            background: rgba(40, 40, 40, 0.9);
            border-bottom-color: #444;
        }
        
        .dark-theme .toolbar label {
            color: #ccc;
        }
        
        .dark-theme .toolbar button {
            background: #2a2a2a;
            color: #e0e0e0 !important;
            border-color: #444;
        }
        
        .dark-theme .toolbar button:hover {
            background: #1b5e20;
            color: #a5d6a7 !important;
            border-color: #4CAF50;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
        }
        
        .dark-theme .toolbar select {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-theme .toolbar select:hover {
            background: #333;
            border-color: #666;
        }
        
        .dark-theme .status-bar {
            background: rgba(30, 30, 30, 0.95);
            color: #ccc;
            border-top-color: #444;
        }
        
        .dark-theme .scheduler-container {
            background: #2a2a2a;
        }
        
        /* Dark theme for scheduler using filter */
        .dark-theme #scheduler {
            filter: invert(0.9) hue-rotate(180deg);
        }
        
        /* Re-invert images and icons in dark mode */
        .dark-theme #scheduler img,
        .dark-theme #scheduler .b-icon {
            filter: invert(1) hue-rotate(-180deg);
        }
        
        /* Dependency lines styling - SOLID and DARK */
        .b-sch-dependency {
            stroke: #2d3748 !important; /* Very dark gray */
            stroke-width: 2.5 !important;
            opacity: 1 !important;
            stroke-dasharray: none !important; /* SOLID lines */
        }
        
        .b-sch-dependency-arrow {
            fill: #2d3748 !important;
            stroke: #2d3748 !important;
        }
        
        .b-sch-dependency:hover {
            stroke: #1a202c !important; /* Almost black on hover */
            stroke-width: 3 !important;
            opacity: 1 !important;
        }
        
        .b-sch-dependency-arrow:hover {
            fill: #1a202c !important;
            stroke: #1a202c !important;
        }
        
        /* Visual-only dependencies - SOLID dark lines */
        .b-sch-dependency.b-inactive,
        .b-sch-dependency.visual-dependency {
            stroke: #2d3748 !important; /* Dark gray */
            stroke-width: 2.5 !important;
            opacity: 0.9 !important;
            stroke-dasharray: none !important; /* SOLID - no dashes */
        }
        
        .b-sch-dependency.b-inactive .b-sch-dependency-arrow,
        .b-sch-dependency.visual-dependency .b-sch-dependency-arrow {
            fill: #2d3748 !important;
            stroke: #2d3748 !important;
            opacity: 0.9 !important;
        }
        
        /* Critical path dependency styling */
        .b-sch-dependency.b-critical {
            stroke: #ff4444 !important;
            stroke-width: 3 !important;
        }
        
        .b-sch-dependency.b-critical .b-sch-dependency-arrow {
            fill: #ff4444 !important;
            stroke: #ff4444 !important;
        }
        
        /* Header actions styling */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        /* Navigation Menu - Match main app */
        .nav-menu {
            position: fixed;
            top: 0;
            left: -320px;
            width: 320px;
            height: 100vh;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            transition: left 0.3s ease;
            z-index: 2000;
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.15);
        }
        
        .nav-menu.open {
            left: 0;
        }
        
        .nav-menu-header {
            background: #0f172a;
            color: #f8fafc;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }
        
        .nav-menu-header h3 {
            margin: 0;
        }
        
        .close-menu, .close-max-ai {
            background: transparent;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
        }
        
        .nav-menu-items {
            padding: 1rem;
        }
        
        .nav-item {
            display: block;
            padding: 0.75rem 1rem;
            color: #333;
            text-decoration: none;
            border-radius: 4px;
            transition: background 0.2s;
            margin-bottom: 0.5rem;
        }
        
        .nav-item:hover {
            background: #f5f5f5;
        }
        
        .nav-item.active {
            background: #f0f0f0;
            color: #333;
            font-weight: 500;
        }
        
        /* Max AI Panel - Match main app */
        .max-ai-panel {
            position: fixed;
            top: 0;
            right: 0; /* Visible by default to showcase scheduler features */
            width: 400px;
            height: 100vh;
            background: #ffffff;
            border-left: 1px solid #e2e8f0;
            transition: right 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
        }
        
        .max-ai-panel.closed {
            right: -400px;
        }
        
        .max-ai-header {
            background: #0f172a;
            color: #f8fafc;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }
        
        .max-ai-header h3 {
            margin: 0;
        }
        
        .max-ai-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .max-ai-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .max-ai-message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .max-ai-message.assistant {
            background: #f0f0f0;
            font-size: 0.9rem;
        }
        
        .max-ai-message.user {
            background: rgba(59, 130, 246, 0.1);
            margin-left: 2rem;
        }
        
        .max-ai-message ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }
        
        .max-ai-message strong {
            font-weight: 600;
            color: #333;
        }
        
        .max-ai-input {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #e0e0e0;
            gap: 0.5rem;
        }
        
        .max-ai-input input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.875rem;
        }
        
        .max-ai-input button {
            padding: 0.5rem 1rem;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .max-ai-input button:hover {
            background: #555;
        }
        
        /* Dark theme for nav menu and Max AI */
        .dark-theme .nav-menu,
        .dark-theme .max-ai-panel {
            background: #0f172a;
            color: #f8fafc;
            border-color: #334155;
        }
        
        .dark-theme .nav-menu-header,
        .dark-theme .max-ai-header {
            background: #1e293b;
            border-bottom-color: #475569;
        }
        
        .dark-theme .constraint-modal-content {
            background: #2a2a2a;
            color: white;
        }
        
        .dark-theme .constraint-modal-header {
            background: #333;
            border-bottom-color: #444;
        }
        
        .dark-theme .constraint-modal-header h2 {
            color: white;
        }
        
        .dark-theme .constraint-modal-close {
            color: #ccc;
        }
        
        .dark-theme .constraint-modal-close:hover {
            color: white;
        }
        
        .dark-theme .constraint-section h3 {
            color: white;
            border-bottom-color: #444;
        }
        
        .dark-theme .constraint-group h4 {
            color: #ccc;
        }
        
        .dark-theme .constraint-item:hover {
            background: #333;
        }
        
        .dark-theme .constraint-label {
            color: #e0e0e0;
        }
        
        .dark-theme .constraint-modal-footer {
            background: #333;
            border-top-color: #444;
        }
        
        .dark-theme .constraint-modal-footer button {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-theme .constraint-modal-footer button:hover {
            background: #1b5e20;
            color: #a5d6a7;
            border-color: #4CAF50;
        }
        
        .dark-theme .constraint-modal-footer button.apply {
            background: #2e7d32;
            color: white;
            border-color: #2e7d32;
        }
        
        .dark-theme .constraint-modal-footer button.apply:hover {
            background: #4CAF50;
        }
        
        .dark-theme .nav-item {
            color: #ccc;
        }
        
        .dark-theme .nav-item:hover {
            background: #333;
        }
        
        .dark-theme .nav-item.active {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .dark-theme .max-ai-message.assistant {
            background: #333;
            color: #ccc;
        }
        
        .dark-theme .max-ai-message.user {
            background: rgba(59, 130, 246, 0.2);
            color: #ccc;
        }
        
        .dark-theme .max-ai-input {
            border-top-color: #444;
        }
        
        .dark-theme .max-ai-input input {
            background: #333;
            color: white;
            border-color: #444;
        }
        
        /* Quick Actions Styles */
        .max-ai-quick-actions {
            padding: 0.75rem;
            background: linear-gradient(to right, #eff6ff, #e0e7ff);
            border-bottom: 1px solid #e0e0e0;
        }
        
        .dark-theme .max-ai-quick-actions {
            background: linear-gradient(to right, #1a2332, #202842);
            border-bottom: 1px solid #444;
        }
        
        .quick-actions-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .dark-theme .quick-actions-title {
            color: #cbd5e0;
        }
        
        .quick-actions-section {
            margin-bottom: 0.75rem;
        }
        
        .quick-actions-label {
            font-size: 0.75rem;
            color: #718096;
            margin-bottom: 0.5rem;
        }
        
        .dark-theme .quick-actions-label {
            color: #a0aec0;
        }
        
        .quick-actions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .quick-action-btn {
            padding: 0.5rem;
            font-size: 0.75rem;
            background: white;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        
        .dark-theme .quick-action-btn {
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #e0e0e0;
        }
        
        .quick-action-btn:hover {
            background: #edf2f7;
            border-color: #666;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dark-theme .quick-action-btn:hover {
            background: #374151;
            border-color: #666;
        }
        
        /* Animation styles */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* Constraint Settings Styles */
        .constraint-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }
        
        .constraint-modal.active {
            display: flex;
        }
        
        .constraint-modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .constraint-modal-header {
            padding: 1rem 1.5rem;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .constraint-modal-header h2 {
            margin: 0;
            font-size: 1.25rem;
            color: #333;
        }
        
        .constraint-modal-close {
            background: transparent;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .constraint-modal-close:hover {
            color: #333;
        }
        
        .constraint-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .constraint-section {
            margin-bottom: 2rem;
        }
        
        .constraint-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            color: #333;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .constraint-group {
            margin-bottom: 1rem;
        }
        
        .constraint-group h4 {
            margin: 0 0 0.5rem 0;
            font-size: 0.95rem;
            color: #555;
            font-weight: 600;
        }
        
        .constraint-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .constraint-item:hover {
            background: #f9f9f9;
        }
        
        .constraint-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
            margin-right: 1rem;
        }
        
        .constraint-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .constraint-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 22px;
        }
        
        .constraint-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        .constraint-toggle input:checked + .constraint-toggle-slider {
            background-color: #4CAF50;
        }
        
        .constraint-toggle input:checked + .constraint-toggle-slider:before {
            transform: translateX(18px);
        }
        
        .constraint-label {
            flex: 1;
            font-size: 0.875rem;
            color: #333;
            cursor: pointer;
        }
        
        .constraint-modal-footer {
            padding: 1rem 1.5rem;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .constraint-modal-footer button {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
        }
        
        .constraint-modal-footer button:hover {
            background: #f5f5f5;
        }
        
        .constraint-modal-footer button.apply {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .constraint-modal-footer button.apply:hover {
            background: #45a049;
        }
        
        .quick-action-btn.full-width {
            grid-column: span 2;
        }
        
        .view-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .view-control-btn {
            flex: 1;
            padding: 0.4rem;
            font-size: 0.7rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .dark-theme .view-control-btn {
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #e0e0e0;
        }
        
        .view-control-btn:hover {
            background: #f7fafc;
            border-color: #a0aec0;
        }
        
        .dark-theme .view-control-btn:hover {
            background: #374151;
        }
        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .scheduler-notification {
            transition: all 0.3s ease-out;
        }
        
        /* Dependency line styling */
        /* Make dependency lines darker and solid in light mode */
        .b-sch-dependency,
        .b-sch-dependency-line {
            stroke: #2d3748 !important; /* Very dark gray for excellent visibility */
            stroke-width: 2.5 !important;
            opacity: 1 !important;
            stroke-dasharray: none !important; /* Solid lines */
        }
        
        /* Visual-only dependency styling - solid lines, slightly darker */
        .visual-dependency,
        .visual-dependency .b-sch-dependency-line {
            stroke: #1a202c !important; /* Almost black for maximum visibility */
            stroke-width: 2.5 !important;
            stroke-dasharray: none !important; /* SOLID lines - no dashes */
            opacity: 0.9 !important;
        }
        
        /* Inactive dependency styling - ensure they don't interfere */
        .b-inactive.b-sch-dependency,
        .b-sch-dependency.b-inactive {
            pointer-events: none !important;
            stroke: #2d3748 !important; /* Dark solid lines */
            stroke-dasharray: none !important; /* SOLID lines */
            opacity: 0.85 !important;
        }
        
        /* Dark theme dependency lines */
        .dark-theme .b-sch-dependency,
        .dark-theme .b-sch-dependency-line {
            stroke: #cbd5e0 !important; /* Light gray for dark theme */
            opacity: 1 !important;
            stroke-dasharray: none !important; /* Solid lines */
        }
        
        .dark-theme .visual-dependency,
        .dark-theme .visual-dependency .b-sch-dependency-line {
            stroke: #e2e8f0 !important; /* Very light for dark theme */
            stroke-dasharray: none !important; /* SOLID lines */
            opacity: 0.95 !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Production Schedule</h1>
        <div class="header-actions">
            <span id="lastUpdate">Last updated: --</span>
        </div>
    </div>
    

    <div class="toolbar">
        <div class="toolbar-group">
            <label for="viewPreset">View:</label>
            <select id="viewPreset">
                <option value="hourAndDay">Hour & Day</option>
                <option value="dayAndWeek" selected>Day & Week</option>
                <option value="weekAndMonth">Week & Month</option>
                <option value="monthAndYear">Month & Year</option>
            </select>
        </div>

        <div class="toolbar-group">
            <label for="planningAreaFilter">Planning Area:</label>
            <select id="planningAreaFilter" data-testid="select-planning-area">
                <option value="all">All Areas</option>
            </select>
            <button id="applyPlanningAreaFilter" class="scheduler-btn" data-testid="button-apply-planning-area" style="margin-left: 0.5rem;">
                Apply Filter
            </button>
        </div>

        <div class="toolbar-group" style="display: flex; gap: 0.25rem;">
            <button id="zoomIn" class="icon-only" title="Zoom In">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <button id="zoomOut" class="icon-only" title="Zoom Out">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <button id="zoomToFit" class="icon-only" title="Fit to View">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                </svg>
            </button>
        </div>

        <div class="toolbar-group">
            <label for="schedulingAlgorithm">Algorithm:</label>
            <select id="schedulingAlgorithm">
                <option value="asap">ASAP (Forward)</option>
                <option value="alap">ALAP (Backward)</option>
                <option value="drum">Theory of Constraints (DBR)</option>
            </select>
            <button id="applyScheduling">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
                <span>Apply</span>
            </button>
        </div>

        <div class="toolbar-group">
            <button id="saveSchedule">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                    <polyline points="7 3 7 8 15 8"></polyline>
                </svg>
                <span>Save</span>
            </button>
            <button id="loadScheduleBtn" onclick="loadSchedule()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                <span>Load</span>
            </button>
            <button id="refreshSchedule" class="icon-only" title="Refresh">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
            </button>
        </div>
    </div>

    <div class="scheduler-container">
        <div id="scheduler"></div>
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <div class="status-bar">
        <span id="operationCount">0 operations scheduled</span>
        <span id="resourceUtilization">Resource utilization: --</span>
    </div>

    <!-- Load Bryntum Scheduler Pro UMD -->
    <script id="bryntum-script" src="/schedulerpro.umd.js?v=633"></script>
    
    <script>
        console.log('üî• SCHEDULER SCRIPT STARTING...');
        
        // Global error handler to catch any errors
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('‚ùå Global error:', msg, 'at', url + ':' + lineNo);
            console.error('Error object:', error);
            
            // Show error in UI
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.innerHTML = `
                    <div style="color: red; font-size: 16px; padding: 20px; background: white; border-radius: 8px;">
                        <h3>Scheduler Error</h3>
                        <p>${msg}</p>
                        <p>Please refresh the page or contact support.</p>
                    </div>
                `;
            }
            return true;
        };
        
        // --- Planning area filter: robust wiring + safe filtering ---
        // Bind once, unconditionally
        document.addEventListener('click', (e) => {
            if (e.target?.id === 'applyPlanningAreaFilter') {
                e.preventDefault();
                handleApplyPlanningAreaFilter().catch(console.error);
            }
        });
        
        // Back-compat for inline onclick="applyPlanningAreaFilter()"
        window.applyPlanningAreaFilter = () => handleApplyPlanningAreaFilter();

        // Filters: resources by planning_area, then events by the visible resources via assignmentStore
        async function handleApplyPlanningAreaFilter() {
            const ddl = document.getElementById('planningAreaFilter');
            const area = ddl?.value || 'all';
            const sch = window.scheduler;
            const { resourceStore, eventStore, assignmentStore } = sch;

            sch.suspendRefresh();
            resourceStore.clearFilters();
            eventStore.clearFilters();

            if (area !== 'all') {
                resourceStore.filter(r => (r.planning_area ?? r.data?.planning_area) === area);
                const visibleResourceIds = new Set(resourceStore.records.map(r => String(r.id)));
                eventStore.filter(ev => {
                    const a = assignmentStore.find(x => x.eventId === ev.id);
                    return a ? visibleResourceIds.has(String(a.resourceId)) : false;
                });
            }

            sch.resumeRefresh();
            sch.refresh(); 
            sch.refreshRows();
            setTimeout(() => sch.zoomToFit({ leftMargin: 50, rightMargin: 50 }), 100);
        }
        
        // Function to render PT dependencies as visual-only SVG lines
        function renderPTDependencyLines(scheduler, dependencies) {
            try {
                console.log(`üé® Rendering ${dependencies.length} PT dependency lines...`);
                
                // Wait for scheduler to be fully rendered
                setTimeout(() => {
                    // Get scheduler element
                    const schedulerEl = scheduler.element;
                    
                    // Remove any existing dependency container
                    const existingSvg = document.querySelector('.pt-dependency-overlay');
                    if (existingSvg) {
                        existingSvg.remove();
                    }
                    
                    // Create SVG container as overlay OUTSIDE Bryntum's DOM
                    const svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svgContainer.setAttribute('class', 'pt-dependency-overlay');
                    svgContainer.style.position = 'absolute';
                    svgContainer.style.top = '0';
                    svgContainer.style.left = '0';
                    svgContainer.style.width = '100%';
                    svgContainer.style.height = '100%';
                    svgContainer.style.pointerEvents = 'none';
                    svgContainer.style.zIndex = '100';
                    
                    // Find the scheduler's main container and add as sibling
                    const schedulerWrapper = schedulerEl.closest('.scheduler-container') || schedulerEl.parentElement;
                    schedulerWrapper.style.position = 'relative';
                    schedulerWrapper.appendChild(svgContainer);
                    
                    // Draw each dependency as a line
                    let linesDrawn = 0;
                    dependencies.forEach(dep => {
                        const fromEvent = scheduler.eventStore.getById(dep.from);
                        const toEvent = scheduler.eventStore.getById(dep.to);
                        
                        if (fromEvent && toEvent) {
                            // Get event elements
                            const fromEl = scheduler.getElementFromEventRecord(fromEvent);
                            const toEl = scheduler.getElementFromEventRecord(toEvent);
                            
                            if (fromEl && toEl) {
                                // Get positions
                                const fromRect = fromEl.getBoundingClientRect();
                                const toRect = toEl.getBoundingClientRect();
                                const containerRect = svgContainer.getBoundingClientRect();
                                
                                // Calculate line coordinates (from right edge of source to left edge of target)
                                const x1 = fromRect.right - containerRect.left;
                                const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
                                const x2 = toRect.left - containerRect.left;
                                const y2 = toRect.top + toRect.height / 2 - containerRect.top;
                                
                                // Create SVG path for dependency line with arrow
                                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                
                                // Create curved line path
                                const midX = (x1 + x2) / 2;
                                const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                                
                                path.setAttribute('d', d);
                                path.setAttribute('stroke', '#2d3748'); // Dark gray
                                path.setAttribute('stroke-width', '2.5');
                                path.setAttribute('fill', 'none');
                                path.setAttribute('marker-end', 'url(#arrowhead)');
                                path.setAttribute('class', 'pt-dependency-line');
                                
                                svgContainer.appendChild(path);
                                linesDrawn++;
                            }
                        }
                    });
                    
                    // Add arrowhead marker definition if not exists
                    if (!svgContainer.querySelector('#arrowhead')) {
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                        marker.setAttribute('id', 'arrowhead');
                        marker.setAttribute('markerWidth', '10');
                        marker.setAttribute('markerHeight', '10');
                        marker.setAttribute('refX', '9');
                        marker.setAttribute('refY', '3');
                        marker.setAttribute('orient', 'auto');
                        
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 0, 10 3, 0 6');
                        polygon.setAttribute('fill', '#2d3748');
                        
                        marker.appendChild(polygon);
                        defs.appendChild(marker);
                        svgContainer.appendChild(defs);
                    }
                    
                    console.log(`‚úÖ PT dependency lines rendered successfully: ${linesDrawn} lines drawn`);
                }, 500); // Wait 500ms for scheduler to render
                
            } catch (error) {
                console.error('‚ùå Error rendering PT dependency lines:', error);
            }
        }
        
        // Make function globally accessible
        window.renderPTDependencyLines = renderPTDependencyLines;
        
        // Wait for DOM to load
        // Guard to prevent multiple initialization attempts
        let schedulerInitialized = false;
        
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ DOMContentLoaded event fired - Starting scheduler initialization...');
            
            // Prevent multiple initialization
            if (schedulerInitialized) {
                console.log('Scheduler already initialized, skipping...');
                return;
            }
            schedulerInitialized = true;
            
            try {
                console.log('üìä Checking if Bryntum is loaded...');
                
                // Wait for Bryntum to be available with retry mechanism
                let retries = 0;
                const maxRetries = 50;
                const retryDelay = 100; // milliseconds
                
                while (retries < maxRetries) {
                    // Debug: Check what's available on window
                    console.log(`üîç Checking for Bryntum library (attempt ${retries + 1}/${maxRetries})...`);
                    
                    // The Bryntum UMD file exports to window.bryntum.schedulerpro namespace
                    if (window.bryntum?.schedulerpro?.SchedulerPro) {
                        window.SchedulerPro = window.bryntum.schedulerpro.SchedulerPro;
                        console.log('‚úÖ Found SchedulerPro at window.bryntum.schedulerpro.SchedulerPro');
                        break;
                    }
                    
                    // Also check for direct SchedulerPro on window
                    if (window.SchedulerPro) {
                        console.log('‚úÖ Found SchedulerPro directly on window');
                        break;
                    }
                    
                    if (retries === maxRetries - 1) {
                        // Last retry failed
                        console.error('‚ùå Bryntum SchedulerPro library not loaded after', maxRetries * retryDelay, 'ms!');
                        console.error('window.bryntum structure:', window.bryntum);
                        console.error('Available Bryntum items on window:', Object.keys(window).filter(k => k.toLowerCase().includes('scheduler') || k.toLowerCase().includes('bryntum')));
                        // Notify parent of error
                        if (window.parent !== window) {
                            window.parent.postMessage({ type: 'SCHEDULER_ERROR', error: 'Bryntum library not loaded' }, '*');
                        }
                        // Hide loading overlay when directly accessed
                        const loadingOverlay = document.getElementById('loadingOverlay');
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }
                        return;
                    }
                    
                    // Wait before next retry
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retries++;
                }
                
                console.log('‚úÖ Bryntum SchedulerPro loaded successfully', window.SchedulerPro);
                
                // Notify parent window that scheduler is ready
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'SCHEDULER_READY' }, '*');
                    console.log('üì§ Sent SCHEDULER_READY message to parent');
                }
                
                // Set today's date to September 3, 2025
                const today = new Date(2025, 8, 3); // September 3, 2025
                today.setHours(8, 0, 0, 0); // Start at 8 AM
                
                // Helper to create a date relative to September 3, 2025
                function createDate(hoursFromNow) {
                    const date = new Date(2025, 8, 3); // September 3, 2025
                    date.setHours(8 + hoursFromNow, 0, 0, 0); // Start at 8 AM
                    return date;
                }
                
                // Planning area filter state
                let selectedPlanningArea = 'all';
                let lastScheduledArea = '';
                let allPlanningAreas = [];
                
                // Load all planning areas for the dropdown (once on startup)
                async function loadPlanningAreas() {
                    try {
                        const response = await fetch('/api/resources');
                        if (response.ok) {
                            const allResources = await response.json();
                            const areas = new Set();
                            allResources.forEach(resource => {
                                if (resource.planning_area) {
                                    areas.add(resource.planning_area);
                                }
                            });
                            allPlanningAreas = Array.from(areas).sort();
                            
                            // Populate dropdown
                            const dropdown = document.getElementById('planningAreaFilter');
                            allPlanningAreas.forEach(area => {
                                const option = document.createElement('option');
                                option.value = area;
                                option.textContent = area;
                                option.setAttribute('data-testid', `option-planning-area-${area}`);
                                dropdown.appendChild(option);
                            });
                            
                            console.log('‚úÖ Planning areas loaded:', allPlanningAreas);
                        }
                    } catch (error) {
                        console.error('Error loading planning areas:', error);
                    }
                }
                
                // Load planning areas first
                await loadPlanningAreas();
                
                // NOTE: Click listener for applyPlanningAreaFilter button is already
                // attached via document.addEventListener at line 1145-1150
                // No need for duplicate listener here
                console.log('‚úÖ Planning area filter button handler already attached via document click delegation');
                
                // Fetch real PT operations and resources from the backend
                let resources = [];
                let ptOperations = [];
                let resourceCapabilities = {};
                let fetchedDependencies = []; // Store dependencies at a higher scope
                
                try {
                    // Fetch resources, PT operations, and dependencies from the backend APIs
                    // NOTE: Dependencies are for visual display only - ALAP uses sequence numbers for scheduling
                    const [resourcesResponse, operationsResponse, dependenciesResponse, capabilitiesResponse] = await Promise.all([
                        fetch('/api/resources'),
                        fetch('/api/pt-operations'),
                        fetch('/api/pt-dependencies'), // Keep for visual dependency lines
                        fetch('/api/resources-with-capabilities')
                    ]);
                    
                    if (resourcesResponse.ok) {
                        resources = await resourcesResponse.json();
                        console.log('‚úÖ Resources fetched successfully:', resources.length);
                        console.log('First 3 resources:', resources.slice(0, 3));
                        
                        // CRITICAL: Sort resources to ensure proper grouping 
                        // (fermentation tanks together, bright tanks together, packaging together)
                        // Define order for resource types
                        const getOrder = (name) => {
                            const lowerName = name.toLowerCase();
                            // 1. MILLING (top)
                            if (lowerName.includes('mill')) return 1;
                            // 2. MASHING
                            if (lowerName.includes('mash')) return 2;
                            // 3. LAUTERING
                            if (lowerName.includes('lauter')) return 3;
                            // 4. BOILING/KETTLE
                            if (lowerName.includes('boil') || lowerName.includes('kettle')) return 4;
                            // 5. WHIRLPOOL
                            if (lowerName.includes('whirlpool')) return 5;
                            // 6. COOLING
                            if (lowerName.includes('cool')) return 6;
                            // 7. ALL FERMENTATION TANKS (grouped together)
                            if (lowerName.includes('ferment')) return 7;
                            // 8. ALL BRIGHT/CONDITIONING TANKS (grouped together)
                            if (lowerName.includes('bright') || lowerName.includes('condition')) return 8;
                            // 9. PASTEURIZATION
                            if (lowerName.includes('pasteur')) return 9;
                            // 10. ALL PACKAGING/FILLING (bottling and canning grouped together)
                            if (lowerName.includes('bottle') || lowerName.includes('can') || lowerName.includes('filler') || lowerName.includes('packag')) return 10;
                            // 11. Any other resources
                            return 11;
                        };
                        
                        // Sort resources and add explicit sortOrder field
                        resources.sort((a, b) => {
                            const aName = (a.name || '').toLowerCase();
                            const bName = (b.name || '').toLowerCase();
                            
                            const aOrder = getOrder(aName);
                            const bOrder = getOrder(bName);
                            
                            // First sort by type order
                            if (aOrder !== bOrder) {
                                return aOrder - bOrder;
                            }
                            
                            // Within same type, sort alphabetically by name
                            return aName.localeCompare(bName);
                        });
                        
                        // Add explicit sortOrder field to each resource to prevent Bryntum from re-sorting
                        resources = resources.map((resource, index) => ({
                            ...resource,
                            sortOrder: index + 1,  // Add explicit sort order
                            // Override the numeric ID with a string to prevent numeric sorting
                            originalId: resource.id,
                            id: `resource_${index + 1}_${resource.id}`,
                            // CRITICAL: Explicitly preserve planning_area field for filtering
                            planning_area: resource.planning_area || resource.planning_area_name || ''
                        }));
                        
                        console.log('‚úÖ Resources sorted by operational sequence:');
                        resources.forEach((r, idx) => {
                            console.log(`  ${idx + 1}. ${r.name} (sortOrder: ${r.sortOrder}, id: ${r.id}, planning_area: ${r.planning_area || 'NONE'})`);
                        });
                    } else {
                        console.error('‚ùå Failed to fetch resources:', resourcesResponse.status);
                        // No fallback - let resources stay empty rather than showing wrong equipment
                        resources = [];
                    }
                    
                    // REMOVED: Unscheduled resource line
                    // resources.unshift({
                    //     id: 'unscheduled',
                    //     name: 'üîÑ Unscheduled Operations',
                    //     category: 'Unscheduled',
                    //     eventColor: '#808080' // Gray color for unscheduled items
                    // });
                    
                    if (operationsResponse.ok) {
                        ptOperations = await operationsResponse.json();
                        console.log('‚úÖ PT Operations fetched successfully:', ptOperations.length);
                        if (ptOperations.length > 0) {
                            console.log('‚úÖ First PT operation sample:', ptOperations[0]);
                        }
                    } else {
                        console.error('‚ùå Failed to fetch PT operations:', operationsResponse.status);
                    }
                    
                    // Process dependencies (for visual display only - ALAP uses sequence numbers)
                    if (dependenciesResponse && dependenciesResponse.ok) {
                        const deps = await dependenciesResponse.json();
                        // CRITICAL FIX: API returns 'from' and 'to' directly, not 'fromEvent' and 'toEvent'
                        fetchedDependencies = deps.map(dep => ({
                            id: String(dep.id),  // Ensure ID is a string
                            from: dep.from,      // Correct field name from API
                            to: dep.to,          // Correct field name from API
                            type: dep.type || 2, // Default to Finish-to-Start
                            lag: dep.lag || 0,
                            lagUnit: dep.lagUnit || 'hour',
                            fromEvent: dep.from, // Also include for compatibility
                            toEvent: dep.to,     // Also include for compatibility
                            // Mark as inactive so they show visually but don't constrain
                            inactive: true,
                            cls: 'visual-dependency' // CSS class for visual styling
                        }));
                        console.log('‚úÖ Dependencies fetched from database (for visual display):', fetchedDependencies.length);
                        if (fetchedDependencies.length > 0) {
                            console.log('Sample dependency:', fetchedDependencies[0]);
                            // Validate the dependency has required fields
                            const validDeps = fetchedDependencies.filter(d => d.from && d.to);
                            console.log(`‚úÖ ${validDeps.length}/${fetchedDependencies.length} dependencies have valid from/to fields`);
                        }
                    } else {
                        console.warn('Failed to fetch dependencies, using empty array');
                    }
                    
                    // Process resource capabilities
                    if (capabilitiesResponse && capabilitiesResponse.ok) {
                        const capabilitiesData = await capabilitiesResponse.json();
                        console.log('‚úÖ Resource capabilities fetched successfully');
                        console.log('Capabilities data:', capabilitiesData);
                        capabilitiesData.forEach(resource => {
                            resourceCapabilities[resource.id] = resource.capabilities || [];
                            console.log(`Resource ${resource.name} (ID: ${resource.id}) has capabilities:`, resource.capabilities);
                        });
                        // Log specific resources for debugging
                        console.log('üç∫ Bright Tank 1 capabilities:', resourceCapabilities[8]);
                        console.log('üç∫ Bright Tank 2 capabilities:', resourceCapabilities[9]);
                        console.log('üç∫ Fermenter Tank 1 capabilities:', resourceCapabilities[5]);
                        console.log('üç∫ Fermenter Tank 2 capabilities:', resourceCapabilities[6]);
                        console.log('üç∫ Fermenter Tank 3 capabilities:', resourceCapabilities[7]);
                    }
                } catch (error) {
                    console.error('‚ùå Error fetching data:', error);
                    // No fallback - let resources stay empty rather than showing wrong equipment
                    resources = [];
                }

                // Map resources to create resource lookup by both ID and name
                const resourceMap = new Map();
                const resourceByName = new Map();
                const originalIdMap = new Map(); // Map original numeric IDs to new string IDs
                resources.forEach(resource => {
                    resourceMap.set(resource.id, resource);
                    resourceMap.set(resource.name, resource);
                    // Also create a name-based lookup for better matching
                    resourceByName.set(resource.name?.toLowerCase(), resource);
                    // Map original numeric ID to new string ID
                    if (resource.originalId) {
                        originalIdMap.set(resource.originalId, resource.id);
                    }
                });
                
                
                // Define capability mappings for brewing operations
                // Based on PT Resource Capabilities: 1=MILLING, 2=MASHING, 3=LAUTERING, 
                // 4=BOILING, 5=FERMENTATION, 6=CONDITIONING, 8=PACKAGING, 9=PASTEURIZATION
                function getRequiredCapability(operationName) {
                    if (!operationName) return null;
                    const name = operationName.toLowerCase();
                    
                    // Check most specific patterns first to avoid mismatches
                    if (name.includes('packag')) return 8;
                    if (name.includes('mill')) return 1;
                    if (name.includes('mash')) return 2;
                    if (name.includes('lauter')) return 3;
                    if (name.includes('boil')) return 4;
                    if (name.includes('ferment')) return 5;
                    if (name.includes('condition')) return 6;
                    if (name.includes('pasteur')) return 9;
                    
                    return null; // No specific capability required
                }
                
                // Transform PT operations into Bryntum events format
                // CRITICAL: Load operations but DON'T use overlapping scheduled times
                let events = ptOperations.map((operation, index) => {
                    // Log job names for debugging
                    if (index < 5 || operation.jobName) {
                        console.log(`Operation ${operation.name}: Job = ${operation.jobName || 'NO JOB NAME'}`);
                    }
                    
                    // First try to find a matching resource based on capability
                    let resourceId = findResourceId(operation, resourceMap, resourceByName, resources, originalIdMap);
                    
                    // Check if operation is truly unscheduled (no valid resource assignment)
                    const isUnscheduled = !resourceId || resourceId === 'unscheduled' || !resources.find(r => r.id === resourceId && r.id !== 'unscheduled');
                    
                    let startDate;
                    
                    // Use the actual scheduled times from database - API sends them as startDate/endDate
                    if (operation.startDate) {
                        startDate = new Date(operation.startDate);
                        console.log(`üìÖ Using DB scheduled time for ${operation.name}: ${startDate.toISOString()}`);
                    } else {
                        // Fallback: Use base date if no scheduled time exists
                        const baseDate = new Date(2025, 8, 3, 7, 0, 0); // Sept 3, 7 AM
                        startDate = new Date(baseDate.getTime() + index * 30 * 60 * 1000);
                        console.log(`‚ö†Ô∏è No scheduled time for ${operation.name}, using fallback: ${startDate.toISOString()}`);
                    }
                    
                    // If no valid resource found, assign to unscheduled resource
                    if (isUnscheduled) {
                        resourceId = 'unscheduled';
                    }
                    
                    // Calculate duration - API sends duration in minutes from cycle_hrs
                    let duration = 2; // Default 2 hours
                    
                    // First try to use duration field from API (already in minutes from cycle_hrs)
                    if (operation.duration) {
                        duration = operation.duration / 60; // Convert minutes to hours
                        console.log(`üìä Using API duration for ${operation.name}: ${duration.toFixed(1)} hours`);
                    }
                    // Then try calculated from scheduled times (API sends endDate/startDate)
                    else if (operation.endDate && operation.startDate) {
                        const endDate = new Date(operation.endDate);
                        const startMs = new Date(operation.startDate).getTime();
                        duration = (endDate.getTime() - startMs) / (1000 * 60 * 60); // Convert to hours
                        console.log(`üìä Calculated duration from times for ${operation.name}: ${duration.toFixed(1)} hours`);
                    }
                    
                    // NO CAPPING - Use actual durations for realistic scheduling
                    // Fermentation can be 48+ hours, conditioning 24+ hours, etc.
                    console.log(`‚úÖ Operation ${operation.name} final duration: ${duration.toFixed(1)} hours`);
                    
                    return {
                        id: operation.id,
                        name: operation.name || `${operation.jobName || 'Job'}: ${operation.name || 'Operation'}`,
                        startDate: startDate,
                        duration: duration,
                        durationUnit: 'hour',
                        resourceId: resourceId,
                        percentDone: operation.percent_done || 0,
                        eventColor: isUnscheduled ? '#808080' : (operation.eventColor || getOperationColor(operation.name)),
                        // ASAP scheduling constraints (not for unscheduled operations)
                        constraintType: isUnscheduled ? null : 'startnoearlierthan', // No constraints for unscheduled
                        constraintDate: isUnscheduled ? null : startDate,
                        manuallyScheduled: false, // Allow automatic scheduling
                        draggable: true, // Allow dragging to schedule
                        // Additional PT operation data
                        jobId: operation.jobExternalId || operation.jobId || operation.job_id, // Use jobExternalId for dependency generation
                        jobName: operation.jobName,
                        jobDueDate: operation.dueDate, // CRITICAL: Add job Need-By date for ALAP scheduling
                        operationName: operation.name,
                        resourceName: operation.resourceName,
                        isUnscheduled: isUnscheduled,
                        sequence_number: operation.sequence_number || operation.sequenceNumber || 0, // Map from API response
                        ptData: operation // Keep original PT data for algorithms
                    };
                }); // Include all operations, even unscheduled ones
                
                // LOG IMMEDIATELY to verify code is running
                console.log('üöÄ SCHEDULER LOADED - Total events:', events.length);
                console.log('First 3 events:', events.slice(0, 3));
                console.log('Event dates range:', events.length > 0 ? {
                    first: events[0]?.startDate,
                    last: events[events.length - 1]?.startDate
                } : 'no events');
                
                // Helper function to find the correct resource ID
                function findResourceId(operation, resourceMap, resourceByName, resources, originalIdMap) {
                    // First try to match by the operation's resource_id which is the original numeric ID
                    if (operation.resourceId && originalIdMap.has(operation.resourceId)) {
                        return originalIdMap.get(operation.resourceId);
                    }
                    if (operation.resource_id && originalIdMap.has(operation.resource_id)) {
                        return originalIdMap.get(operation.resource_id);
                    }
                    
                    // Try various ways to match the resource
                    if (operation.resourceId && resourceMap.has(operation.resourceId)) {
                        return operation.resourceId;
                    }
                    if (operation.resource_id && resourceMap.has(operation.resource_id)) {
                        return operation.resource_id;
                    }
                    // Try to match by exact name
                    if (operation.resourceName) {
                        if (resourceMap.has(operation.resourceName)) {
                            return resourceMap.get(operation.resourceName).id;
                        }
                        // Try case-insensitive match
                        const lowerName = operation.resourceName.toLowerCase();
                        if (resourceByName.has(lowerName)) {
                            return resourceByName.get(lowerName).id;
                        }
                        // If resource name exists but not found in map, create a new resource entry
                        if (operation.resourceName !== 'Resource null' && operation.resourceName !== 'Unassigned') {
                            // Create a dynamic resource ID based on the name
                            const dynamicId = `resource_${operation.resourceName.replace(/\s+/g, '_').toLowerCase()}`;
                            // Add it to resources if not already there
                            if (!resourceMap.has(dynamicId)) {
                                const newResource = {
                                    id: dynamicId,
                                    name: operation.resourceName,
                                    category: 'Manufacturing'
                                };
                                resources.push(newResource);
                                resourceMap.set(dynamicId, newResource);
                                resourceMap.set(operation.resourceName, newResource);
                                resourceByName.set(operation.resourceName.toLowerCase(), newResource);
                            }
                            return dynamicId;
                        }
                    }
                    // Don't fallback to a random resource if not found - return null for unscheduled
                    return null;
                }
                
                // Helper function to assign colors based on operation type (brewing-specific)
                // CRITICAL: Order checks from most specific to least specific to avoid mismatches
                function getOperationColor(operationName) {
                    if (!operationName) return '#2563eb'; // Blue
                    const name = operationName.toLowerCase();
                    
                    // Brewing-specific operations with distinct colors
                    // Check packaging FIRST before lager to avoid "Packaging - Lager" matching lager
                    if (name.includes('packag')) return '#ea580c'; // Orange
                    if (name.includes('milling') || name.includes('mill')) return '#2563eb'; // Blue
                    if (name.includes('mash')) return '#7c3aed'; // Purple  
                    if (name.includes('lauter')) return '#0891b2'; // Cyan
                    if (name.includes('boil')) return '#dc2626'; // Red
                    if (name.includes('ferment')) return '#059669'; // Green
                    if (name.includes('lager') && !name.includes('packag')) return '#059669'; // Green (but not packaging)
                    if (name.includes('condition')) return '#0d9488'; // Teal
                    if (name.includes('pasteur')) return '#7c2d12'; // Brown
                    
                    // Generic manufacturing operations
                    if (name.includes('machining')) return '#2563eb'; // Blue
                    if (name.includes('assembly')) return '#059669'; // Green
                    if (name.includes('quality') || name.includes('testing')) return '#7c3aed'; // Purple
                    if (name.includes('filtration')) return '#0d9488'; // Teal
                    if (name.includes('carbonation')) return '#eab308'; // Yellow
                    
                    return '#2563eb'; // Default blue
                }
                
                console.log(`üìä Transformed ${events.length} PT operations into Bryntum events`);
                
                // If we have no PT operations, don't create fake demo data
                if (events.length === 0) {
                    console.log('üìä No PT operations found - scheduler will be empty until operations are added');
                    // Keep events array empty - better to show an empty scheduler than wrong data
                }

                // ===== PT DEPENDENCIES VISUAL DISPLAY =====
                // Load PT dependencies from database as VISUAL-ONLY lines
                // These show workflow but DO NOT constrain scheduling
                // Conflict suppression handlers prevent any dependency conflict dialogs
                // Scheduling is based ONLY on: Job Priority (1=highest) and Operation Sequence Numbers
                
                let dependencies = [];
                
                console.log('===== DEPENDENCY CONFIGURATION =====');
                console.log('Dependencies: ENABLED for visual display (non-constraining)');
                console.log('Scheduling based on: Job Priority (1=highest) and Operation Sequence Numbers only');
                console.log('PT dependencies show workflow connections but do NOT affect scheduling');
                
                // Load PT dependencies from database for visual display
                if (fetchedDependencies && fetchedDependencies.length > 0) {
                    console.log(`üìã Loading ${fetchedDependencies.length} PT dependencies for visual display...`);
                    
                    // Map dependencies with inactive flag to prevent constraint enforcement
                    dependencies = fetchedDependencies.map(dep => ({
                        id: String(dep.id),
                        from: dep.source_operation_id || dep.from,  // Map database field to Bryntum field
                        to: dep.target_operation_id || dep.to,      // Map database field to Bryntum field
                        type: dep.type || 2, // 2 = Finish-to-Start
                        lag: dep.lag || 0,
                        lagUnit: dep.lagUnit || 'hour',
                        // Mark as inactive to prevent automatic constraint enforcement
                        inactive: true,
                        cls: 'visual-dependency'
                    }));
                    
                    console.log(`‚úÖ ${dependencies.length} PT dependencies ready for visual display`);
                } else {
                    console.log('‚ÑπÔ∏è No PT dependencies found in database');
                }

                // Detect mobile device
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                const isTablet = window.innerWidth > 768 && window.innerWidth <= 1024;
                
                // Choose appropriate view preset based on device
                let viewPreset = 'dayAndWeek';
                let resourceColumnWidth = 200;
                
                if (isMobile) {
                    viewPreset = 'weekAndDay';  // Wider view for mobile
                    resourceColumnWidth = 120;
                } else if (isTablet) {
                    viewPreset = 'weekAndDay';
                    resourceColumnWidth = 150;
                }
                
                // Configure columns based on device
                const schedulerColumns = [
                    { text: 'Resource', field: 'name', width: resourceColumnWidth, locked: isMobile }
                ];
                
                // Create scheduler instance with ASAP scheduling
                // Make scheduler globally accessible for Max AI
                // Use SchedulerPro from the ES module (now available on window)
                // Add conflict resolution handler before creating scheduler
                // This will automatically resolve dependency conflicts
                const handleSchedulingConflict = (conflict) => {
                    console.log('üîß Auto-resolving scheduling conflict');
                    
                    // Always choose to ignore dependency conflicts
                    if (conflict && conflict.resolutions) {
                        // Look for resolution that removes or deactivates the dependency
                        for (const resolution of conflict.resolutions) {
                            if (resolution.description && 
                                (resolution.description.toLowerCase().includes('deactivate dependency') ||
                                 resolution.description.toLowerCase().includes('remove dependency'))) {
                                console.log('  ‚Üí Auto-selected: Ignoring dependency constraint');
                                resolution.resolve();
                                return;
                            }
                        }
                        
                        // If no dependency resolution, remove constraints
                        for (const resolution of conflict.resolutions) {
                            if (resolution.description && 
                                resolution.description.toLowerCase().includes('remove') &&
                                resolution.description.toLowerCase().includes('constraint')) {
                                console.log('  ‚Üí Auto-selected: Removing date constraint');
                                resolution.resolve();
                                return;
                            }
                        }
                        
                        // Last resort: cancel
                        for (const resolution of conflict.resolutions) {
                            if (resolution.description && 
                                resolution.description.toLowerCase().includes('cancel')) {
                                console.log('  ‚Üí Cancelling operation');
                                resolution.resolve();
                                return;
                            }
                        }
                    }
                };

                // Create a custom VisualDependency model that forces dependencies to be inactive
                class VisualDependencyModel extends SchedulerPro.DependencyModel {
                    static get fields() {
                        return [
                            // Force active to always be false for visual-only behavior
                            { name: 'active', defaultValue: false },
                            { name: 'inactive', defaultValue: true }
                        ];
                    }
                    
                    // Override active getter to always return false
                    get active() {
                        return false;
                    }
                    
                    // Prevent setting active to true
                    set active(value) {
                        // Do nothing - always stay inactive
                    }
                }
                
                // Create a custom DependencyStore using our visual-only model
                const visualDependencyStore = new SchedulerPro.DependencyStore({
                    modelClass: VisualDependencyModel,
                    data: [] // Start with empty, will load after scheduler is initialized
                });
                
                // Make visual dependency store globally accessible
                window.visualDependencyStore = visualDependencyStore;
                
                window.scheduler = new SchedulerPro({
                    appendTo: 'scheduler',
                    
                    columns: schedulerColumns,

                    viewPreset: viewPreset,
                    rowHeight: isMobile ? 50 : 60,
                    barMargin: isMobile ? 5 : 8,
                    
                    // CRITICAL: Event listeners to suppress ALL dependency conflicts
                    listeners: {
                        // Suppress ALL conflict resolution dialogs for dependencies
                        beforeSchedulingConflictResolution: ({ schedulingIssue }) => {
                            console.log('üîç Conflict detected:', schedulingIssue?.type, schedulingIssue);
                            
                            // Suppress ALL dependency-related conflicts
                            if (schedulingIssue && 
                                (schedulingIssue.type === 'dependencyconflict' || 
                                 schedulingIssue.type === 'dependency' ||
                                 schedulingIssue.description?.toLowerCase().includes('dependency'))) {
                                console.log('‚ö†Ô∏è Dependency conflict SUPPRESSED (visual-only deps)');
                                return false; // Prevent the dialog
                            }
                            
                            // Allow other conflict types (resource overlaps, constraint violations, etc.)
                            return true;
                        },
                        
                        // Hook into project load to force dependencies inactive
                        projectChange: ({ project }) => {
                            if (project && project.dependencyStore) {
                                // Force all dependencies to be inactive before any propagation
                                project.dependencyStore.forEach(dep => {
                                    dep.active = false;
                                    dep.inactive = true;
                                });
                                console.log('üîß Forced all dependencies inactive in project store');
                            }
                        },
                        
                        // Allow inactive (visual-only) dependencies, block active (constraining) dependencies
                        beforeDependencyAdd: ({ dependency }) => {
                            // Always mark dependencies as inactive for visual display only
                            if (dependency && !dependency.inactive) {
                                dependency.inactive = true;
                                dependency.active = false;
                                console.log('üìã Dependency marked as inactive (visual-only):', dependency.id);
                            }
                            
                            // Allow the dependency to be added now that it's inactive
                            return true;
                        },
                        
                        beforeDependencyUpdate: ({ dependency }) => {
                            // Ensure dependency remains inactive during updates
                            if (dependency && !dependency.inactive) {
                                dependency.inactive = true;
                                dependency.active = false;
                                console.log('üìã Dependency update - enforced inactive flag:', dependency.id);
                            }
                            
                            // Allow the update now that inactive flag is set
                            return true;
                        },
                        
                        // Hook before any scheduling propagation
                        beforeProjectPropagate: ({ project }) => {
                            // Ensure all dependencies are inactive before propagation
                            if (project && project.dependencyStore) {
                                project.dependencyStore.forEach(dep => {
                                    dep.active = false;
                                    dep.inactive = true;
                                });
                            }
                        }
                    },
                    
                    
                    // Enable horizontal scrolling on mobile
                    scrollable: isMobile ? { overflowX: 'auto', overflowY: 'auto' } : true,
                    
                    // Zoom level for better mobile view
                    zoomLevel: isMobile ? 0 : 5,
                    zoomOnMouseWheel: !isMobile,
                    
                    // Enable pinch zoom on mobile
                    pinchZoom: isMobile,
                    
                    // CRITICAL: Prevent overlapping events on same resource
                    allowOverlap: false,
                    
                    // Event layout - 'none' forces proper constraint handling, no visual stacking
                    eventLayout: 'none',  // 'none' enforces hard constraints, no overlaps allowed
                    
                    // Enable constraint violation indicators
                    enableEventAnimations: false,  // Disable animations for better performance with constraints
                    
                    // Disable state persistence to avoid localStorage errors
                    stateId: null,
                    
                    // Disable sync storage to prevent errors
                    syncDataOnLoad: false,

                    // Single project configuration with strict no-overlap constraints
                    project: {
                        autoLoad: false,
                        autoSync: false,
                        silenceInitialCommit: true, // Prevent initial save attempts
                        
                        // Note: inline data will be loaded after fetching from API
                        // resources, events, dependencies will be provided via loadInlineData()
                        
                        // Enable automatic scheduling dates
                        autoCalculateStartDate: true,
                        autoCalculateEndDate: true,
                        autoCalculate: false,          // DISABLED - Only recalculate when explicitly triggered
                        recalculateAfterLoad: false,  // DISABLED - Don't auto-recalculate after loading
                        
                        // CRITICAL: Constraint configuration 
                        // We use 'none' to prevent all constraint conflicts including dependencies
                        // Our algorithms handle date constraints programmatically
                        constraintsMode: 'none',    // 'none' = no constraint enforcement, just visual lines
                        manuallyScheduled: false,    // Allow engine to move tasks to resolve conflicts
                        
                        // Scheduling engine configuration
                        schedulingDirection: 'none', // DISABLED - No default scheduling direction
                        allowDependencyLag: true,     // Allow lag times between dependencies
                        calculateCriticalPath: true   // Enable critical path calculation
                    },

                    features: {
                        // Dependencies feature ENABLED - using PT dependencies for visualization
                        // Bryntum will handle the rendering natively
                        dependencies: true,
                        
                        // Enable drag and drop with tooltip
                        eventDrag: {
                            showTooltip: true,
                            constrainDragToResource: false, // Allow dragging between resources
                            // Validate that target resource has required capability AND no time overlap
                            validatorFn({ draggedRecords, targetRecord, startDate, endDate }) {
                                // Check each dragged operation
                                for (const draggedRecord of draggedRecords) {
                                    const operationName = draggedRecord.name || draggedRecord.operationName || '';
                                    const requiredCapability = getRequiredCapability(operationName);
                                    
                                    // 1. Check capability requirements - USE SIMPLE NAME MATCHING SINCE API IS BROKEN
                                    if (targetRecord) {
                                        const operationNameLower = operationName.toLowerCase();
                                        const targetResourceNameLower = targetRecord.name.toLowerCase();
                                        
                                        console.log(`üîç Validating drag: Operation "${operationName}" to resource "${targetRecord.name}"`);
                                        
                                        // Simple capability matching based on resource and operation names
                                        const isValidMatch = 
                                            // Milling operations can only go on Grain Mill
                                            (operationNameLower.includes('mill') && targetResourceNameLower.includes('grain mill')) ||
                                            // Mashing operations can only go on Mash Tun
                                            (operationNameLower.includes('mash') && !operationNameLower.includes('unmash') && 
                                             targetResourceNameLower.includes('mash tun')) ||
                                            // Lautering operations can only go on Lauter Tun
                                            (operationNameLower.includes('lauter') && targetResourceNameLower.includes('lauter tun')) ||
                                            // Boiling operations can only go on Brew Kettle
                                            (operationNameLower.includes('boil') && targetResourceNameLower.includes('brew kettle')) ||
                                            // Fermentation operations can only go on Fermenter Tanks
                                            (operationNameLower.includes('ferment') && targetResourceNameLower.includes('fermenter tank')) ||
                                            // Conditioning operations can only go on Bright Tanks
                                            (operationNameLower.includes('condition') && targetResourceNameLower.includes('bright tank')) ||
                                            // Packaging operations can only go on Bottling/Canning Lines
                                            (operationNameLower.includes('packag') && (targetResourceNameLower.includes('bottling') || 
                                                                                        targetResourceNameLower.includes('canning'))) ||
                                            // Decoction Mash is a special mashing operation
                                            (operationNameLower.includes('decoction') && targetResourceNameLower.includes('mash tun'));
                                        
                                        if (!isValidMatch) {
                                            console.warn(`‚ùå Invalid resource match: ${operationName} cannot be performed on ${targetRecord.name}`);
                                            
                                            // Provide helpful error messages
                                            let expectedResource = 'appropriate resource';
                                            if (operationNameLower.includes('mill')) expectedResource = 'Grain Mill';
                                            else if (operationNameLower.includes('mash')) expectedResource = 'Mash Tun';
                                            else if (operationNameLower.includes('lauter')) expectedResource = 'Lauter Tun';
                                            else if (operationNameLower.includes('boil')) expectedResource = 'Brew Kettle';
                                            else if (operationNameLower.includes('ferment')) expectedResource = 'Fermenter Tank';
                                            else if (operationNameLower.includes('condition')) expectedResource = 'Bright Tank';
                                            else if (operationNameLower.includes('packag')) expectedResource = 'Bottling/Canning Line';
                                            
                                            return {
                                                valid: false,
                                                message: `${operationName} must be performed on ${expectedResource}, not ${targetRecord.name}`
                                            };
                                        }
                                    }
                                    
                                    // 2. CRITICAL: Use resource's isDateRangeAvailable to check overlaps (Best Practice)
                                    if (targetRecord && startDate && endDate) {
                                        // DEBUG: Log all events on target resource
                                        console.log(`üîç Checking overlap for ${operationName} on ${targetRecord.name}`);
                                        console.log(`  Proposed time: ${startDate.toLocaleString()} to ${endDate.toLocaleString()}`);
                                        console.log(`  Events on ${targetRecord.name}:`, targetRecord.events?.map(e => ({
                                            id: e.id,
                                            name: e.name,
                                            start: e.startDate?.toLocaleString(),
                                            end: e.endDate?.toLocaleString()
                                        })));
                                        
                                        // Find actual conflicting events manually (more reliable than isDateRangeAvailable)
                                        const resourceEvents = targetRecord.events?.filter(event => {
                                            // Skip the dragged event itself and any phantom events
                                            if (event.id === draggedRecord.id || 
                                                event.id === draggedRecord.eventId || 
                                                !event.startDate || 
                                                !event.endDate) {
                                                return false;
                                            }
                                            
                                            // Check for actual time overlap
                                            const overlap = event.startDate < endDate && event.endDate > startDate;
                                            if (overlap) {
                                                console.log(`  ‚ö†Ô∏è Found overlapping event: ${event.name} (${event.id})`);
                                            }
                                            return overlap;
                                        }) || [];
                                        
                                        // Only show error if there's a REAL conflicting event
                                        if (resourceEvents.length > 0) {
                                            const conflictingEvent = resourceEvents[0];
                                            console.warn(`‚ö†Ô∏è Cannot drop ${operationName}: Time slot occupied on ${targetRecord.name} by ${conflictingEvent.name}`);
                                            
                                            const conflictStart = conflictingEvent.startDate.toLocaleString('en-US', { 
                                                month: 'short', 
                                                day: 'numeric', 
                                                hour: 'numeric', 
                                                minute: '2-digit' 
                                            });
                                            const conflictEnd = conflictingEvent.endDate.toLocaleString('en-US', { 
                                                month: 'short', 
                                                day: 'numeric', 
                                                hour: 'numeric', 
                                                minute: '2-digit' 
                                            });
                                            return {
                                                valid: false,
                                                message: `Resource busy: ${conflictingEvent.name} runs from ${conflictStart} to ${conflictEnd}`
                                            };
                                        }
                                        
                                        // No real conflicts found - allow the drop
                                        console.log(`  ‚úÖ No conflicts found, allowing drop`);
                                    }
                                }
                                return true; // Valid drop
                            }
                        },
                        
                        // Enable resize with overlap validation
                        eventResize: {
                            showTooltip: true,
                            // CRITICAL: Use resource's isDateRangeAvailable to prevent overlaps (Best Practice)
                            validatorFn({ eventRecord, startDate, endDate }) {
                                const resource = eventRecord.resource;
                                if (!resource || !startDate || !endDate) return true;
                                
                                // Use resource-level overlap detection per Bryntum best practices
                                const isAvailable = resource.isDateRangeAvailable(
                                    startDate,
                                    endDate,
                                    eventRecord  // Exclude the resized event itself
                                );
                                
                                if (!isAvailable) {
                                    console.warn(`‚ö†Ô∏è Cannot resize ${eventRecord.name}: Time slot occupied`);
                                    
                                    // Find the conflicting event for better error message
                                    const resourceEvents = resource.events.filter(event => 
                                        event.id !== eventRecord.id &&
                                        event.startDate < endDate && 
                                        event.endDate > startDate
                                    );
                                    
                                    const conflictingEvent = resourceEvents[0];
                                    if (conflictingEvent) {
                                        const conflictStart = conflictingEvent.startDate.toLocaleString('en-US', { 
                                            month: 'short', 
                                            day: 'numeric', 
                                            hour: 'numeric', 
                                            minute: '2-digit' 
                                        });
                                        const conflictEnd = conflictingEvent.endDate.toLocaleString('en-US', { 
                                            month: 'short', 
                                            day: 'numeric', 
                                            hour: 'numeric', 
                                            minute: '2-digit' 
                                        });
                                        return {
                                            valid: false,
                                            message: `Cannot resize: ${conflictingEvent.name} runs from ${conflictStart} to ${conflictEnd}`
                                        };
                                    }
                                    return {
                                        valid: false,
                                        message: `Time slot is already occupied on this resource`
                                    };
                                }
                                return { valid: true }; // Valid resize
                            }
                        },
                        
                        // Event tooltips on hover
                        eventTooltip: {
                            template: ({ eventRecord }) => {
                                // Extract job name/batch from the event data
                                const jobInfo = eventRecord.jobName || eventRecord.data?.jobName || '';
                                const jobDisplay = jobInfo ? `<strong style="color: #0066cc;">Job: ${jobInfo}</strong><br>` : '';
                                
                                return `
                                    <div style="padding: 10px; min-width: 200px;">
                                        ${jobDisplay}
                                        <strong>${eventRecord.name}</strong><br>
                                        <div style="margin-top: 5px; font-size: 0.9em;">
                                            Start: ${eventRecord.startDate.toLocaleString()}<br>
                                            End: ${eventRecord.endDate.toLocaleString()}<br>
                                            Duration: ${eventRecord.duration} ${eventRecord.durationUnit}<br>
                                            Progress: ${eventRecord.percentDone}%
                                        </div>
                                        ${eventRecord.isUnscheduled ? '<br><span style="color: orange; font-weight: bold;">‚ö†Ô∏è Unscheduled - Drag to a resource to schedule</span>' : ''}
                                    </div>
                                `;
                            }
                        },
                        
                        // Show current time line
                        timeRanges: {
                            showCurrentTimeLine: true
                        },
                        
                        // Progress line feature - shows percentage complete
                        percentBar: true,
                        
                        // Non-working time visualization
                        nonWorkingTime: true,
                        
                        // Critical paths feature
                        criticalPaths: false,
                        
                        // Event menu on right-click
                        eventMenu: true,
                        
                        // Schedule menu on right-click
                        scheduleMenu: true
                    },

                    eventRenderer({ eventRecord, renderData }) {
                        renderData.eventColor = eventRecord.eventColor;
                        return {
                            html: `
                                <div style="padding: 4px;">
                                    <div style="font-weight: 500; font-size: 12px;">${eventRecord.name}</div>
                                    <div style="font-size: 11px; opacity: 0.8;">
                                        ${eventRecord.percentDone}% complete
                                    </div>
                                </div>
                            `
                        };
                    },

                    startDate: (() => {
                        // Start from today (September 3, 2025)
                        const start = new Date(2025, 8, 3); // Month is 0-indexed, so 8 = September
                        start.setHours(0, 0, 0, 0);
                        return start;
                    })(),
                    endDate: (() => {
                        // Show 4 weeks from today to ensure all operations are visible
                        const end = new Date(2025, 9, 3); // October 3, 2025
                        end.setHours(23, 59, 59, 999);
                        return end;
                    })(),
                    // Enable infinite scrolling for better navigation
                    infiniteScroll: true,
                    zoomLevel: 10
                });

                // Setup toolbar handlers
                const scheduler = window.scheduler;
                
                // Add event listeners to handle dragging from unscheduled resource
                scheduler.on('eventdrop', ({ eventRecords, targetResourceRecord, context }) => {
                    eventRecords.forEach(eventRecord => {
                        // Check if the event was dragged from unscheduled to a real resource
                        if (eventRecord.isUnscheduled && targetResourceRecord.id !== 'unscheduled') {
                            // Mark as scheduled now
                            eventRecord.isUnscheduled = false;
                            // Update color to match the operation type
                            eventRecord.eventColor = getOperationColor(eventRecord.name);
                            // Apply ASAP constraint now that it's scheduled
                            eventRecord.constraintType = 'startnoearlierthan';
                            eventRecord.constraintDate = eventRecord.startDate;
                            console.log(`‚úÖ Operation "${eventRecord.name}" scheduled to resource: ${targetResourceRecord.name}`);
                            updateStatus(); // Update metrics
                        } else if (!eventRecord.isUnscheduled && targetResourceRecord.id === 'unscheduled') {
                            // Mark as unscheduled if dragged back to unscheduled
                            eventRecord.isUnscheduled = true;
                            eventRecord.eventColor = '#808080';
                            eventRecord.constraintType = null;
                            eventRecord.constraintDate = null;
                            console.log(`‚ö†Ô∏è Operation "${eventRecord.name}" moved to unscheduled`);
                            updateStatus(); // Update metrics
                        }
                    });
                });
                
                // Add event listeners to automatically handle scheduling conflicts
                scheduler.project.on({
                    schedulingconflict: (event) => {
                        console.log('üìã Scheduling conflict detected:', event.conflict);
                        
                        // Automatically resolve the conflict
                        const conflict = event.conflict;
                        if (conflict && conflict.resolutions && conflict.resolutions.length > 0) {
                            // Find resolution to deactivate or remove dependency
                            for (const resolution of conflict.resolutions) {
                                const desc = (resolution.description || '').toLowerCase();
                                if (desc.includes('deactivate dependency') || 
                                    desc.includes('remove dependency')) {
                                    console.log('  ‚Üí Auto-resolving: Ignoring dependency');
                                    resolution.resolve();
                                    return false; // Prevent default dialog
                                }
                            }
                            
                            // Otherwise remove constraints
                            for (const resolution of conflict.resolutions) {
                                const desc = (resolution.description || '').toLowerCase();
                                if (desc.includes('remove') && desc.includes('constraint')) {
                                    console.log('  ‚Üí Auto-resolving: Removing constraint');
                                    resolution.resolve();
                                    return false; // Prevent default dialog
                                }
                            }
                            
                            // Default: cancel
                            const cancelResolution = conflict.resolutions.find(r => 
                                (r.description || '').toLowerCase().includes('cancel'));
                            if (cancelResolution) {
                                console.log('  ‚Üí Auto-resolving: Cancelling');
                                cancelResolution.resolve();
                                return false; // Prevent default dialog
                            }
                        }
                    },
                    
                    beforeschedulingconflictdialog: (event) => {
                        // Prevent the dialog from showing
                        console.log('  ‚Üí Suppressing conflict dialog');
                        return false;
                    }
                });
                
                // Also handle dependency validation to always allow operations
                if (scheduler.project.dependencyStore) {
                    scheduler.project.dependencyStore.on({
                        beforevalidate: (event) => {
                            // Always mark dependencies as valid (visual-only)
                            console.log('  ‚Üí Dependency validation suppressed (visual-only)');
                            event.valid = true;
                            return false; // Skip validation
                        }
                    });
                }
                
                // Enhanced status update function using real PT data
                function updateStatus() {
                    const operationCount = scheduler.eventStore.count || 0;
                    document.getElementById('operationCount').textContent = `${operationCount} operations scheduled`;
                    
                    // Calculate detailed resource utilization using PT operations data
                    const events = scheduler.eventStore.records || [];
                    const resources = scheduler.resourceStore.records || [];
                    
                    let totalOperationHours = 0;
                    const resourceUtilization = {};
                    
                    // Find the actual schedule timespan
                    let earliestStart = null;
                    let latestEnd = null;
                    
                    // Calculate utilization per resource and find schedule bounds
                    resources.forEach(resource => {
                        // Skip the unscheduled resource line from calculations
                        if (resource.id === 'unscheduled') return;
                        
                        const resourceEvents = events.filter(e => e.resourceId === resource.id);
                        let resourceHours = 0;
                        
                        resourceEvents.forEach(event => {
                            resourceHours += event.duration || 0;
                            
                            // Track schedule bounds
                            if (event.startDate) {
                                const startTime = new Date(event.startDate).getTime();
                                const endTime = new Date(event.endDate || event.startDate).getTime();
                                
                                if (!earliestStart || startTime < earliestStart) {
                                    earliestStart = startTime;
                                }
                                if (!latestEnd || endTime > latestEnd) {
                                    latestEnd = endTime;
                                }
                            }
                        });
                        
                        resourceUtilization[resource.id] = {
                            name: resource.name,
                            hours: resourceHours,
                            operationCount: resourceEvents.length
                        };
                        totalOperationHours += resourceHours;
                    });
                    
                    // Calculate actual working days and hours in the schedule
                    let scheduleSpanHours = 0;
                    if (earliestStart && latestEnd) {
                        const spanMs = latestEnd - earliestStart;
                        const spanDays = Math.ceil(spanMs / (1000 * 60 * 60 * 24));
                        // Assume 8 working hours per day
                        scheduleSpanHours = spanDays * 8;
                    } else {
                        // Fallback to single day if no schedule
                        scheduleSpanHours = 8;
                    }
                    
                    // Calculate utilization based on actual schedule span
                    // Exclude unscheduled resource from count
                    const activeResources = resources.filter(r => r.id !== 'unscheduled').length;
                    const totalResourceCapacity = activeResources * scheduleSpanHours;
                    const utilization = totalResourceCapacity > 0 ? Math.round((totalOperationHours / totalResourceCapacity) * 100) : 0;
                    
                    document.getElementById('resourceUtilization').textContent = `Resource utilization: ${utilization}% (${totalOperationHours.toFixed(1)}h total)`;
                    document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                    
                    // Store utilization data for Max AI analysis
                    window.currentUtilization = resourceUtilization;
                    window.currentStats = {
                        operations: operationCount,
                        utilization: utilization,
                        totalHours: totalOperationHours,
                        resources: resources.length
                    };
                }

                // Removed standalone navigation - now integrated with main app
                // const maxAIBtn = document.getElementById('maxAIBtn');
                // const maxAI = document.getElementById('maxAI');
                // const closeMaxAI = document.getElementById('closeMaxAI');
                // const maxInput = document.getElementById('maxInput');
                // const maxSend = document.getElementById('maxSend');
                // const maxMessages = document.getElementById('maxMessages');
                
                // maxAIBtn.addEventListener('click', () => {
                //     maxAI.classList.toggle('closed');
                //     const btnText = maxAI.classList.contains('closed') ? 'ü§ñ Max AI' : 'ü§ñ Hide AI';
                //     maxAIBtn.textContent = btnText;
                // });
                
                // closeMaxAI.addEventListener('click', () => {
                //     maxAI.classList.add('closed');
                //     maxAIBtn.textContent = 'ü§ñ Max AI';
                // });
                
                // Listen for messages from parent window (main app's Max AI panel)
                window.addEventListener('message', (event) => {
                    // Handle algorithm run requests from parent
                    if (event.data && event.data.type === 'RUN_ALGORITHM') {
                        runSchedulerAlgorithm(event.data.algorithm);
                    }
                });
                
                // Improved debug function per Bryntum best practices
                function assertNoOverlaps(scheduler) {
                    const overlaps = [];
                    const TOLERANCE_MS = 1000; // 1 second tolerance for perfect handoffs
                    
                    for (const r of scheduler.resourceStore.records) {
                        const evs = r.events.slice().sort((a, b) => a.startDate - b.startDate);
                        for (let i = 1; i < evs.length; i++) {
                            const overlapMs = evs[i - 1].endDate - evs[i].startDate;
                            // Only flag as overlap if operations overlap by more than the tolerance
                            // This handles perfect handoffs where one ends exactly when another starts
                            if (overlapMs > TOLERANCE_MS) {
                                overlaps.push({ 
                                    resource: r.name, 
                                    a: evs[i - 1].name, 
                                    b: evs[i].name,
                                    overlapMs: overlapMs
                                });
                                console.log(`  ‚ö†Ô∏è Real overlap detected on ${r.name}: "${evs[i - 1].name}" ends at ${evs[i - 1].endDate.toLocaleString()} but "${evs[i].name}" starts at ${evs[i].startDate.toLocaleString()} (${overlapMs}ms overlap)`);
                            } else if (overlapMs > 0 && overlapMs <= TOLERANCE_MS) {
                                console.log(`  ‚úÖ Perfect handoff on ${r.name}: "${evs[i - 1].name}" to "${evs[i].name}" (${overlapMs}ms within tolerance)`);
                            }
                        }
                    }
                    if (overlaps.length) {
                        console.warn('‚ùå Real overlaps found:', overlaps);
                        return false;
                    } else {
                        console.log('‚úÖ No overlaps per resource (perfect handoffs allowed)');
                        return true;
                    }
                }
                
                // Repair function to enforce no overlaps across all resources
                async function enforceNoOverlapAcrossAllResources() {
                    console.log('  üîß Starting overlap repair...');
                    let totalMoved = 0;
                    let iterations = 0;
                    const maxIterations = 10; // Prevent infinite loops
                    
                    // Keep repairing until no overlaps remain or max iterations reached
                    while (iterations < maxIterations) {
                        iterations++;
                        let movedInThisPass = 0;
                        
                        const resList = scheduler.resourceStore.records.filter(r => r.id !== 'unscheduled');
                        
                        // Process each resource
                        for (const resource of resList) {
                            const events = resource.events.slice().sort((a, b) => a.startDate - b.startDate);
                            
                            // Check each event for overlaps with subsequent events
                            for (let i = 0; i < events.length; i++) {
                                const currentEvent = events[i];
                                
                                // Check if this event overlaps with any later events on the same resource
                                let needsMove = false;
                                for (let j = i + 1; j < events.length; j++) {
                                    const nextEvent = events[j];
                                    if (currentEvent.endDate > nextEvent.startDate) {
                                        needsMove = true;
                                        break;
                                    }
                                }
                                
                                // Also check if any earlier event overlaps with this one
                                for (let j = 0; j < i; j++) {
                                    const prevEvent = events[j];
                                    if (prevEvent.endDate > currentEvent.startDate) {
                                        needsMove = true;
                                        break;
                                    }
                                }
                                
                                if (needsMove) {
                                    const dur = currentEvent.durationMS ?? currentEvent.duration * 3600000;
                                    
                                    // Find the earliest free slot that doesn't create new overlaps
                                    const { start, end } = findNextFreeSlotOnResource(resource, currentEvent.startDate, dur, currentEvent);
                                    
                                    // Double-check the slot is truly free by verifying against all events
                                    let slotIsFree = true;
                                    for (const otherEvent of events) {
                                        if (otherEvent === currentEvent) continue;
                                        
                                        // Check if the proposed slot would overlap with this event
                                        if ((start < otherEvent.endDate && end > otherEvent.startDate) ||
                                            (start >= otherEvent.startDate && start < otherEvent.endDate) ||
                                            (end > otherEvent.startDate && end <= otherEvent.endDate)) {
                                            slotIsFree = false;
                                            break;
                                        }
                                    }
                                    
                                    if (slotIsFree && start.getTime() !== currentEvent.startDate.getTime()) {
                                        console.log(`    üìÖ Moving "${currentEvent.name}" on ${resource.name} from ${currentEvent.startDate.toLocaleString()} to ${start.toLocaleString()}`);
                                        currentEvent.set({ startDate: start, endDate: end, manuallyScheduled: false });
                                        movedInThisPass++;
                                        totalMoved++;
                                    } else if (!slotIsFree) {
                                        // If the slot finder didn't find a truly free slot, manually find one
                                        console.log(`    ‚ö†Ô∏è Slot finder failed for "${currentEvent.name}" on ${resource.name}, searching manually...`);
                                        
                                        // Find the latest end time of all events on this resource
                                        let latestEnd = new Date();
                                        for (const evt of events) {
                                            if (evt !== currentEvent && evt.endDate > latestEnd) {
                                                latestEnd = new Date(evt.endDate);
                                            }
                                        }
                                        
                                        // Schedule after the latest event
                                        const newStart = new Date(latestEnd);
                                        const newEnd = new Date(newStart.getTime() + dur);
                                        
                                        console.log(`    üìÖ Moving "${currentEvent.name}" to end of schedule: ${newStart.toLocaleString()}`);
                                        currentEvent.set({ startDate: newStart, endDate: newEnd, manuallyScheduled: false });
                                        movedInThisPass++;
                                        totalMoved++;
                                    }
                                }
                            }
                        }
                        
                        // DON'T commit changes inside the loop to prevent triggering events
                        if (movedInThisPass > 0) {
                            // Just log the progress, don't commit yet
                            console.log(`  üîÑ Pass ${iterations}: Moved ${movedInThisPass} operations`);
                        } else {
                            // No more overlaps found, we're done
                            console.log(`  ‚úÖ All overlaps resolved after ${iterations} pass${iterations > 1 ? 'es' : ''}`);
                            break;
                        }
                    }
                    
                    if (iterations >= maxIterations) {
                        console.error(`  ‚ö†Ô∏è Reached maximum iterations (${maxIterations}) - some overlaps may remain`);
                    }
                    
                    // Commit all changes ONCE at the end to avoid triggering events during the loop
                    if (totalMoved > 0) {
                        await scheduler.project.commitAsync();
                        await scheduler.project.propagate();
                    }
                    
                    console.log(`  üìä Total operations moved: ${totalMoved}`);
                }
                
                // Helper function to check for constraint violations (resource overlaps) - legacy support
                async function checkConstraintViolations() {
                    const violations = [];
                    const resources = scheduler.resourceStore.records;
                    
                    for (const resource of resources) {
                        const events = resource.events.slice().sort((a, b) => a.startDate - b.startDate);
                        
                        // Check for overlaps
                        for (let i = 0; i < events.length - 1; i++) {
                            const current = events[i];
                            const next = events[i + 1];
                            
                            if (current.endDate > next.startDate) {
                                violations.push({
                                    resource: resource.name,
                                    event1: current.name,
                                    event2: next.name,
                                    overlap: current.endDate - next.startDate
                                });
                            }
                        }
                    }
                    
                    return violations;
                }
                
                // Canonical slot finder - uses assignments for single source of truth
                function findNextFreeSlotOnResource(resource, earliestStart, durationMs, excludeEvent) {
                    let start = new Date(earliestStart);
                    
                    // Respect working time if a calendar exists
                    const cal = resource.calendar || resource.project?.calendar;
                    if (cal?.isNonWorkingTime?.(start)) start = cal.skipNonWorkingTime(start, true);
                    
                    // Collect all events assigned to this resource (assignmentStore is the single source of truth)
                    const { assignmentStore, eventStore } = scheduler;
                    const events = [];
                    assignmentStore.forEach(a => {
                        if (a.resourceId === resource.id) {
                            const e = eventStore.getById(a.eventId);
                            if (e && e !== excludeEvent && e.id !== excludeEvent?.id && e.startDate && e.endDate) {
                                events.push(e);
                            }
                        }
                    });
                    events.sort((a, b) => a.startDate - b.startDate);
                    
                    // Keep trying to find a truly free slot
                    let attempts = 0;
                    const maxAttempts = events.length + 2; // Prevent infinite loops
                    
                    while (attempts < maxAttempts) {
                        attempts++;
                        let needsMove = false;
                        const end = new Date(start.getTime() + durationMs);
                        
                        // Check against all events for any kind of overlap
                        for (const e of events) {
                            // Check if the proposed slot overlaps with this event
                            if (start < e.endDate && end > e.startDate) {
                                // Found an overlap, move to after this event
                                start = new Date(e.endDate.getTime());
                                needsMove = true;
                                break;
                            }
                        }
                        
                        if (!needsMove) {
                            // No overlaps found, we have a valid slot
                            break;
                        }
                    }
                    
                    // If we still can't find a slot, place at the very end
                    if (attempts >= maxAttempts) {
                        let latestEnd = new Date(earliestStart);
                        for (const e of events) {
                            if (e.endDate > latestEnd) {
                                latestEnd = new Date(e.endDate.getTime());
                            }
                        }
                        start = latestEnd;
                    }
                    
                    if (cal?.isNonWorkingTime?.(start)) start = cal.skipNonWorkingTime(start, true);
                    const end = new Date(start.getTime() + durationMs);
                    return { start, end };
                }
                
                // Helper function to resolve overlaps by shifting operations
                async function resolveOverlaps() {
                    console.log('üîß Attempting to resolve resource overlaps using best practice packer...');
                    const resources = scheduler.resourceStore.records;
                    
                    for (const resource of resources) {
                        const events = resource.events.slice().sort((a, b) => a.startDate - b.startDate);
                        
                        // Fix overlaps using the packer approach
                        for (let i = 0; i < events.length; i++) {
                            const event = events[i];
                            const durationMs = event.duration * 60 * 60 * 1000;
                            
                            // Find the next free slot for this event
                            const slot = findNextFreeSlotOnResource(resource, event.startDate, durationMs, event);
                            
                            if (slot.start.getTime() !== event.startDate.getTime()) {
                                const shift = slot.start - event.startDate;
                                event.startDate = slot.start;
                                event.endDate = slot.end;
                                console.log(`üìÖ Shifted ${event.name} by ${shift / (1000 * 60)} minutes to avoid overlap on ${resource.name}`);
                            }
                        }
                    }
                    
                    await scheduler.project.commitAsync();
                    console.log('‚úÖ Overlap resolution complete');
                    
                    // Verify with the assertion function
                    assertNoOverlaps(scheduler);
                }
                
                // Function to run scheduler algorithms from quick actions
                function runSchedulerAlgorithm(algorithm) {
                    const algorithmDropdown = document.getElementById('schedulingAlgorithm');
                    const applyButton = document.getElementById('applyScheduling');
                    
                    // Map algorithm names to dropdown values
                    const algorithmMap = {
                        'ASAP': 'asap',
                        'ALAP': 'alap',
                        'CRITICAL_PATH': 'criticalPath',
                        'LEVEL_RESOURCES': 'levelResources',
                        'DRUM_TOC': 'drum'
                    };
                    
                    // Set the dropdown value and trigger the algorithm
                    if (algorithmMap[algorithm]) {
                        algorithmDropdown.value = algorithmMap[algorithm];
                        applyButton.click();
                        
                        // Max AI feedback removed - handled by main app's AI panel
                        // const aiMsg = document.createElement('div');
                        // aiMsg.className = 'max-ai-message assistant';
                        // aiMsg.textContent = `‚úÖ ${algorithm.replace(/_/g, ' ')} algorithm applied successfully!`;
                        // maxMessages.appendChild(aiMsg);
                        // maxMessages.scrollTop = maxMessages.scrollHeight;
                    }
                }
                
                // Make functions available globally for onclick handlers
                window.runSchedulerAlgorithm = runSchedulerAlgorithm;
                
                // Max AI chat functionality removed - handled by main app's AI panel
                function sendMaxMessage() {
                    // This function is now handled by the main app's Max AI panel
                    console.log('Max AI chat is handled by the main app panel');
                    return;
                    
                    // Removed code that references deleted elements
                    // const message = maxInput.value.trim();
                    // if (!message) return;
                    // const userMsg = document.createElement('div');
                    // userMsg.className = 'max-ai-message user';
                    // userMsg.textContent = message;
                    // maxMessages.appendChild(userMsg);
                    
                    // Clear input
                    maxInput.value = '';
                    
                    // Process AI response and execute algorithms
                    setTimeout(async () => {
                        const aiMsg = document.createElement('div');
                        aiMsg.className = 'max-ai-message assistant';
                        
                        // Parse message for algorithm commands
                        const lowerMessage = message.toLowerCase();
                        let response = '';
                        let executedAlgorithm = null;
                        
                        // Check for algorithm execution commands
                        if (lowerMessage.includes('run') || lowerMessage.includes('execute') || lowerMessage.includes('apply') || lowerMessage.includes('optimize')) {
                            if (lowerMessage.includes('asap') || lowerMessage.includes('forward')) {
                                executedAlgorithm = 'asap';
                                response = 'üöÄ Executing ASAP (Forward) scheduling algorithm...';
                            } else if (lowerMessage.includes('alap') || lowerMessage.includes('backward')) {
                                executedAlgorithm = 'alap';
                                response = '‚è∞ Executing ALAP (Backward) scheduling algorithm...';
                            } else if (lowerMessage.includes('critical path')) {
                                executedAlgorithm = 'criticalPath';
                                response = 'üéØ Executing Critical Path optimization...';
                            } else if (lowerMessage.includes('level') || lowerMessage.includes('balance resource')) {
                                executedAlgorithm = 'levelResources';
                                response = '‚öñÔ∏è Executing Resource Leveling algorithm...';
                            } else if (lowerMessage.includes('drum') || lowerMessage.includes('toc') || lowerMessage.includes('constraint')) {
                                executedAlgorithm = 'drum';
                                response = 'ü•Å Executing Drum (Theory of Constraints) optimization...';
                            } else {
                                response = 'To optimize the schedule, please specify an algorithm. You can say:\n‚Ä¢ "Run ASAP scheduling"\n‚Ä¢ "Apply ALAP algorithm"\n‚Ä¢ "Execute critical path optimization"\n‚Ä¢ "Level resources"\n‚Ä¢ "Apply drum scheduling"';
                            }
                        } 
                        // Check for analysis or information requests
                        else if (lowerMessage.includes('what') || lowerMessage.includes('explain') || lowerMessage.includes('tell me about')) {
                            if (lowerMessage.includes('asap')) {
                                response = 'ASAP (As Soon As Possible) pushes all operations to the earliest possible time slots. Best for urgent orders or maximizing early throughput. Say "Run ASAP" to apply it.';
                            } else if (lowerMessage.includes('alap')) {
                                response = 'ALAP (As Late As Possible) delays operations to the latest time that still meets due dates. Minimizes inventory holding costs. Say "Run ALAP" to apply it.';
                            } else if (lowerMessage.includes('critical path')) {
                                response = 'Critical Path identifies the longest sequence of dependent tasks and optimizes them first. Minimizes project completion time. Say "Execute critical path" to apply it.';
                            } else if (lowerMessage.includes('level') || lowerMessage.includes('resource')) {
                                response = 'Resource Leveling distributes work evenly across all resources. Prevents overloading and improves efficiency. Say "Level resources" to apply it.';
                            } else if (lowerMessage.includes('drum') || lowerMessage.includes('toc')) {
                                response = 'Drum scheduling (TOC) identifies your bottleneck resource and optimizes around it. Maximizes throughput. Say "Apply drum scheduling" to apply it.';
                            } else if (lowerMessage.includes('current') || lowerMessage.includes('active')) {
                                const currentAlgo = document.getElementById('schedulingAlgorithm').value;
                                const algoNames = {
                                    'asap': 'ASAP (Forward)',
                                    'alap': 'ALAP (Backward)',
                                    'criticalPath': 'Critical Path',
                                    'levelResources': 'Resource Leveling',
                                    'drum': 'Drum (TOC)'
                                };
                                response = `The current active algorithm is: ${algoNames[currentAlgo]}. You can ask me to run any other algorithm to change it.`;
                            } else {
                                response = 'I can help you optimize the schedule. Try asking:\n‚Ä¢ "Run ASAP scheduling"\n‚Ä¢ "What is the current algorithm?"\n‚Ä¢ "Explain critical path"\n‚Ä¢ "Level the resources"';
                            }
                        }
                        // Check for help commands
                        else if (lowerMessage.includes('help') || lowerMessage.includes('commands')) {
                            response = 'üìä **Schedule Optimization Commands:**\n\n**Execute Algorithms:**\n‚Ä¢ Run ASAP\n‚Ä¢ Apply ALAP\n‚Ä¢ Execute critical path\n‚Ä¢ Level resources\n‚Ä¢ Apply drum scheduling\n\n**Get Information:**\n‚Ä¢ What is ASAP?\n‚Ä¢ Explain critical path\n‚Ä¢ Current algorithm?\n\n**Analysis:**\n‚Ä¢ Analyze schedule\n‚Ä¢ Show utilization';
                        }
                        // Check for analysis commands
                        else if (lowerMessage.includes('analyze') || lowerMessage.includes('utilization') || lowerMessage.includes('insights') || lowerMessage.includes('bottleneck')) {
                            // Perform detailed schedule analysis
                            const scheduler = window.scheduler;
                            const events = scheduler.eventStore.records || [];
                            const resources = scheduler.resourceStore.records || [];
                            
                            // Calculate resource utilization details
                            const resourceUsage = {};
                            resources.forEach(resource => {
                                const resourceEvents = events.filter(e => e.resourceId === resource.id);
                                let totalDuration = 0;
                                resourceEvents.forEach(event => {
                                    const duration = (event.endDate - event.startDate) / (1000 * 60 * 60); // hours
                                    totalDuration += duration;
                                });
                                resourceUsage[resource.name] = {
                                    operations: resourceEvents.length,
                                    hoursUsed: totalDuration.toFixed(1),
                                    utilization: resourceEvents.length > 0 ? 100 : 0
                                };
                            });
                            
                            // Find bottlenecks (resources with highest utilization)
                            let bottleneck = null;
                            let maxOps = 0;
                            Object.entries(resourceUsage).forEach(([name, data]) => {
                                if (data.operations > maxOps) {
                                    maxOps = data.operations;
                                    bottleneck = name;
                                }
                            });
                            
                            // Calculate timeline span
                            let earliestStart = null;
                            let latestEnd = null;
                            events.forEach(event => {
                                if (!earliestStart || event.startDate < earliestStart) {
                                    earliestStart = event.startDate;
                                }
                                if (!latestEnd || event.endDate > latestEnd) {
                                    latestEnd = event.endDate;
                                }
                            });
                            
                            const makespan = earliestStart && latestEnd ? 
                                ((latestEnd - earliestStart) / (1000 * 60 * 60)).toFixed(1) : 0;
                            
                            // Build comprehensive analysis
                            response = 'üìä **Production Schedule Analysis**\n\n';
                            response += `üìà **Overall Metrics:**\n`;
                            response += `‚Ä¢ Total Operations: ${events.length}\n`;
                            response += `‚Ä¢ Active Resources: ${Object.values(resourceUsage).filter(r => r.operations > 0).length}/${resources.length}\n`;
                            response += `‚Ä¢ Total Makespan: ${makespan} hours\n`;
                            response += `‚Ä¢ Current Algorithm: ${document.getElementById('schedulingAlgorithm').options[document.getElementById('schedulingAlgorithm').selectedIndex].text}\n\n`;
                            
                            response += `üè≠ **Resource Utilization:**\n`;
                            Object.entries(resourceUsage).forEach(([name, data]) => {
                                if (data.operations > 0) {
                                    response += `‚Ä¢ ${name}: ${data.operations} operations, ${data.hoursUsed} hours\n`;
                                }
                            });
                            
                            if (bottleneck) {
                                response += `\n‚ö†Ô∏è **Bottleneck Identified:**\n`;
                                response += `‚Ä¢ ${bottleneck} has the highest load with ${maxOps} operations\n`;
                            }
                            
                            // Optimization recommendations
                            response += `\nüí° **Optimization Recommendations:**\n`;
                            
                            const currentAlgo = document.getElementById('schedulingAlgorithm').value;
                            if (currentAlgo === 'asap') {
                                response += `‚Ä¢ Current: ASAP - Good for urgent orders\n`;
                                response += `‚Ä¢ Consider: ALAP to reduce inventory costs\n`;
                                response += `‚Ä¢ Consider: Level Resources to balance workload\n`;
                            } else if (currentAlgo === 'alap') {
                                response += `‚Ä¢ Current: ALAP - Minimizing inventory\n`;
                                response += `‚Ä¢ Consider: ASAP for faster delivery\n`;
                                response += `‚Ä¢ Consider: Critical Path to reduce makespan\n`;
                            } else if (currentAlgo === 'criticalPath') {
                                response += `‚Ä¢ Current: Critical Path - Optimized for completion time\n`;
                                response += `‚Ä¢ Consider: Level Resources if some resources are overloaded\n`;
                                response += `‚Ä¢ Consider: Drum/TOC if bottleneck is limiting throughput\n`;
                            } else if (currentAlgo === 'levelResources') {
                                response += `‚Ä¢ Current: Resource Leveling - Balanced workload\n`;
                                response += `‚Ä¢ Consider: Critical Path to reduce total time\n`;
                                response += `‚Ä¢ Consider: Drum/TOC to optimize bottlenecks\n`;
                            } else {
                                response += `‚Ä¢ Current: Drum/TOC - Optimized for bottlenecks\n`;
                                response += `‚Ä¢ Consider: ASAP for urgent completion\n`;
                                response += `‚Ä¢ Consider: Level Resources for even distribution\n`;
                            }
                            
                            response += `\nWould you like me to apply a different algorithm to optimize the schedule?`;
                        }
                        else {
                            response = `I understand you're asking about "${message}". I can help you optimize the schedule using different algorithms. Say "help" to see available commands.`;
                        }
                        
                        // Execute the algorithm if one was selected
                        if (executedAlgorithm) {
                            aiMsg.textContent = response;
                            maxMessages.appendChild(aiMsg);
                            maxMessages.scrollTop = maxMessages.scrollHeight;
                            
                            // Change the dropdown and execute
                            document.getElementById('schedulingAlgorithm').value = executedAlgorithm;
                            
                            // Execute the algorithm after a brief delay
                            setTimeout(() => {
                                // Click the apply button to trigger the algorithm
                                document.getElementById('applyScheduling').click();
                                
                                // Add success message after algorithm completes
                                setTimeout(() => {
                                    const successMsg = document.createElement('div');
                                    successMsg.className = 'max-ai-message assistant';
                                    const algoNames = {
                                        'asap': 'ASAP (Forward)',
                                        'alap': 'ALAP (Backward)',
                                        'criticalPath': 'Critical Path',
                                        'levelResources': 'Resource Leveling',
                                        'drum': 'Drum (TOC)'
                                    };
                                    
                                    // Get updated stats
                                    const utilization = document.getElementById('resourceUtilization').textContent;
                                    const totalOps = document.getElementById('operationCount').textContent;
                                    
                                    successMsg.textContent = `‚úÖ Successfully applied ${algoNames[executedAlgorithm]} algorithm!\n\nResults:\n‚Ä¢ ${totalOps}\n‚Ä¢ ${utilization}\n\nThe schedule has been optimized. Would you like to try a different algorithm?`;
                                    maxMessages.appendChild(successMsg);
                                    maxMessages.scrollTop = maxMessages.scrollHeight;
                                }, 1500); // Wait for algorithm to complete
                            }, 500);
                        } else {
                            aiMsg.textContent = response;
                            maxMessages.appendChild(aiMsg);
                            maxMessages.scrollTop = maxMessages.scrollHeight;
                        }
                    }, 300);
                    
                    maxMessages.scrollTop = maxMessages.scrollHeight;
                }
                
                // Max AI event listeners removed - using main app's AI panel
                // maxSend.addEventListener('click', sendMaxMessage);
                // maxInput.addEventListener('keypress', (e) => {
                //     if (e.key === 'Enter') sendMaxMessage();
                // });
                
                // Theme toggle removed - using consistent light theme with blue-purple gradient
                
                // View preset selector
                document.getElementById('viewPreset').addEventListener('change', (e) => {
                    scheduler.viewPreset = e.target.value;
                });
                
                // Zoom controls
                document.getElementById('zoomIn').addEventListener('click', () => {
                    scheduler.zoomLevel = Math.min(scheduler.zoomLevel + 2, 20);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    scheduler.zoomLevel = Math.max(scheduler.zoomLevel - 2, 0);
                });
                
                document.getElementById('zoomToFit').addEventListener('click', () => {
                    // Zoom to fit all events according to Bryntum official documentation
                    // https://bryntum.com/products/schedulerpro/docs/api/Scheduler/view/mixin/TimelineZoomable#function-zoomToFit
                    scheduler.zoomToFit({
                        leftMargin: 50,   // Margin in pixels between first event start and first visible date
                        rightMargin: 50   // Margin in pixels between last event end and last visible date
                    });
                    console.log('Zoom to fit applied with 50px margins');
                });
                
                // Apply Scheduling Algorithm button
                document.getElementById('applyScheduling').addEventListener('click', () => {
                    const algorithm = document.getElementById('schedulingAlgorithm').value;
                    document.getElementById('loadingOverlay').style.display = 'flex';
                    
                    // Store current view settings to maintain consistent timeline
                    const currentZoomLevel = scheduler.zoomLevel;
                    const currentStartDate = scheduler.startDate;
                    const currentEndDate = scheduler.endDate;
                    
                    requestAnimationFrame(() => {
                        setTimeout(async () => {
                            try {
                                const project = scheduler.project;
                                let message = '';
                                let color = 'green';
                                
                                switch(algorithm) {
                                    case 'asap':
                                        // ASAP - As Soon As Possible (Forward Scheduling)
                                        await asapScheduling();
                                        message = 'ASAP scheduling applied - operations scheduled as early as possible!';
                                        break;
                                        
                                    case 'alap':
                                        // ALAP - As Late As Possible (Backward Scheduling)
                                        await alapScheduling();
                                        message = 'ALAP scheduling applied - operations scheduled as late as possible!';
                                        color = 'blue';
                                        break;
                                        
                                    case 'criticalPath':
                                        // Critical Path Method
                                        await criticalPathScheduling();
                                        message = 'Critical Path identified and optimized!';
                                        color = 'orange';
                                        break;
                                        
                                    case 'levelResources':
                                        // Resource Leveling
                                        await levelResourcesScheduling();
                                        message = 'Resources leveled - workload balanced across resources!';
                                        color = 'purple';
                                        break;
                                        
                                    case 'drum':
                                        // Drum (Theory of Constraints)
                                        await drumScheduling();
                                        message = 'Drum scheduling applied - optimized around bottleneck!';
                                        color = 'brown';
                                        break;
                                }
                                
                                // Refresh the scheduler
                                scheduler.refresh();
                                
                                // Apply zoom to fit after algorithm is applied
                                scheduler.zoomToFit({
                                    leftMargin: 50,   // Margin in pixels between first event start and first visible date
                                    rightMargin: 50   // Margin in pixels between last event end and last visible date
                                });
                                console.log('Zoom to fit applied after ' + algorithm + ' scheduling');
                                
                                // Hide loading and show success message
                                document.getElementById('loadingOverlay').style.display = 'none';
                                updateStatus();
                                
                                // Show message in status bar
                                const statusElement = document.getElementById('operationCount');
                                const originalText = statusElement.textContent;
                                statusElement.innerHTML = `<span style="color: ${color}; font-weight: bold;">${message}</span>`;
                                
                                setTimeout(() => {
                                    statusElement.textContent = originalText;
                                    updateStatus();
                                }, 3000);
                                
                            } catch (error) {
                                console.error('Scheduling error:', error);
                                document.getElementById('loadingOverlay').style.display = 'none';
                                
                                const statusElement = document.getElementById('operationCount');
                                const originalText = statusElement.textContent;
                                statusElement.innerHTML = `<span style="color: red;">Scheduling failed - ${error.message}</span>`;
                                
                                setTimeout(() => {
                                    statusElement.textContent = originalText;
                                    updateStatus();
                                }, 3000);
                            }
                        }, 300);
                    });
                });
                
                // Save schedule to database
                async function saveSchedule() {
                    try {
                        const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                        const operations = events.map(event => ({
                            id: event.id,
                            start: event.startDate.toISOString(),
                            end: event.endDate.toISOString()
                        }));
                        
                        console.log(`üíæ Saving schedule to database (${operations.length} operations)...`);
                        
                        const response = await fetch('/api/pt-operations/schedule', {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ operations })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Save failed: ${response.statusText}`);
                        }
                        
                        const result = await response.json();
                        console.log(`‚úÖ Schedule saved: ${result.updated}/${result.total} operations updated`);
                        return true;
                    } catch (error) {
                        console.error('‚ùå Failed to save schedule:', error);
                        return false;
                    }
                }

                // Shared helper functions for job extraction and sorting
                function getJobKey(ev) {
                    return ev.jobId ?? ev.jobID ?? ev.job_id ??
                           ev.jobName ?? ev.job_name ??
                           ev.ptData?.jobId ?? ev.ptData?.jobName ??
                           ev.data?.jobId ?? ev.data?.jobName ?? null;
                }

                function getJobPriority(ev) {
                    // Priority 1 = highest, Priority 5 = lowest
                    const priority = ev.jobPriority ?? ev.job_priority ?? 
                                   ev.ptData?.jobPriority ?? ev.ptData?.job_priority ??
                                   ev.data?.jobPriority ?? ev.data?.job_priority ?? 999;
                    return parseInt(priority);
                }
                
                function getJobNumber(jobKey) {
                    if (!jobKey) return Number.MAX_SAFE_INTEGER;
                    const m = String(jobKey).match(/\d+/g);
                    return m ? parseInt(m.join(''), 10) : Number.MAX_SAFE_INTEGER;
                }

                function getSequence(ev) {
                    return ev.sequence_number ?? ev.sequenceNumber ??
                           ev.ptData?.sequence_number ?? ev.ptData?.sequenceNumber ?? 0;
                }

                // Runtime test functions - can be run in DevTools console
                // Make these globally accessible for testing
                window.getJobKey = getJobKey;
                window.getJobPriority = getJobPriority;
                window.getSequence = getSequence;
                
                // Test A: Verify no engine dependencies (only visual dependencies)
                window.testNoDependencies = function() {
                    const engineDeps = scheduler.project.dependencyStore?.count || 0;
                    const visualDeps = scheduler.features?.dependencies?.store?.count || 0;
                    console.assert(engineDeps === 0, 'Project dependencyStore should be empty');
                    console.log('‚úÖ Test A - Dependencies Check:');
                    console.log('  Engine dependencies:', engineDeps, '(should be 0)');
                    console.log('  Visual dependencies:', visualDeps, '(visual lines only)');
                    return engineDeps === 0;
                };

                // Test B: Verify job finish order by priority
                window.testJobFinishOrder = function() {
                    const groups = new Map();
                    scheduler.eventStore.records.forEach(e => {
                        const k = getJobKey(e); 
                        if (!k) return;
                        const arr = groups.get(k) || groups.set(k, []).get(k);
                        arr.push(e);
                    });
                    const finishByJob = [...groups.entries()].map(([k, ops]) => ({
                        job: k,
                        priority: getJobPriority(ops[0]),
                        finish: new Date(Math.max(...ops.map(o => o.endDate?.getTime() || 0)))
                    })).sort((a, b) => a.finish - b.finish);
                    
                    console.log('‚úÖ Test B - Job Finish Order (should be by priority 1‚Üí5):');
                    console.table(finishByJob);
                    
                    // Verify priority order
                    let valid = true;
                    for (let i = 0; i < finishByJob.length - 1; i++) {
                        if (finishByJob[i].priority > finishByJob[i + 1].priority) {
                            console.warn(`‚ö†Ô∏è Job with priority ${finishByJob[i].priority} finishes after priority ${finishByJob[i + 1].priority}`);
                            valid = false;
                        }
                    }
                    return valid;
                };

                // Test C: Check for overlaps
                window.testNoOverlaps = function() {
                    let overlaps = 0;
                    const byRes = new Map();
                    scheduler.assignmentStore.forEach(a => {
                        const r = a.resourceId, e = scheduler.eventStore.getById(a.eventId);
                        if (!e) return;
                        (byRes.get(r) || byRes.set(r, []).get(r)).push(e);
                    });
                    byRes.forEach((list, resourceId) => {
                        list.sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < list.length - 1; i++) {
                            if (list[i].endDate > list[i + 1].startDate) {
                                overlaps++;
                                const resource = scheduler.resourceStore.getById(resourceId);
                                console.error(`‚ùå Overlap on ${resource?.name}: "${list[i].name}" ends at ${list[i].endDate.toLocaleString()} but "${list[i + 1].name}" starts at ${list[i + 1].startDate.toLocaleString()}`);
                            }
                        }
                    });
                    console.log('‚úÖ Test C - Overlap Check:');
                    console.log('  Overlaps found:', overlaps);
                    console.assert(overlaps === 0, 'No overlaps expected');
                    return overlaps === 0;
                };

                // Run all tests
                window.runAllTests = function() {
                    console.log('üß™ Running all scheduler tests...\n');
                    const testA = window.testNoDependencies();
                    const testB = window.testJobFinishOrder();
                    const testC = window.testNoOverlaps();
                    
                    console.log('\nüìä Test Results:');
                    console.log('  Test A (No Engine Dependencies):', testA ? '‚úÖ PASS' : '‚ùå FAIL');
                    console.log('  Test B (Job Priority Order):', testB ? '‚úÖ PASS' : '‚ùå FAIL');
                    console.log('  Test C (No Overlaps):', testC ? '‚úÖ PASS' : '‚ùå FAIL');
                    
                    const allPass = testA && testB && testC;
                    console.log('\n' + (allPass ? 'üéâ All tests passed!' : '‚ö†Ô∏è Some tests failed'));
                    return allPass;
                };

                // Left compaction helper for forward scheduling (ASAP)
                async function compactLeftPerResource() {
                    const { resourceStore, eventStore } = scheduler;
                    for (const res of resourceStore.records) {
                        const evs = eventStore.records
                            .filter(e => String(e.resourceId) === String(res.id))
                            .filter(e => e.startDate && e.endDate)
                            .sort((a, b) => a.startDate - b.startDate);
                        
                        let cursor = evs.length ? new Date(evs[0].startDate) : null;
                        for (let i = 0; i < evs.length; i++) {
                            const cur = evs[i];
                            if (i === 0) continue;
                            const dur = cur.endDate - cur.startDate;
                            // Slide left up to the previous event's end
                            const prevEnd = evs[i - 1].endDate;
                            if (cur.startDate > prevEnd) {
                                cur.set({ startDate: new Date(prevEnd), endDate: new Date(prevEnd.getTime() + dur) });
                            }
                        }
                    }
                    await scheduler.project.commitAsync();
                    await scheduler.project.propagate();
                }

                // Scheduling Algorithm Implementations
                // Make asapScheduling globally accessible
                let isAsapRunning = false; // Add flag to prevent re-entrance
                window.asapScheduling = async function asapScheduling() {
                    // Prevent re-entrance if already running
                    if (isAsapRunning) {
                        console.warn('‚ö†Ô∏è ASAP scheduling already in progress, skipping...');
                        return;
                    }
                    
                    isAsapRunning = true;
                    
                    try {
                        // ============================================================================
                        // ASAP (As Soon As Possible) - Forward Scheduling Algorithm
                        // ============================================================================
                        // This algorithm schedules operations from today forward, respecting:
                        // 1. Job priority (1=highest, 5=lowest) 
                        // 2. Operation sequence within each job
                        
                        const scheduler = window.scheduler;
                        const { project, eventStore, assignmentStore } = scheduler;
                        
                        // No need to clear dependencies - they're only in the feature store for visual display
                        console.log('üé® Dependencies are visual-only, no clearing needed for ASAP scheduling');
                        // 3. Manufacturing release date (if specified in ptjobs table)
                        // 
                        // IMPORTANT: Dependency lines are VISUAL ONLY for the Gantt chart.
                        // The scheduling logic IGNORES dependencies and uses only priority + sequence.
                        // ============================================================================
                        
                        console.log('üöÄ Starting ASAP scheduling (Forward from Today)...');
                        console.log('üìå NOTE: Dependencies are visual-only. Scheduling uses priority + sequence.');
                        const events = [...eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                        console.log(`  Total operations to schedule: ${events.length}`);
                    
                    // Clear any existing constraint dates and manual flags to ensure clean scheduling
                    events.forEach(event => {
                        event.constraintDate = null;
                        event.constraintType = null;
                        event.manuallyScheduled = false;
                    });
                    
                    // ============================================================================
                    // ASAP Base Date Logic:
                    // Use TODAY as the default base scheduling date (not a hardcoded date)
                    // Operations will be scheduled as soon as possible from today forward
                    // ============================================================================
                    const today = new Date();
                    today.setHours(7, 0, 0, 0); // Start at 7 AM today
                    console.log(`üìÖ Base scheduling date (today): ${today.toLocaleDateString()}`);
                    
                    // Map to store job-specific start dates (from manufacturing_release_date if available)
                    const jobStartDates = new Map(); // jobKey -> Date
                    
                    // NOTE: Dependencies are IGNORED for scheduling logic
                    console.log('üìã Using job priority and sequence numbers for scheduling');
                    console.log('üîó Dependencies shown as lines on Gantt but do NOT affect schedule');
                    
                    // ============================================================================
                    // Helper Functions for Data Extraction
                    // ============================================================================
                    // Note: Using shared getJobKey, getJobNumber, and getSequence functions defined above
                    
                    // Get the job priority (1=highest priority, 5=lowest priority)
                    const getPriority = (event) => {
                        return event.jobPriority || event.job_priority || 
                               event.ptData?.jobPriority || event.ptData?.job_priority ||
                               event.data?.jobPriority || event.data?.job_priority ||
                               999; // Default low priority if not found
                    };
                    
                    // Get the manufacturing release date for a job (if specified)
                    const getManufacturingReleaseDate = (event) => {
                        // Check for manufacturing_release_date in various locations
                        const releaseDateStr = event.manufacturingReleaseDate || 
                                              event.manufacturing_release_date ||
                                              event.ptData?.manufacturingReleaseDate ||
                                              event.ptData?.manufacturing_release_date ||
                                              event.data?.manufacturingReleaseDate ||
                                              event.data?.manufacturing_release_date ||
                                              null;
                        
                        if (releaseDateStr) {
                            const releaseDate = new Date(releaseDateStr);
                            // Ensure release date is not in the past (use today if it is)
                            if (releaseDate < today) {
                                console.log(`  ‚ö†Ô∏è Manufacturing release date ${releaseDate.toLocaleDateString()} is in the past, using today instead`);
                                return today;
                            }
                            return releaseDate;
                        }
                        return null; // No release date specified
                    };
                    
                    // Group operations by job and sort by sequence number
                    const jobOperations = new Map(); // jobKey -> array of events sorted by sequence
                    
                    for (const ev of events) {
                        const key = getJobKey(ev);
                        if (!key) {
                            // Handle orphan operations (no job ID)
                            if (!jobOperations.has('_orphans_')) {
                                jobOperations.set('_orphans_', []);
                            }
                            jobOperations.get('_orphans_').push(ev);
                            continue;
                        }
                        
                        if (!jobOperations.has(key)) {
                            jobOperations.set(key, []);
                        }
                        jobOperations.get(key).push(ev);
                    }
                    
                    // Sort each job's operations by sequence number
                    for (const [jobKey, operations] of jobOperations.entries()) {
                        operations.sort((a, b) => getSequence(a) - getSequence(b));
                        console.log(`  Job "${jobKey}": ${operations.length} operations (sequences ${operations.map(op => getSequence(op)).join(', ')})`);
                    }
                    
                    // ASAP: Sort jobs by PRIORITY ASC (1 before 5) so Priority 1 finishes first
                    const sortedJobs = Array.from(jobOperations.entries()).sort(([keyA, opsA], [keyB, opsB]) => {
                        // Skip orphans - they go last
                        if (keyA === '_orphans_') return 1;
                        if (keyB === '_orphans_') return -1;
                        
                        // Sort by job PRIORITY ascending
                        // Priority 1 (highest) should schedule first and finish first
                        // Priority 5 (lowest) should schedule last and finish last
                        const priorityA = getJobPriority(opsA[0]);
                        const priorityB = getJobPriority(opsB[0]);
                        
                        if (priorityA !== priorityB) {
                            return priorityA - priorityB; // Ascending: 1, 2, 3, 4, 5
                        }
                        
                        // If same priority, sort by job key for consistency
                        return String(keyA).localeCompare(String(keyB));
                    });
                    
                    // Flatten sorted jobs into a single sorted events array
                    const sortedEvents = [];
                    for (const [jobKey, operations] of sortedJobs) {
                        sortedEvents.push(...operations);
                    }
                    
                    console.log(`  ‚úÖ Sorted ${sortedEvents.length} events by job priority and sequence`);
                    
                    // Log the priority order for verification
                    console.log('üìä ASAP Job scheduling order (highest priority first for forward scheduling):');
                    sortedJobs.forEach(([jobKey, operations], index) => {
                        if (jobKey === '_orphans_') {
                            console.log(`  ${index + 1}. Orphan operations: ${operations.length} operations`);
                        } else {
                            const priority = parseInt(getPriority(operations[0]));
                            console.log(`  ${index + 1}. Priority ${priority}: Job ${jobKey} - ${operations.length} operations`);
                        }
                    });
                    
                    // Process events in job/sequence order
                    const byId = id => eventStore.getById(id);
                    
                    // ADVANCED BIN PACKING ALGORITHM for optimal schedule compaction
                    // Track occupied time slots for each resource (like a timeline with filled bins)
                    const resourceTimelines = new Map(); // resourceId -> array of {start, end, eventId}
                    
                    console.log('\nüì¶ Starting Advanced Bin Packing Algorithm for schedule compaction...');
                    
                    // Helper function to find the earliest available slot on a resource
                    function findEarliestSlot(resourceId, duration, earliestPossibleStart) {
                        const timeline = resourceTimelines.get(resourceId) || [];
                        
                        // If no operations on this resource yet, can start at earliest possible time
                        if (timeline.length === 0) {
                            return earliestPossibleStart;
                        }
                        
                        // Sort timeline by start time (should already be sorted, but ensure it)
                        timeline.sort((a, b) => a.start.getTime() - b.start.getTime());
                        
                        // Check if we can fit before the first operation
                        if (timeline[0].start.getTime() - earliestPossibleStart.getTime() >= duration) {
                            return earliestPossibleStart;
                        }
                        
                        // Check gaps between operations (bin packing)
                        for (let i = 0; i < timeline.length - 1; i++) {
                            const gapStart = timeline[i].end;
                            const gapEnd = timeline[i + 1].start;
                            const gapSize = gapEnd.getTime() - gapStart.getTime();
                            
                            // Check if this gap is big enough and respects earliest start
                            if (gapSize >= duration) {
                                // If gap starts after or at earliest possible start, use gap start
                                if (gapStart.getTime() >= earliestPossibleStart.getTime()) {
                                    return gapStart;
                                }
                                // If gap ends late enough to fit operation after earliest start
                                else if (earliestPossibleStart.getTime() + duration <= gapEnd.getTime()) {
                                    return earliestPossibleStart;
                                }
                            }
                        }
                        
                        // No gaps found, schedule after the last operation
                        const lastEnd = timeline[timeline.length - 1].end;
                        return new Date(Math.max(lastEnd.getTime(), earliestPossibleStart.getTime()));
                    }
                    
                    // ============================================================================
                    // Process Operations in Job/Sequence Order
                    // NOTE: Dependencies are NOT used for scheduling logic, only visual display
                    // ============================================================================
                    for (const [jobKey, operations] of sortedJobs) {
                        console.log(`\nüè≠ Processing Job: ${jobKey} with ${operations.length} operations`);
                        
                        // Determine the start date for this job
                        let jobStartDate = today; // Default to today
                        
                        // Check if this job has a manufacturing release date
                        if (operations.length > 0 && jobKey !== '_orphans_') {
                            const releaseDate = getManufacturingReleaseDate(operations[0]);
                            if (releaseDate) {
                                jobStartDate = releaseDate;
                                console.log(`  üìÖ Job has manufacturing release date: ${releaseDate.toLocaleDateString()}`);
                            } else {
                                console.log(`  üìÖ No release date specified, starting from today: ${today.toLocaleDateString()}`);
                            }
                            // Store for potential reuse
                            jobStartDates.set(jobKey, jobStartDate);
                        }
                        
                        let previousOperationEnd = null; // Track end of previous operation in this job
                        
                        for (const event of operations) {
                            const sequence = getSequence(event);
                            
                            // ========================================================================
                            // Calculate Earliest Start Time
                            // For first operation in job: use job start date (today or release date)
                            // For subsequent operations: must start after previous operation ends
                            // ========================================================================
                            let earliestStart = previousOperationEnd || jobStartDate;
                            
                            console.log(`  üìã Operation "${event.name}" (seq ${sequence})`);
                            if (previousOperationEnd) {
                                console.log(`     Must start after previous operation ends: ${previousOperationEnd.toLocaleString()}`);
                            } else {
                                console.log(`     First operation, can start at: ${earliestStart.toLocaleString()}`);
                            }
                            
                            // Get the resource this event is assigned to
                            let resource = null;
                            const assignment = assignmentStore.find(a => a.eventId === event.id);
                            if (assignment) {
                                resource = scheduler.resourceStore.getById(assignment.resourceId);
                            }
                            
                            const durationMs = event.durationMS ?? (event.duration * 60 * 60 * 1000);
                            
                            if (resource) {
                                const resourceId = resource.id;
                                
                                // Find the earliest slot using bin packing algorithm
                                const slotStart = findEarliestSlot(resourceId, durationMs, earliestStart);
                                const slotEnd = new Date(slotStart.getTime() + durationMs);
                                
                                console.log(`  üì¶ Packing "${event.name}" on "${resource.name}"`);
                                console.log(`     Sequence requires after: ${earliestStart.toLocaleString()}`);
                                console.log(`     Found optimal slot: ${slotStart.toLocaleString()} to ${slotEnd.toLocaleString()}`);
                                
                                // Update the event with the packed times
                                event.setStartDate(slotStart, true); // true = keep duration
                                event.set({
                                    endDate: slotEnd,
                                    manuallyScheduled: false
                                });
                                
                                // Add this time slot to the resource timeline
                                if (!resourceTimelines.has(resourceId)) {
                                    resourceTimelines.set(resourceId, []);
                                }
                                resourceTimelines.get(resourceId).push({
                                    start: slotStart,
                                    end: slotEnd,
                                    eventId: event.id,
                                    eventName: event.name
                                });
                                
                                // Update previous operation end for next operation in sequence
                                previousOperationEnd = slotEnd;
                                
                                console.log(`  ‚úÖ Packed "${event.name}" on ${resource.name}: ${slotStart.toLocaleString()} to ${slotEnd.toLocaleString()}`);
                            } else {
                                // Unassigned events - schedule at earliest time
                                const endDate = new Date(earliestStart.getTime() + durationMs);
                                
                                console.log(`  ‚ö†Ô∏è Event "${event.name}" has no resource assignment`);
                                event.set({ 
                                    startDate: earliestStart, 
                                    endDate: endDate,
                                    manuallyScheduled: false
                                });
                                
                                // Update previous operation end for next operation in sequence
                                previousOperationEnd = endDate;
                            }
                        }
                        
                        console.log(`  ‚úÖ Job ${jobKey} complete - scheduled ${operations.length} operations by sequence`);
                    }
                    
                    // Log packing efficiency
                    console.log('\nüìä Bin Packing Results:');
                    resourceTimelines.forEach((timeline, resourceId) => {
                        const resource = scheduler.resourceStore.getById(resourceId);
                        if (timeline.length > 0) {
                            timeline.sort((a, b) => a.start.getTime() - b.start.getTime());
                            const firstOp = timeline[0];
                            const lastOp = timeline[timeline.length - 1];
                            const totalSpan = lastOp.end.getTime() - firstOp.start.getTime();
                            const totalWorkTime = timeline.reduce((sum, slot) => 
                                sum + (slot.end.getTime() - slot.start.getTime()), 0);
                            const utilization = ((totalWorkTime / totalSpan) * 100).toFixed(1);
                            console.log(`  ${resource.name}: ${timeline.length} operations, ${utilization}% utilization`);
                        }
                    });
                    
                    // Commit all changes and propagate
                    console.log('  üíæ Committing changes...');
                    await project.commitAsync();
                    
                    // Let Bryntum's engine handle any final adjustments
                    console.log('  üîÑ Propagating schedule...');
                    await project.propagate();
                    
                    // Restore visual-only dependencies to feature store (not project store)
                    console.log('üîç Restoring visual dependencies...');
                    const originalDeps = window.originalDependencies || [];
                    console.log(`üîç Found ${originalDeps.length} original dependencies to restore`);
                    
                    if (originalDeps.length > 0 && scheduler.project?.dependencyStore) {
                        const depStore = scheduler.project.dependencyStore;
                        depStore.removeAll();
                        depStore.add(
                            originalDeps.map(({ id, from, to, type = 2, lag = 0, lagUnit = 'hour' }) => ({
                                id: String(id), 
                                fromEvent: from,  // Bryntum uses fromEvent/toEvent
                                toEvent: to,      // not from/to
                                type: type,
                                lag: lag,
                                lagUnit: lagUnit,
                                inactive: true,
                                cls: 'visual-dependency'
                            }))
                        );
                        console.log(`üé® Restored ${depStore.count} visual-only dependency lines`);
                    } else if (originalDeps.length === 0) {
                        console.log('‚ö†Ô∏è No original dependencies to restore');
                    }
                    
                    console.log('\n‚úÖ ASAP scheduling completed using job priority and sequence order');
                    
                    // Dependencies are already loaded in Bryntum's dependency store
                    if (window.originalDependencies && window.originalDependencies.length > 0) {
                        console.log('‚úÖ PT dependencies are displayed natively by Bryntum after ASAP scheduling');
                    }
                    
                    // Apply left compaction to remove gaps
                    console.log('üì¶ Applying left compaction to remove gaps...');
                    await compactLeftPerResource();
                    console.log('‚úÖ Left compaction complete - gaps removed');
                    
                    // Verify no overlaps using the assertion function
                    if (assertNoOverlaps(scheduler)) {
                        console.log('  ‚úÖ No overlaps detected - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.error('  ‚ùå VERIFICATION FAILED: Overlaps detected after ASAP!');
                        
                        // Log which resources have overlaps for debugging
                        const resourceOverlaps = new Map();
                        scheduler.assignmentStore.forEach(assignment => {
                            const resourceId = assignment.resourceId;
                            if (!resourceOverlaps.has(resourceId)) {
                                resourceOverlaps.set(resourceId, []);
                            }
                            const event = scheduler.eventStore.getById(assignment.eventId);
                            if (event) {
                                resourceOverlaps.get(resourceId).push(event);
                            }
                        });
                        
                        resourceOverlaps.forEach((events, resourceId) => {
                            const resource = scheduler.resourceStore.getById(resourceId);
                            events.sort((a, b) => a.startDate - b.startDate);
                            for (let i = 0; i < events.length - 1; i++) {
                                if (events[i].endDate > events[i + 1].startDate) {
                                    console.error(`    ‚ùå Overlap on ${resource?.name}: "${events[i].name}" ends at ${events[i].endDate.toLocaleString()} but "${events[i + 1].name}" starts at ${events[i + 1].startDate.toLocaleString()}`);
                                }
                            }
                        });
                        
                        // Attempt to repair overlaps
                        console.log('  üîß Attempting to repair overlaps...');
                        await enforceNoOverlapAcrossAllResources();
                        
                        // Check again after repair
                        if (assertNoOverlaps(scheduler)) {
                            console.log('  ‚úÖ Overlaps successfully repaired - schedule ready to save');
                            // REMOVED automatic save - user must click Save button
                        } else {
                            console.error('  ‚ùå Failed to repair all overlaps');
                        }
                    }
                    } finally {
                        // Always reset the flag, even if there was an error
                        isAsapRunning = false;
                    }
                }
                
                // Backward packer helper - finds the latest free slot on resource working backwards
                function findLatestFreeSlotOnResource(resource, latestEnd, durationMs, excludeEvent) {
                    const { eventStore, assignmentStore } = scheduler;

                    // 1) Collect busy intervals for this resource
                    const busy = new Map(); // eventId -> { start, end }

                    // from assignments (multi-assign model)
                    if (assignmentStore?.count) {
                        assignmentStore.forEach(asg => {
                            if (String(asg.resourceId) === String(resource.id)) {
                                const ev = eventStore.getById(asg.eventId);
                                if (ev && ev !== excludeEvent && ev.startDate && ev.endDate) {
                                    busy.set(ev.id, { start: new Date(ev.startDate), end: new Date(ev.endDate) });
                                }
                            }
                        });
                    }

                    // from event.resourceId (single-assign model)
                    eventStore.records.forEach(ev => {
                        if (ev !== excludeEvent &&
                            String(ev.resourceId) === String(resource.id) &&
                            ev.startDate && ev.endDate) {
                            busy.set(ev.id, { start: new Date(ev.startDate), end: new Date(ev.endDate) });
                        }
                    });

                    // 2) Normalize & sort by start
                    const intervals = Array.from(busy.values())
                        .filter(i => i.start < i.end && i.start < latestEnd)
                        .sort((a, b) => a.start - b.start);

                    // 3) Merge overlaps
                    const merged = [];
                    for (const cur of intervals) {
                        if (merged.length === 0) {
                            merged.push({ ...cur });
                        } else {
                            const last = merged[merged.length - 1];
                            if (cur.start <= last.end) {
                                if (cur.end > last.end) last.end = cur.end; // extend
                            } else {
                                merged.push({ ...cur });
                            }
                        }
                    }

                    // 4) Walk from the right to find the latest gap that fits
                    const cal = resource.calendar || resource.project?.calendar;
                    let right = new Date(latestEnd);

                    // Snap right boundary to working time (backwards)
                    if (cal?.isNonWorkingTime?.(right)) right = cal.skipNonWorkingTime(right, false);

                    // Helper to return a working-time adjusted slot
                    function finish(start, end) {
                        // Snap again if needed
                        if (cal?.isNonWorkingTime?.(end)) end = cal.skipNonWorkingTime(end, false);
                        let s = new Date(end.getTime() - durationMs);

                        // If start is in non-working, snap backwards to previous working instant
                        if (cal?.isNonWorkingTime?.(s)) s = cal.skipNonWorkingTime(s, false);

                        return { start: s, end };
                    }

                    // Sentinel: if no intervals, the slot ends at 'right'
                    if (!merged.length) return finish(new Date(right.getTime() - durationMs), right);

                    // Consider only intervals that start < right
                    for (let i = merged.length - 1; i >= 0; i--) {
                        const iv = merged[i];

                        // If this interval ends after 'right', move 'right' to iv.start and continue (it overlaps the boundary)
                        if (iv.end > right) {
                            right = new Date(Math.min(right.getTime(), iv.start.getTime()));
                            continue;
                        }

                        // Latest candidate gap is (iv.end, right)
                        if (right - iv.end >= durationMs) {
                            const end = new Date(right);
                            const start = new Date(end.getTime() - durationMs);
                            // Fits here ‚Äî return right-justified inside the gap
                            return finish(start, end);
                        }

                        // Not enough room; move 'right' to the start of this interval and continue left
                        right = new Date(iv.start);
                    }

                    // Gap from -‚àû ‚Ä¶ right
                    return finish(new Date(right.getTime() - durationMs), right);
                }
                
                // ---- ALAP scheduled by Job Need-By date ----
                // ============================================================================
                // ALAP (As Late As Possible) - Backward Scheduling Algorithm
                // ============================================================================
                // This algorithm schedules operations backward from their need-by dates:
                // 1. Jobs are sorted by priority REVERSED (5 before 1) so lowest priority 
                //    schedules first and gets placed latest, leaving room for high priority
                // 2. Operations within each job are scheduled in REVERSE sequence order
                // 3. Last operation ends at the job's need-by date
                // 4. Earlier operations work backward in time (finish-to-start)
                //
                // IMPORTANT: Dependency lines are VISUAL ONLY for the Gantt chart.
                // The scheduling logic IGNORES dependencies and uses only priority + sequence.
                // ============================================================================
                window.alapScheduling = async function alapScheduling() {
                    console.log('üöÄ ALAP: Backward scheduling from Need-By dates');
                    console.log('üìå NOTE: Dependencies are visual-only. Scheduling uses priority + sequence.');
                    
                    const scheduler = window.scheduler;
                    const { project, eventStore, dependencyStore, assignmentStore, resourceStore } = scheduler;
                    
                    // üîß CRITICAL: Temporarily clear dependencies to prevent conflicts during ALAP
                    const originalAutoSync = project.autoSync;
                    const originalValidateConstraintInterval = project.validateConstraintInterval;
                    
                    project.autoSync = false; // Prevent automatic syncing during changes
                    project.validateConstraintInterval = false; // Disable constraint validation during scheduling
                    
                    // No need to clear dependencies - they're only in the feature store for visual display
                    console.log('üé® Dependencies are visual-only, no clearing needed for ALAP scheduling');
                    
                    // Guard
                    const allEvents = [...eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    if (!allEvents.length) {
                        console.warn('ALAP: no events to schedule'); 
                        return;
                    }
                    
                    // Read the "Jobs must meet Need Dates" toggle (defaults true in your UI)
                    const requireNeedDates = (window.activeConstraints?.needDates ?? true);
                    console.log(`ALAP: needDates constraint = ${requireNeedDates}`);
                    
                    // ============================================================================
                    // Helper Functions for ALAP Algorithm
                    // ============================================================================
                    
                    // Convert various date formats to Date object or null
                    const asDateOrNull = (v) => {
                        if (!v) return null;
                        if (v instanceof Date) return isNaN(v) ? null : v;
                        // Accept ISO strings or epoch numbers
                        const d = new Date(v);
                        return isNaN(d) ? null : d;
                    };
                    
                    // Note: Using shared getJobKey, getJobNumber, and getSequence functions defined at top
                    
                    // Extract the need-by/due date from event data
                    // Searches multiple field locations for compatibility with various data formats
                    const extractDueFromEvent = (ev) => {
                        const p = ev.ptData || ev.data || {};
                        // Look for jobDueDate first as it's the field from our PT data API
                        const candidates = [
                            ev.jobDueDate, ev.jobNeedBy, ev.needByDate, ev.need_date_time, ev.need_date, 
                            ev.dueDate, ev.due_date, ev.promiseDate, ev.promisedDate, ev.requiredDate, 
                            ev.shipDate, ev.deliveryDate,
                            p.jobDueDate, p.jobNeedBy, p.needByDate, p.need_date_time, p.need_date, 
                            p.dueDate, p.due_date, p.promiseDate, p.promisedDate, p.requiredDate, 
                            p.shipDate, p.deliveryDate,
                            p.job?.needByDate, p.job?.need_date_time, p.job?.dueDate
                        ];
                        for (const c of candidates) {
                            const d = asDateOrNull(c);
                            if (d) return d;
                        }
                        return null;
                    };
                    
                    // Build a map: jobKey -> dueDate (Need-By)
                    const jobDueMap = new Map();
                    for (const ev of allEvents) {
                        const key = getJobKey(ev);
                        if (!key) continue;
                        if (!jobDueMap.has(key)) {
                            const d = extractDueFromEvent(ev);
                            if (d) {
                                jobDueMap.set(key, d);
                                console.log(`  Job "${key}" has Need-By date: ${d.toLocaleString()}`);
                            }
                        }
                    }
                    
                    // Fallbacks:
                    // 1) use scheduler visible end date if present
                    // 2) else use October 30, 2025 (our new default Need-By date)
                    const globalFallback =
                        scheduler.endDate ? new Date(scheduler.endDate) : new Date(2025, 9, 30, 23, 50, 0, 0);
                    console.log('ALAP: global fallback due =', globalFallback?.toString());
                    
                    // ---------- prepare ----------
                    // Clear constraints and manual flags for a clean run
                    allEvents.forEach(ev => {
                        ev.constraintDate = null;
                        ev.constraintType = null;
                        ev.manuallyScheduled = false;
                    });
                    
                    // üîÑ SIMPLIFIED: Using sequence numbers directly - no dependencies needed!
                    console.log('üìã Using sequence numbers for finish-to-start scheduling');
                    
                    // Group operations by job and sort by sequence number
                    const jobOperations = new Map(); // jobKey -> array of events sorted by sequence
                    
                    for (const ev of allEvents) {
                        const key = getJobKey(ev);
                        if (!key) continue;
                        
                        const seq = getSequence(ev);
                        
                        if (!jobOperations.has(key)) {
                            jobOperations.set(key, []);
                        }
                        jobOperations.get(key).push(ev);
                    }
                    
                    // Sort each job's operations by sequence number
                    for (const [jobKey, operations] of jobOperations.entries()) {
                        operations.sort((a, b) => getSequence(a) - getSequence(b));
                        console.log(`  Job "${jobKey}": ${operations.length} operations (seq ${getSequence(operations[0])} to ${getSequence(operations[operations.length - 1])})`);
                    }
                    
                    // Set project direction to Backward for ALAP
                    project.direction = 'Backward';
                    project.schedulingDirection = 'backward';
                    
                    // Helper to resolve the resource for an event (handles both assignment and direct resourceId)
                    const resolveResource = (ev) => {
                        const { assignmentStore, resourceStore } = scheduler;

                        // Prefer assignments when present
                        const asg = assignmentStore?.find?.(a => a.eventId === ev.id);
                        if (asg) return resourceStore.getById(asg.resourceId);

                        // Fallback to direct event.resourceId (single-assignment model)
                        if (ev.resourceId != null) return resourceStore.getById(ev.resourceId);

                        return null;
                    };
                    
                    // Process each job independently
                    console.log('\nüìç Processing jobs with sequence-based backward scheduling...');
                    
                    // ALAP: Sort jobs by PRIORITY DESC (5 before 1) 
                    // In backward scheduling, what schedules first finishes last (closest to need-by)
                    // So Priority 5 schedules first to finish last, Priority 1 schedules last to finish first
                    const sortedJobs = Array.from(jobOperations.entries()).sort(([keyA, opsA], [keyB, opsB]) => {
                        // Sort by job PRIORITY descending
                        // Priority 5 (lowest) should schedule first (gets latest position/finishes last)
                        // Priority 1 (highest) should schedule last (gets earliest position/finishes first)
                        const priorityA = getJobPriority(opsA[0]);
                        const priorityB = getJobPriority(opsB[0]);
                        
                        if (priorityA !== priorityB) {
                            return priorityB - priorityA; // DESCENDING: 5, 4, 3, 2, 1
                        }
                        
                        // If same priority, sort by job key for consistency
                        return String(keyB).localeCompare(String(keyA));
                    });
                    
                    console.log('üìä ALAP Job scheduling order (descending by priority for backward scheduling):');
                    sortedJobs.forEach(([jobKey, ops], index) => {
                        const priority = getJobPriority(ops[0]);
                        const due = jobDueMap.get(jobKey) || globalFallback;
                        console.log(`  ${index + 1}. Priority ${priority}: ${jobKey} (Due: ${due.toLocaleDateString()}) - schedules ${index === 0 ? 'FIRST (placed later/finishes last)' : index === sortedJobs.length - 1 ? 'LAST (placed earlier/finishes first)' : 'in middle'}`);
                    });
                    
                    // Process each job completely
                    for (const [jobKey, operations] of sortedJobs) {
                        console.log(`\nüè≠ Processing Job: ${jobKey}`);
                        const jobDue = jobDueMap.get(jobKey) || globalFallback;
                        console.log(`  Due: ${jobDue.toLocaleString()}`);
                        console.log(`  Operations: ${operations.length} (sequences ${operations.map(op => getSequence(op)).join(', ')})`);
                        
                        // Schedule backward from last operation (highest sequence)
                        let nextOperationStart = null;
                        
                        // Process operations in REVERSE sequence order (highest to lowest)
                        for (let i = operations.length - 1; i >= 0; i--) {
                            const operation = operations[i];
                            const sequence = getSequence(operation);
                            const durationMs = operation.durationMS ?? (operation.duration * 60 * 60 * 1000);
                            const resource = resolveResource(operation);
                            
                            let endDate;
                            
                            // Last operation (highest sequence) gets the Need-By constraint
                            if (i === operations.length - 1) {
                                endDate = new Date(jobDue);
                                if (requireNeedDates) {
                                    operation.constraintType = 'finishnolaterthan';
                                    operation.constraintDate = new Date(jobDue);
                                    console.log(`  üìå Last op "${operation.name}" (seq ${sequence}) constrained to finish by ${jobDue.toLocaleString()}`);
                                }
                            } else {
                                // Earlier operations must finish when the next operation starts (finish-to-start)
                                endDate = nextOperationStart;
                                console.log(`  üîó "${operation.name}" (seq ${sequence}) must finish before next operation starts at ${endDate.toLocaleString()}`);
                            }
                            
                            // Calculate start date based on duration
                            let startDate, actualEndDate;
                            
                            if (resource) {
                                // Find latest free slot on the resource
                                const slot = findLatestFreeSlotOnResource(resource, endDate, durationMs, operation);
                                startDate = slot.start;
                                actualEndDate = slot.end;
                            } else {
                                // No resource - simple backward calculation
                                actualEndDate = endDate;
                                startDate = new Date(endDate.getTime() - durationMs);
                            }
                            
                            // Set the dates on the operation
                            operation.set({
                                startDate: startDate,
                                endDate: actualEndDate,
                                manuallyScheduled: false
                            });
                            
                            console.log(`  ‚¨ÖÔ∏è Scheduled: ${operation.name} @ ${resource?.name || 'no-resource'}`);
                            console.log(`     ${startDate.toLocaleString()} to ${actualEndDate.toLocaleString()}`);
                            
                            // This operation's start becomes the next operation's end (working backward)
                            nextOperationStart = startDate;
                        }
                        
                        console.log(`  ‚úÖ Job ${jobKey} complete - scheduled ${operations.length} operations by sequence`);
                        
                        // üîß CRITICAL: Commit changes after each job to ensure resource conflicts are visible
                        // This ensures findLatestFreeSlotOnResource sees the updated schedules
                        await project.commitAsync();
                        console.log(`  üìù Committed job ${jobKey} to stores`);
                    }
                    
                    // Handle any orphan operations (no job ID)
                    const orphans = allEvents.filter(ev => !getJobKey(ev));
                    if (orphans.length > 0) {
                        console.warn(`\n‚ö†Ô∏è Found ${orphans.length} orphan operations (no job ID)`);
                        // Schedule orphans to start from current date
                        const baseDate = new Date();
                        orphans.forEach(ev => {
                            const durationMs = ev.durationMS ?? (ev.duration * 60 * 60 * 1000);
                            ev.set({
                                startDate: baseDate,
                                endDate: new Date(baseDate.getTime() + durationMs),
                                manuallyScheduled: false
                            });
                        });
                    }
                    
                    // Commit and propagate with backward direction
                    await project.commitAsync();
                    await project.propagate();
                    
                    // Restore to Forward for normal operation
                    project.direction = 'Forward';
                    project.schedulingDirection = 'forward';
                    
                    // üîß CRITICAL: Restore validation settings and dependencies
                    project.autoSync = originalAutoSync;
                    project.validateConstraintInterval = originalValidateConstraintInterval;
                    
                    // Restore visual-only dependencies to feature store (not project store)
                    console.log('üîç Restoring visual dependencies...');
                    const originalDeps = window.originalDependencies || [];
                    console.log(`üîç Found ${originalDeps.length} original dependencies to restore`);
                    
                    if (originalDeps.length > 0 && scheduler.project?.dependencyStore) {
                        const depStore = scheduler.project.dependencyStore;
                        depStore.removeAll();
                        depStore.add(
                            originalDeps.map(({ id, from, to, type = 2, lag = 0, lagUnit = 'hour' }) => ({
                                id: String(id), 
                                fromEvent: from,  // Bryntum uses fromEvent/toEvent
                                toEvent: to,      // not from/to
                                type: type,
                                lag: lag,
                                lagUnit: lagUnit,
                                inactive: true,
                                cls: 'visual-dependency'
                            }))
                        );
                        console.log(`üé® Restored ${depStore.count} visual-only dependency lines`);
                    } else if (originalDeps.length === 0) {
                        console.log('‚ö†Ô∏è No original dependencies to restore');
                    }
                    
                    console.log('‚ñ∂Ô∏è Restored conflict validation settings');
                    
                    console.log('‚úÖ ALAP complete (backward cascade from Need-By dates). Compacting schedule‚Ä¶');
                    
                    // Add right-compaction pass to close gaps
                    async function compactRightPerResource() {
                        const { resourceStore, eventStore } = scheduler;

                        for (const res of resourceStore.records) {
                            // Get all events on this resource, sorted by start ASC
                            const evs = eventStore.records
                                .filter(e => String(e.resourceId) === String(res.id))
                                .filter(e => e.startDate && e.endDate)
                                .sort((a, b) => a.startDate - b.startDate);

                            // Slide each event as far right as possible up to the next event start
                            for (let i = evs.length - 2; i >= 0; i--) {
                                const cur = evs[i];
                                const next = evs[i + 1];
                                const dur = cur.endDate - cur.startDate;
                                const latestEnd = next.startDate;
                                const slot = findLatestFreeSlotOnResource(res, latestEnd, dur, cur);
                                cur.set({ startDate: slot.start, endDate: slot.end, manuallyScheduled: false });
                            }
                        }

                        await scheduler.project.commitAsync();
                        await scheduler.project.propagate();
                    }

                    await compactRightPerResource();
                    
                    // Verify overlaps but don't save automatically
                    if (typeof assertNoOverlaps === 'function' && assertNoOverlaps(scheduler)) {
                        console.log('  ‚úÖ No overlaps detected - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.error('‚ùå Overlap verification failed after ALAP.');
                        
                        // Check again after repair
                        if (assertNoOverlaps(scheduler)) {
                            console.log('  ‚úÖ Overlaps successfully repaired - schedule ready to save');
                            // REMOVED automatic save - user must click Save button
                        } else {
                            console.error('  ‚ùå Failed to repair all overlaps');
                        }
                    }
                }
                
                async function criticalPathScheduling() {
                    // Identify and optimize critical path - Schedule by resource to prevent overlaps
                    console.log('üöÄ Starting Critical Path scheduling...');
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    const baseDate = new Date(2025, 8, 3);
                    baseDate.setHours(7, 0, 0, 0);
                    
                    // Group by resource and schedule sequentially
                    const resourceEvents = {};
                    events.forEach(event => {
                        if (!resourceEvents[event.resourceId]) {
                            resourceEvents[event.resourceId] = [];
                        }
                        resourceEvents[event.resourceId].push(event);
                    });
                    
                    Object.keys(resourceEvents).forEach(resourceId => {
                        const resEvents = resourceEvents[resourceId];
                        let nextAvailableTime = new Date(baseDate);
                        
                        resEvents.forEach(event => {
                            event.startDate = new Date(nextAvailableTime);
                            const durationMs = event.duration * 60 * 60 * 1000;
                            event.endDate = new Date(event.startDate.getTime() + durationMs);
                            nextAvailableTime = new Date(event.endDate.getTime() + 30 * 60 * 1000);
                        });
                    });
                    
                    await scheduler.project.commitAsync();
                    await scheduler.project.propagate();
                    console.log('‚úÖ Critical Path scheduling completed');
                    
                    // VERIFY no overlaps
                    let overlapsFound = 0;
                    Object.keys(resourceEvents).forEach(resourceId => {
                        const resEvents = resourceEvents[resourceId].sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < resEvents.length - 1; i++) {
                            if (resEvents[i].endDate > resEvents[i + 1].startDate) {
                                overlapsFound++;
                            }
                        }
                    });
                    if (overlapsFound === 0) {
                        console.log('‚úÖ Critical Path Verification passed - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.log(`‚ùå Critical Path FAILED: ${overlapsFound} overlaps`);
                    }
                }
                
                async function levelResourcesScheduling() {
                    // Balance workload across resources to reduce utilization peaks
                    console.log('üöÄ Starting Level Resources scheduling...');
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    const resources = [...scheduler.resourceStore.records].filter(r => r.id !== 'unscheduled');
                    
                    if (events.length === 0 || resources.length === 0) return;
                    
                    // Calculate current resource loads and identify overloaded resources
                    const resourceEvents = {};
                    resources.forEach(r => {
                        resourceEvents[r.id] = [];
                    });
                    
                    events.forEach(event => {
                        if (resourceEvents[event.resourceId]) {
                            resourceEvents[event.resourceId].push(event);
                        }
                    });
                    
                    // Set base scheduling date - Sept 3, 2025
                    const baseDate = new Date(2025, 8, 3);
                    baseDate.setHours(7, 0, 0, 0); // 7 AM start
                    
                    // Calculate scheduling span - 14 days (2 weeks)
                    const endDate = new Date(2025, 8, 17);
                    endDate.setHours(17, 0, 0, 0); // 5 PM end
                    
                    const workingHoursPerDay = 10; // 7 AM to 5 PM
                    const totalDays = 14;
                    const totalAvailableHours = totalDays * workingHoursPerDay * resources.length;
                    
                    // Level the resources by spreading operations evenly
                    const resourceNextAvailable = {};
                    resources.forEach(r => {
                        resourceNextAvailable[r.id] = new Date(baseDate);
                    });
                    
                    // Sort events by priority/duration to optimize scheduling
                    events.sort((a, b) => {
                        // Prioritize longer operations first for better packing
                        return (b.duration || 0) - (a.duration || 0);
                    });
                    
                    // Redistribute operations to level resource utilization
                    events.forEach(event => {
                        // Find the resource that becomes available earliest
                        let earliestResource = event.resourceId;
                        let earliestTime = resourceNextAvailable[event.resourceId] || new Date(baseDate);
                        
                        // For leveling, we can look for other compatible resources with earlier availability
                        // For now, keep original resource assignments but spread timing
                        
                        // Schedule the operation
                        const startTime = new Date(resourceNextAvailable[event.resourceId] || baseDate);
                        
                        // Add gaps between operations to reduce utilization percentage
                        // This simulates maintenance, changeover, or buffer time
                        const bufferMinutes = 60; // 1 hour buffer between operations
                        
                        event.startDate = startTime;
                        const durationMs = (event.duration || 2) * 60 * 60 * 1000;
                        event.endDate = new Date(startTime.getTime() + durationMs);
                        
                        // Update next available time for this resource (with buffer)
                        resourceNextAvailable[event.resourceId] = new Date(event.endDate.getTime() + bufferMinutes * 60 * 1000);
                        
                        // If we've exceeded working hours for the day, move to next day
                        const nextAvail = resourceNextAvailable[event.resourceId];
                        if (nextAvail.getHours() >= 17) {
                            // Move to next day at 7 AM
                            nextAvail.setDate(nextAvail.getDate() + 1);
                            nextAvail.setHours(7, 0, 0, 0);
                            resourceNextAvailable[event.resourceId] = nextAvail;
                        }
                    });
                    
                    // Commit the changes
                    await scheduler.project.commitAsync();
                    await scheduler.project.propagate();
                    console.log('‚úÖ Level Resources scheduling completed');
                    
                    // VERIFY no overlaps
                    let overlapsFound = 0;
                    Object.keys(resourceEvents).forEach(resourceId => {
                        const resEvents = resourceEvents[resourceId].sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < resEvents.length - 1; i++) {
                            if (resEvents[i].endDate > resEvents[i + 1].startDate) {
                                overlapsFound++;
                            }
                        }
                    });
                    if (overlapsFound === 0) {
                        console.log('‚úÖ Level Resources Verification passed - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.log(`‚ùå Level Resources FAILED: ${overlapsFound} overlaps`);
                    }
                    
                    // Force a refresh to recalculate utilization
                    setTimeout(() => {
                        updateStatus();
                    }, 100);
                }
                
                // ============================================================================
                // DRUM (Theory of Constraints) - Bottleneck-Based Scheduling Algorithm
                // ============================================================================
                // This algorithm implements the Drum-Buffer-Rope (DBR) methodology:
                // 1. Identifies the bottleneck resource (drum) - highest total load
                // 2. Schedules the drum optimally (longest operations first)
                // 3. Schedules feeding resources to keep drum supplied (rope)
                // 4. Adds buffers to protect the drum from disruptions
                //
                // IMPORTANT: Dependency lines are VISUAL ONLY for the Gantt chart.
                // The scheduling logic IGNORES dependencies and focuses on bottleneck optimization.
                // ============================================================================
                async function drumScheduling() {
                    console.log('üöÄ Starting Drum (TOC) scheduling - Theory of Constraints');
                    console.log('üìå NOTE: Dependencies are visual-only. Scheduling optimizes bottleneck resource.');
                    
                    // No need to clear dependencies - they're only in the feature store for visual display
                    console.log('üé® Dependencies are visual-only, no clearing needed for Drum scheduling');
                    
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    
                    // ========================================================================
                    // Step 1: Identify the Bottleneck Resource (The Drum)
                    // The resource with the highest total workload becomes the constraint
                    // ========================================================================
                    const resourceLoad = {};
                    events.forEach(event => {
                        if (!resourceLoad[event.resourceId]) {
                            resourceLoad[event.resourceId] = 0;
                        }
                        resourceLoad[event.resourceId] += event.duration;
                    });
                    
                    let drumResourceId = null;
                    let maxLoad = 0;
                    Object.entries(resourceLoad).forEach(([resourceId, load]) => {
                        if (load > maxLoad) {
                            maxLoad = load;
                            drumResourceId = resourceId;
                        }
                    });
                    
                    if (!drumResourceId) {
                        console.log('‚ö†Ô∏è No bottleneck resource found');
                        return;
                    }
                    
                    const drumResource = scheduler.resourceStore.getById(drumResourceId);
                    console.log(`  ü•Å Bottleneck (drum) identified: ${drumResource?.name || drumResourceId}`);
                    console.log(`     Total load: ${maxLoad.toFixed(1)} hours`);
                    
                    // Use today as the base scheduling date (similar to ASAP)
                    const baseDate = new Date();
                    baseDate.setHours(7, 0, 0, 0); // Start at 7 AM today
                    
                    // ========================================================================
                    // Step 2: Schedule the Drum (Bottleneck) Resource
                    // Operations on the drum are scheduled longest-first to minimize makespan
                    // ========================================================================
                    const drumEvents = events.filter(e => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === e.id);
                        return assignment && assignment.resourceId === drumResourceId;
                    });
                    let drumTime = new Date(baseDate);
                    
                    // Sort drum operations by duration (longest first for optimal throughput)
                    drumEvents.sort((a, b) => b.duration - a.duration);
                    console.log(`  üìã Scheduling ${drumEvents.length} operations on drum resource`);
                    
                    drumEvents.forEach(event => {
                        event.startDate = new Date(drumTime);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        // Add protective buffer between drum operations (Theory of Constraints principle)
                        drumTime = new Date(event.endDate.getTime() + 15 * 60 * 1000); // 15 min buffer
                        console.log(`    ‚è±Ô∏è ${event.name}: ${event.duration.toFixed(1)}h`);
                    });
                    
                    // ========================================================================
                    // Step 3: Schedule the Rope (Feeding Resources)
                    // Non-bottleneck resources are scheduled to feed the drum on time
                    // ========================================================================
                    const feedingEvents = events.filter(e => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === e.id);
                        return assignment && assignment.resourceId !== drumResourceId;
                    });
                    const resourceSchedules = {}; // Track next available time for each resource
                    
                    console.log(`  üîó Scheduling ${feedingEvents.length} feeding operations`);
                    
                    feedingEvents.forEach(event => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === event.id);
                        const resourceId = assignment ? assignment.resourceId : null;
                        if (!resourceId) return;
                        
                        // Initialize resource timeline if not exists
                        if (!resourceSchedules[resourceId]) {
                            const feedTime = new Date(baseDate);
                            feedTime.setHours(7, 0, 0, 0); // Start at same time as drum
                            resourceSchedules[resourceId] = feedTime;
                        }
                        
                        // Schedule operation sequentially on its resource
                        event.startDate = new Date(resourceSchedules[resourceId]);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        // Add buffer to protect feeding operations (rope principle)
                        resourceSchedules[resourceId] = new Date(event.endDate.getTime() + 30 * 60 * 1000); // 30 min buffer
                    });
                    
                    await scheduler.project.commitAsync();
                    await scheduler.project.propagate();
                    
                    // Restore visual-only dependencies to feature store (not project store)
                    console.log('üîç Restoring visual dependencies...');
                    const originalDeps = window.originalDependencies || [];
                    console.log(`üîç Found ${originalDeps.length} original dependencies to restore`);
                    
                    if (originalDeps.length > 0 && scheduler.project?.dependencyStore) {
                        const depStore = scheduler.project.dependencyStore;
                        depStore.removeAll();
                        depStore.add(
                            originalDeps.map(({ id, from, to, type = 2, lag = 0, lagUnit = 'hour' }) => ({
                                id: String(id), 
                                fromEvent: from,  // Bryntum uses fromEvent/toEvent
                                toEvent: to,      // not from/to
                                type: type,
                                lag: lag,
                                lagUnit: lagUnit,
                                inactive: true,
                                cls: 'visual-dependency'
                            }))
                        );
                        console.log(`üé® Restored ${depStore.count} visual-only dependency lines`);
                    } else if (originalDeps.length === 0) {
                        console.log('‚ö†Ô∏è No original dependencies to restore');
                    }
                    
                    console.log('‚úÖ Drum (TOC) scheduling completed');
                    
                    // VERIFY no overlaps - use assignments to track resources
                    let overlapsFound = 0;
                    const allResourceEvents = {};
                    events.forEach(event => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === event.id);
                        const resourceId = assignment ? assignment.resourceId : null;
                        if (!resourceId) return;
                        
                        if (!allResourceEvents[resourceId]) {
                            allResourceEvents[resourceId] = [];
                        }
                        allResourceEvents[resourceId].push(event);
                    });
                    
                    Object.keys(allResourceEvents).forEach(resourceId => {
                        const resEvents = allResourceEvents[resourceId].sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < resEvents.length - 1; i++) {
                            if (resEvents[i].endDate > resEvents[i + 1].startDate) {
                                overlapsFound++;
                            }
                        }
                    });
                    if (overlapsFound === 0) {
                        console.log('‚úÖ Drum Verification passed - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.log(`‚ùå Drum FAILED: ${overlapsFound} overlaps`);
                    }
                }
                
                // Initialize status updates
                updateStatus();
                
                // CRITICAL: Helper function to wait for scheduler to be ready
                // This eliminates the need for arbitrary timeouts
                window.waitForSchedulerReady = function(timeout = 30000) {
                    return new Promise((resolve, reject) => {
                        // Check if already ready
                        if (window.schedulerReady && window.scheduler?.eventStore?.count > 0) {
                            console.log('‚úÖ Scheduler already ready with', window.scheduler.eventStore.count, 'operations');
                            resolve({
                                ready: true,
                                eventCount: window.scheduler.eventStore.count,
                                resourceCount: window.scheduler.resourceStore.count,
                                assignmentCount: window.scheduler.assignmentStore.count
                            });
                            return;
                        }
                        
                        console.log('‚è≥ Waiting for scheduler to load operations...');
                        
                        // Set up timeout
                        const timeoutId = setTimeout(() => {
                            window.removeEventListener('schedulerOperationsLoaded', handleReady);
                            clearInterval(pollInterval);
                            reject(new Error('Timeout waiting for scheduler to be ready'));
                        }, timeout);
                        
                        // Listen for the custom paint event
                        const handleReady = (event) => {
                            clearTimeout(timeoutId);
                            clearInterval(pollInterval);
                            window.removeEventListener('schedulerOperationsLoaded', handleReady);
                            console.log('üé® Scheduler paint event received! Operations loaded:', event.detail);
                            resolve({
                                ready: true,
                                ...event.detail
                            });
                        };
                        
                        window.addEventListener('schedulerOperationsLoaded', handleReady);
                        
                        // Also poll periodically as backup (in case event was already fired)
                        const pollInterval = setInterval(() => {
                            if (window.scheduler?.eventStore?.count > 0) {
                                clearTimeout(timeoutId);
                                clearInterval(pollInterval);
                                window.removeEventListener('schedulerOperationsLoaded', handleReady);
                                console.log('‚úÖ Scheduler ready (detected by polling) with', window.scheduler.eventStore.count, 'operations');
                                resolve({
                                    ready: true,
                                    eventCount: window.scheduler.eventStore.count,
                                    resourceCount: window.scheduler.resourceStore.count,
                                    assignmentCount: window.scheduler.assignmentStore.count
                                });
                            }
                        }, 500);
                    });
                };
                
                // CRITICAL FIX: Define global scheduling functions that were missing
                // These functions are called from elsewhere but weren't defined
                // Add flag to prevent re-entrance
                let isScheduleASAPRunning = false;
                
                window.scheduleASAP = async function() {
                    // Prevent re-entrance if already running
                    if (isScheduleASAPRunning) {
                        console.warn('‚ö†Ô∏è scheduleASAP already in progress, skipping...');
                        return;
                    }
                    
                    isScheduleASAPRunning = true;
                    
                    try {
                        console.log('üìÖ Running ASAP scheduling...');
                        await window.waitForSchedulerReady(); // Wait for operations to be loaded
                        const project = scheduler.project;
                        
                        // Disable auto-calculation BEFORE making changes to prevent loops
                        const wasAutoCalculate = project.autoCalculate;
                        project.autoCalculate = false;
                        
                        // Set scheduling direction
                        project.schedulingDirection = 'forward';
                        
                        // Manually trigger calculation once
                        await project.propagate();
                        
                        // Commit the scheduled changes
                        await project.commitAsync();
                        
                        // Restore previous auto-calculate state (should stay false)
                        project.autoCalculate = wasAutoCalculate;
                        
                        console.log('‚úÖ ASAP scheduling complete');
                        updateStatus(); // Use updateStatus instead of updateSchedulerStatus
                    } catch (error) {
                        console.error('‚ùå ASAP scheduling error:', error);
                    } finally {
                        isScheduleASAPRunning = false;
                    }
                };
                
                // Add flag to prevent re-entrance for ALAP
                let isScheduleALAPRunning = false;
                
                window.scheduleALAP = async function() {
                    // Prevent re-entrance if already running
                    if (isScheduleALAPRunning) {
                        console.warn('‚ö†Ô∏è scheduleALAP already in progress, skipping...');
                        return;
                    }
                    
                    isScheduleALAPRunning = true;
                    
                    try {
                        console.log('üìÖ Running ALAP scheduling...');
                        await window.waitForSchedulerReady(); // Wait for operations to be loaded
                        const project = scheduler.project;
                        
                        // Disable auto-calculation BEFORE making changes to prevent loops
                        const wasAutoCalculate = project.autoCalculate;
                        project.autoCalculate = false;
                        
                        // Set scheduling direction
                        project.schedulingDirection = 'backward';
                        
                        // Manually trigger calculation once
                        await project.propagate();
                        
                        // Commit the scheduled changes
                        await project.commitAsync();
                        
                        // Restore previous auto-calculate state (should stay false)
                        project.autoCalculate = wasAutoCalculate;
                        
                        console.log('‚úÖ ALAP scheduling complete');
                        updateStatus(); // Use updateStatus instead of updateSchedulerStatus
                    } catch (error) {
                        console.error('‚ùå ALAP scheduling error:', error);
                    } finally {
                        isScheduleALAPRunning = false;
                    }
                };
                
                window.optimizeSchedule = async function(algorithmId) {
                    console.log(`üìÖ Running optimization algorithm: ${algorithmId}...`);
                    await window.waitForSchedulerReady(); // Wait for operations to be loaded
                    // Apply the selected algorithm
                    await applyAlgorithm(scheduler, algorithmId);
                    console.log(`‚úÖ ${algorithmId} optimization complete`);
                    updateStatus(); // Use updateStatus instead of updateSchedulerStatus
                };
                
                console.log('[Scheduler] Helper function registered: window.waitForSchedulerReady(timeout)');
                console.log('[Scheduler] Global scheduling functions registered: window.scheduleASAP(), window.scheduleALAP(), window.optimizeSchedule(algorithmId)');
                
                // CRITICAL DATA LOADING FIX: Load the events into the scheduler's event store
                // The events array was created but never actually loaded into the scheduler
                console.log('üìä Loading data into scheduler - resources:', resources.length, 'events:', events.length, 'dependencies:', dependencies.length);
                
                // CRITICAL FIX: First preserve the resource mapping, then remove resourceId from events
                // Step 1: Create assignments using the original events with resourceId
                const assignments = events.map((event) => ({
                    id: `assignment_${event.id}`,
                    eventId: event.id,
                    resourceId: event.resourceId, // Capture resourceId before removing it
                    units: 100 // Units indicate how much of the resource is consumed (100 = 100%)
                }));
                
                console.log('üìä Created assignments:', assignments.length);
                console.log('üìä First 3 assignments:', assignments.slice(0, 3));
                
                // Step 2: NOW create clean events without resourceId for the scheduler
                // This prevents the "multi-assignment mode" error
                const eventsForScheduler = events.map(event => {
                    // Create new object without resourceId property
                    const cleanEvent = {
                        id: event.id,
                        name: event.name,
                        startDate: event.startDate,
                        endDate: event.endDate,
                        duration: event.duration,
                        durationUnit: event.durationUnit,
                        percentDone: event.percentDone,
                        constraintType: event.constraintType,
                        constraintDate: event.constraintDate,
                        eventColor: event.eventColor,
                        jobName: event.jobName,
                        jobId: event.jobId,
                        jobDueDate: event.jobDueDate, // CRITICAL: Preserve job Need-By date for ALAP
                        sequence_number: event.sequence_number, // CRITICAL: Preserve sequence number for ALAP
                        operationId: event.operationId,
                        manually_scheduled: event.manually_scheduled,
                        isUnscheduled: event.isUnscheduled
                    };
                    // Explicitly ensure no resourceId exists
                    delete cleanEvent.resourceId;
                    return cleanEvent;
                });
                
                // Load the inline data into the scheduler project
                // CRITICAL: Bryntum requires specific property names ending with 'Data'
                try {
                    console.log('‚è≥ Loading inline data into scheduler...');
                    console.log('Resources count:', resources.length);
                    console.log('Events count:', eventsForScheduler.length);
                    console.log('Assignments count:', assignments.length);
                    console.log('Dependencies count:', dependencies.length);
                    
                    // Debug overlay removed - was obstructing the view
                    // Keep console logging for debugging if needed
                    console.log(`Loading: ${resources.length} resources, ${eventsForScheduler.length} events, ${assignments.length} assignments`);
                    
                    // Transform PT operations to ensure they have the correct format for Bryntum
                    const transformedEvents = eventsForScheduler.map(event => {
                        // Ensure dates are Date objects - provide default if null
                        let startDate = null;
                        let endDate = null;
                        
                        // If operation has scheduled dates, use them
                        if (event.startDate) {
                            startDate = event.startDate instanceof Date ? event.startDate : new Date(event.startDate);
                        }
                        if (event.endDate) {
                            endDate = event.endDate instanceof Date ? event.endDate : new Date(event.endDate);
                        }
                        
                        // If no scheduled dates, create unscheduled placeholder dates for display
                        // These will be replaced by ASAP/ALAP/Drum algorithms
                        if (!startDate || !endDate) {
                            const today = new Date();
                            today.setHours(8, 0, 0, 0);  // Start at 8 AM
                            startDate = new Date(today);
                            // Use duration if available, otherwise default to 1 hour
                            const durationHours = event.duration || 1;
                            endDate = new Date(startDate.getTime() + durationHours * 60 * 60 * 1000);
                        }
                        
                        return {
                            id: event.id,
                            name: event.name || 'Unnamed Operation',
                            startDate: startDate,
                            endDate: endDate,
                            eventColor: event.eventColor || event.color || 'green',
                            // Remove resourceId from event - it should come from assignments
                            percentDone: event.percentDone || 0,
                            duration: event.duration,
                            durationUnit: event.durationUnit || 'hour',
                            isUnscheduled: !event.startDate || !event.endDate  // Flag unscheduled operations
                        };
                    }); // Removed filter - keep all operations for scheduling
                    
                    console.log(`‚úÖ Transformed ${transformedEvents.length} valid events with dates`);
                    
                    // Load data WITHOUT dependencies in project store to prevent constraints
                    // Dependencies will be handled separately through visual-only store
                    await scheduler.project.loadInlineData({
                        resourcesData: resources,
                        eventsData: transformedEvents, // Use transformed events
                        assignmentsData: assignments, // Assignments link events to resources
                        // DO NOT load dependencies here - keep project.dependencyStore empty
                        dependenciesData: [] // Empty array to ensure no dependencies in engine
                    });
                    
                    // Keep a copy globally
                    window.originalDependencies = fetchedDependencies || [];
                    
                    // Load visual dependencies into separate store for display only
                    // This ensures dependencies are rendered but don't constrain scheduling
                    setTimeout(() => {
                        try {
                            if (fetchedDependencies && fetchedDependencies.length > 0) {
                                console.log(`üìã Loading ${fetchedDependencies.length} visual-only dependencies...`);
                                
                                // Access the visual dependency store we created earlier
                                if (window.visualDependencyStore) {
                                    const visualStore = window.visualDependencyStore;
                                    
                                    // Map dependencies to proper format
                                    const depsToAdd = fetchedDependencies.map(({ id, from, to, type = 2, lag = 0, lagUnit = 'hour' }) => {
                                        // Verify the events exist
                                        const fromEvent = scheduler.eventStore.getById(from);
                                        const toEvent = scheduler.eventStore.getById(to);
                                        
                                        if (!fromEvent || !toEvent) {
                                            console.warn(`‚ö†Ô∏è Dependency ${id} missing event: from=${from}, to=${to}`);
                                            return null;
                                        }
                                        
                                        return {
                                            id: String(id),
                                            from: from,      // Use 'from' and 'to' for Bryntum dependency model
                                            to: to,
                                            type: type,
                                            lag: lag,
                                            lagUnit: lagUnit,
                                            inactive: true,  // Mark as inactive for visual-only
                                            active: false,   // Extra safety
                                            cls: 'visual-dependency b-inactive'
                                        };
                                    }).filter(dep => dep !== null);
                                    
                                    // Clear and reload the visual dependency store
                                    visualStore.removeAll();
                                    visualStore.add(depsToAdd);
                                    
                                    // Bind visual store to the dependencies feature for rendering
                                    if (scheduler.features.dependencies) {
                                        scheduler.features.dependencies.store = visualStore;
                                        console.log('‚úÖ Visual dependency store bound to scheduler');
                                    }
                                    
                                    console.log(`‚úÖ Loaded ${visualStore.count} visual-only dependencies`);
                                    console.log('Project dependency store count (should be 0):', scheduler.project.dependencyStore?.count || 0);
                                    
                                    // Log some dependency details for debugging
                                    const sampleDeps = depsToAdd.slice(0, 3);
                                    console.log('Sample dependencies:', sampleDeps.map(d => ({
                                        id: d.id,
                                        from: scheduler.eventStore.getById(d.from)?.name,
                                        to: scheduler.eventStore.getById(d.to)?.name,
                                        inactive: d.inactive
                                    })));
                                } else {
                                    console.warn('‚ö†Ô∏è Visual dependency store not created');
                                }
                            } else {
                                console.log('‚ÑπÔ∏è No dependencies to load');
                            }
                        } catch (error) {
                            console.error('‚ùå Error loading visual dependencies:', error);
                        }
                    }, 1500); // Wait for scheduler to be ready
                    
                    console.log(`‚úÖ Loaded! Store has: ${scheduler.eventStore.count} events`);
                    console.log('‚úÖ Inline data loaded successfully');
                    
                    // Save the original stores immediately after loading
                    // This ensures we have the unfiltered data before any filtering occurs
                    window.masterResourceStore = scheduler.project.resourceStore;
                    window.masterEventStore = scheduler.project.eventStore;
                    window.masterAssignmentStore = scheduler.project.assignmentStore;
                    console.log('üì¶ [Initial Load] Master stores saved with all data');
                    
                    // Debug: Check if resources have planning_area field
                    console.log('üîç [Debug] Checking planning_area in master resource store:');
                    const sampleResources = window.masterResourceStore.records.slice(0, 3);
                    sampleResources.forEach(r => {
                        const planningArea = r.planning_area || r.data?.planning_area || r.get?.('planning_area');
                        console.log(`  - ${r.name || r.get?.('name')}: planning_area = ${planningArea}`);
                    });
                    
                    // DISABLED: Commit was triggering automatic propagation/scheduling
                    // Users should manually trigger scheduling via Apply button
                    // await scheduler.project.commitAsync();
                    
                    console.log('‚úÖ Data loaded (not committed - manual scheduling required)');
                    
                    // Log success to console
                    console.log(`‚úÖ Loaded ${scheduler.eventStore.count} operations on ${scheduler.resourceStore.count} resources`);
                    
                    // Update status bar
                    updateStatus();
                    
                    // Zoom to fit after loading
                    if (scheduler.zoomToFit) {
                        setTimeout(() => {
                            scheduler.zoomToFit();
                        }, 100);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading data into scheduler:', error);
                    console.error('Error details:', error.message, error.stack);
                }
                
                console.log('‚úÖ Data loaded into scheduler event store:', scheduler.eventStore.count, 'events');
                
                // Show alert to debug data loading
                const eventCount = scheduler.eventStore.count || 0;
                const resourceCount = scheduler.resourceStore.count || 0;
                const assignmentCount = scheduler.assignmentStore.count || 0;
                
                console.warn(`üìä Final counts - Resources: ${resourceCount}, Events: ${eventCount}, Assignments: ${assignmentCount}`);
                
                // CRITICAL: Fire custom event when operations are loaded and ready
                // This allows external code to know when the scheduler is ready without waiting
                if (eventCount > 0) {
                    window.schedulerReady = true;
                    window.dispatchEvent(new CustomEvent('schedulerOperationsLoaded', {
                        detail: {
                            eventCount,
                            resourceCount,
                            assignmentCount,
                            timestamp: Date.now()
                        }
                    }));
                    console.log('üé® Paint event fired: Scheduler operations loaded and ready!');
                }
                
                if (eventCount === 0) {
                    console.error('‚ùå NO EVENTS LOADED! Debugging info:');
                    console.error('Resources loaded:', resources.length);
                    console.error('Events to load:', events.length);
                    console.error('First event:', events[0]);
                }
                
                // DISABLED: Auto-ASAP was causing infinite loops
                // Users should manually click Apply button to run scheduling
                console.log('‚ÑπÔ∏è Scheduler loaded. Click "Apply" button to run ASAP scheduling.');
                
                // Just fit to view without running ASAP automatically
                setTimeout(() => {
                    if (scheduler.zoomToFit) {
                        scheduler.zoomToFit({
                            leftMargin: 50,
                            rightMargin: 50
                        });
                        console.log('‚úÖ Zoomed to fit initial view');
                    }
                }, 500);
                
                // Periodic status refresh
                setInterval(updateStatus, 30000); // Update every 30 seconds
                
                // Initial zoom to fit using Bryntum official documentation
                // https://bryntum.com/products/schedulerpro/docs/api/Scheduler/view/mixin/TimelineZoomable#function-zoomToFit
                setTimeout(() => {
                    scheduler.zoomToFit({
                        leftMargin: 50,   // Margin in pixels between first event start and first visible date
                        rightMargin: 50   // Margin in pixels between last event end and last visible date
                    });
                    console.log('Initial zoom to fit applied - scheduler always loads in fit-to-view mode');
                }, 750);
                
                // Hide loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
                
                // Check for pending scheduler commands from Max AI (after navigation)
                const pendingCommand = sessionStorage.getItem('pendingSchedulerCommand');
                if (pendingCommand) {
                    try {
                        const commandData = JSON.parse(pendingCommand);
                        sessionStorage.removeItem('pendingSchedulerCommand');
                        
                        // Execute the pending command after a short delay to ensure page is ready
                        setTimeout(() => {
                            if (commandData.command === 'RUN_ALGORITHM') {
                                window.postMessage({
                                    type: 'RUN_SCHEDULER_ALGORITHM',
                                    algorithm: commandData.algorithm
                                }, '*');
                            } else if (commandData.command === 'VIEW_CONTROL') {
                                window.postMessage({
                                    type: 'SCHEDULER_VIEW_CONTROL',
                                    action: commandData.action
                                }, '*');
                            }
                        }, 500);
                    } catch (error) {
                        console.error('Failed to execute pending scheduler command:', error);
                    }
                }
                
                // Listen for messages from Max AI
                window.addEventListener('message', (event) => {
                    console.log('Production Scheduler received message:', event.data);
                    
                    // Handle scheduler commands from Max AI
                    if (event.data?.type === 'SCHEDULER_VIEW_CONTROL') {
                        const action = event.data.action;
                        
                        switch (action) {
                            case 'zoom_in':
                                document.getElementById('zoomIn')?.click();
                                break;
                            case 'zoom_out':
                                document.getElementById('zoomOut')?.click();
                                break;
                            case 'zoom_fit':
                                document.getElementById('zoomToFit')?.click();
                                break;
                            case 'week_view':
                                const viewSelect = document.getElementById('viewPreset');
                                if (viewSelect) {
                                    viewSelect.value = 'dayAndWeek';
                                    viewSelect.dispatchEvent(new Event('change'));
                                }
                                break;
                            case 'day_view':
                                const viewSelectDay = document.getElementById('viewPreset');
                                if (viewSelectDay) {
                                    viewSelectDay.value = 'hourAndDay';
                                    viewSelectDay.dispatchEvent(new Event('change'));
                                }
                                break;
                            case 'month_view':
                                const viewSelectMonth = document.getElementById('viewPreset');
                                if (viewSelectMonth) {
                                    viewSelectMonth.value = 'monthAndYear';
                                    viewSelectMonth.dispatchEvent(new Event('change'));
                                }
                                break;
                        }
                    } else if (event.data?.type === 'RUN_SCHEDULER_ALGORITHM') {
                        const algorithm = event.data.algorithm;
                        const algorithmMap = {
                            'ASAP': 'asap',
                            'ALAP': 'alap',
                            'CRITICAL_PATH': 'criticalPath',
                            'LEVEL_RESOURCES': 'levelResources',
                            'DRUM_TOC': 'drum'
                        };
                        
                        const algorithmValue = algorithmMap[algorithm];
                        if (algorithmValue) {
                            const algorithmSelect = document.getElementById('schedulingAlgorithm');
                            const applyButton = document.getElementById('applyScheduling');
                            
                            if (algorithmSelect && applyButton) {
                                algorithmSelect.value = algorithmValue;
                                applyButton.click();
                                console.log(`Applied scheduling algorithm: ${algorithm}`);
                            }
                        }
                    } else if (event.data?.type === 'SET_THEME') {
                        // Theme toggle removed - using consistent light theme with blue-purple gradient
                        console.log('Theme toggle disabled - using consistent light theme');
                    }
                });
                
            } catch (error) {
                console.error('Failed to initialize scheduler:', error);
                // Only show error if initialization actually failed (not just warnings)
                if (error.message && error.message !== 'undefined') {
                    console.error('Scheduler initialization error details:', error.message);
                }
                // Try to continue with scheduler initialization even if some resources fail
                document.getElementById('loadingOverlay').style.display = 'none';
            } finally {
                // Ensure loading overlay is hidden
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.style.display = 'none';
            }
        });
    </script>
    
    <!-- Additional Scripts -->
    <script>
        // Constraint modal functions have been removed as constraints are now visual-only
        // Dependencies create lines on the Gantt chart but don't affect scheduling logic
        
        // Setup event listeners when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Apply theme from localStorage on page load
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.className = savedTheme === 'dark' ? 'dark-theme' : '';
            
            // Constraint settings removed - functionality simplified
            // Listen for theme changes from parent window
            window.addEventListener('message', (e) => {
                if (e.data && e.data.type === 'SET_THEME') {
                    document.body.className = e.data.theme === 'dark' ? 'dark-theme' : '';
                    localStorage.setItem('theme', e.data.theme);
                }
            });
            
            // Listen for storage changes (theme changes in main app)
            window.addEventListener('storage', (e) => {
                if (e.key === 'theme') {
                    document.body.className = e.newValue === 'dark' ? 'dark-theme' : '';
                }
            });
            
            // Helper function to collect schedule data
            function collectScheduleData() {
                const resources = scheduler.resourceStore.records.map(r => ({
                    id: String(r.id), // Convert to string for API
                    name: r.name,
                    type: r.type || 'default',
                    capacity: Number(r.capacity) || 1 // Ensure it's a number
                }));
                
                const events = scheduler.eventStore.records
                    .filter(e => e.resourceId !== 'unscheduled')
                    .map(e => ({
                        id: String(e.id), // Convert to string for API
                        name: e.name,
                        resourceId: String(e.resourceId), // Ensure string
                        startDate: e.startDate?.toISOString() || '',
                        endDate: e.endDate?.toISOString() || '',
                        duration: e.durationMS || 0,
                        manuallyScheduled: e.manuallyScheduled || false,
                        locked: e.locked || false,
                        priority: e.priority || 0
                    }));
                
                const dependencies = scheduler.dependencyStore.records.map(d => ({
                    id: String(d.id), // Convert to string
                    fromEvent: String(d.fromEvent?.id || d.fromEvent), // Extract ID if it's an object
                    toEvent: String(d.toEvent?.id || d.toEvent), // Extract ID if it's an object
                    type: d.type || 2,
                    lag: d.lag || 0,
                    lagUnit: d.lagUnit || 'hour'
                }));
                
                return {
                    version: `v_${Date.now()}`,
                    snapshot: {
                        resources,
                        events,
                        dependencies,
                        constraints: []
                    },
                    metadata: {
                        plantId: 'plant_1',
                        timestamp: new Date().toISOString(),
                        userId: 'current_user'
                    }
                };
            }
            
            // Helper function to listen for optimization progress via SSE
            async function pollForOptimizationResult(runId, maxAttempts = 60) {
                return new Promise((resolve, reject) => {
                    let timeoutId;
                    let eventSource;
                    
                    // Set a timeout to prevent infinite waiting (30 seconds)
                    const maxTimeout = setTimeout(() => {
                        if (eventSource) {
                            eventSource.close();
                        }
                        reject(new Error('Optimization timed out after 30 seconds. Please try again.'));
                    }, 30000);
                    
                    // Set up SSE connection for progress updates
                    eventSource = new EventSource(`/api/schedules/optimize/${runId}/progress`);
                    
                    // Progress handler
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress' && data.data) {
                                const progress = data.data;
                                console.log(`Optimization progress: ${progress.percentage}% - ${progress.currentStep}`);
                                
                                // Update UI with progress
                                const optimizeBtn = document.getElementById('optimizeSchedule');
                                if (optimizeBtn && optimizeBtn.disabled) {
                                    optimizeBtn.innerHTML = `
                                        <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21 12a9 9 0 11-6-8.49"></path>
                                        </svg>
                                        <span>${progress.percentage}%</span>
                                    `;
                                }
                            } else if (data.type === 'complete') {
                                // Job completed, fetch final status
                                fetch(`/api/schedules/optimize/${runId}`)
                                    .then(res => res.json())
                                    .then(status => {
                                        eventSource.close();
                                        clearTimeout(timeoutId);
                                        clearTimeout(maxTimeout);
                                        resolve(status);
                                    })
                                    .catch(err => {
                                        eventSource.close();
                                        clearTimeout(timeoutId);
                                        clearTimeout(maxTimeout);
                                        reject(err);
                                    });
                            } else if (data.type === 'error') {
                                eventSource.close();
                                clearTimeout(timeoutId);
                                clearTimeout(maxTimeout);
                                reject(new Error(data.error?.message || 'Optimization failed'));
                            }
                        } catch (error) {
                            console.error('Error parsing SSE data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        console.error('SSE error:', error);
                        eventSource.close();
                        
                        // Fallback to polling if SSE fails
                        pollWithFetch();
                    };
                    
                    // Timeout after maxAttempts seconds
                    timeoutId = setTimeout(() => {
                        eventSource.close();
                        reject(new Error('Optimization timeout'));
                    }, maxAttempts * 1000);
                    
                    // Fallback polling function if SSE fails
                    async function pollWithFetch() {
                        clearTimeout(timeoutId);
                        clearTimeout(maxTimeout);
                        for (let i = 0; i < maxAttempts; i++) {
                            try {
                                const response = await fetch(`/api/schedules/optimize/${runId}`);
                                if (!response.ok) throw new Error('Failed to check job status');
                                
                                const status = await response.json();
                                
                                if (status.status === 'completed' || status.status === 'failed') {
                                    clearTimeout(maxTimeout);
                                    resolve(status);
                                    return;
                                }
                                
                                // Update progress if available
                                if (status.progress) {
                                    console.log(`Optimization progress: ${status.progress.percentage}% - ${status.progress.currentStep}`);
                                }
                                
                                // Wait before next poll
                                await new Promise(r => setTimeout(r, 1000));
                            } catch (error) {
                                reject(error);
                                return;
                            }
                        }
                        reject(new Error('Optimization timeout'));
                    }
                });
            }
            
            // Helper function to apply optimization results
            async function applyOptimizationResults(result) {
                scheduler.project.suspendAutoCommit();
                
                try {
                    for (const optEvent of result.events) {
                        const event = scheduler.eventStore.getById(optEvent.id);
                        if (event && optEvent.changed) {
                            event.set({
                                startDate: new Date(optEvent.startDate),
                                endDate: new Date(optEvent.endDate),
                                resourceId: optEvent.resourceId
                            });
                            event.manuallyScheduled = true;
                            event.cls = (event.cls || '') + ' optimized-event';
                        }
                    }
                    
                    scheduler.project.resumeAutoCommit();
                    await scheduler.project.commitAsync();
                } catch (error) {
                    scheduler.project.resumeAutoCommit();
                    throw error;
                }
            }
            
            // Helper function to show notifications
            function showNotification(message, type = 'info') {
                const colors = {
                    success: '#4CAF50',
                    error: '#f44336',
                    info: '#2196F3'
                };
                
                if (scheduler.features.toast) {
                    scheduler.toast({
                        html: message,
                        timeout: 5000,
                        style: `background-color: ${colors[type]}`
                    });
                } else {
                    console.log(`[${type.toUpperCase()}] ${message}`);
                }
            }
            
            // REMOVED DUPLICATE EVENT LISTENER
            // This was causing the ASAP infinite loop because there were two event listeners
            // for the same button. The original listener is at line 3198.
            // Keeping only the first event listener to prevent duplicate scheduling calls.
            
            /* DUPLICATE CODE REMOVED - SEE LINE 3198 FOR THE ACTIVE EVENT LISTENER
            document.getElementById('applyScheduling').addEventListener('click', async () => {
                // This entire block was commented out to prevent duplicate event listener
                // The working event listener is at line 3198
            });
            
            The following block from lines 4903-5158 contained duplicate scheduling logic:
                            console.log('‚è≥ Running Drum/TOC scheduling...');
                            // Use the working custom Drum/TOC implementation
                            await drumScheduling();
                            console.log('‚úÖ Drum/TOC scheduling complete');
                            if (scheduler.toast) {
                                scheduler.toast('Drum/TOC scheduling complete');
                            }
                            break;
                            
                        default:
                            console.warn('‚ùå Unknown algorithm:', algorithm);
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error applying scheduling algorithm:', error);
                    if (window.scheduler && window.scheduler.toast) {
                        window.scheduler.toast({
                            html: `Error: ${error.message}`,
                            style: 'background-color: #ff4444'
                        });
                    }
                }
            });
            
            // END OF SCHEDULING ALGORITHM HANDLER
            
            // The following section used to contain manual ASAP/ALAP scheduling logic
            // but has been replaced with Bryntum's built-in scheduling engine
            
            /* OLD MANUAL CODE REMOVED - Replaced with Bryntum's propagate() method
                                // ASAP scheduling - schedule as soon as possible (simplified approach)
                                console.log('üöÄ Applying ASAP scheduling with simplified resource tracking...');
                                
                                // Get stores
                                const eventStore = window.scheduler.eventStore;
                                const dependencyStore = window.scheduler.dependencyStore;
                                
                                // Build dependency maps
                                const predecessors = {};
                                dependencyStore.records.forEach(dep => {
                                    if (!predecessors[dep.to]) predecessors[dep.to] = [];
                                    predecessors[dep.to].push(dep.from);
                                });
                                
                                // Project start time
                                const projectStart = new Date();
                                projectStart.setHours(8, 0, 0, 0);
                                
                                // Track the latest end time for each resource (simple timeline)
                                const resourceTimelines = new Map();
                                
                                // Process all events multiple times until all are scheduled
                                const maxIterations = 10;
                                const scheduled = new Set();
                                
                                for (let iteration = 0; iteration < maxIterations && scheduled.size < eventStore.count; iteration++) {
                                    console.log(`\nüìå Iteration ${iteration + 1}`);
                                    
                                    eventStore.records.forEach(event => {
                                        if (scheduled.has(event.id)) return;
                                        
                                        // Check if all dependencies are scheduled
                                        const deps = predecessors[event.id] || [];
                                        const allDepsScheduled = deps.every(depId => scheduled.has(depId));
                                        
                                        if (!allDepsScheduled) return;
                                        
                                        // Calculate duration
                                        const durationMs = event.duration * 60 * 60 * 1000;
                                        
                                        // Get the resource ID - Bryntum stores it as a string
                                        const resourceId = String(event.resourceId);
                                        
                                        // Find earliest start based on dependencies
                                        let earliestStart = projectStart.getTime();
                                        deps.forEach(depId => {
                                            const dep = eventStore.getById(depId);
                                            if (dep && dep.endDate) {
                                                earliestStart = Math.max(earliestStart, dep.endDate.getTime());
                                            }
                                        });
                                        
                                        // Check resource availability
                                        const resourceAvailable = resourceTimelines.get(resourceId) || projectStart.getTime();
                                        const actualStart = Math.max(earliestStart, resourceAvailable);
                                        
                                        // Schedule the event
                                        event.startDate = new Date(actualStart);
                                        event.endDate = new Date(actualStart + durationMs);
                                        
                                        // Update resource timeline
                                        resourceTimelines.set(resourceId, event.endDate.getTime());
                                        
                                        // Mark as scheduled
                                        scheduled.add(event.id);
                                        
                                        console.log(`‚úÖ Scheduled "${event.name}" on Resource ${resourceId}: ${event.startDate.toLocaleString()}`);
                                    });
                                }
                                
                                if (scheduled.size < eventStore.count) {
                                    console.warn(`‚ö†Ô∏è Could not schedule ${eventStore.count - scheduled.size} events due to circular dependencies`);
                                }
                                
                                // Force a refresh of the scheduler view
                                window.scheduler.refresh();
                                
                                console.log(`\n‚úÖ ASAP scheduling completed! Scheduled ${scheduled.size}/${eventStore.count} events`);
                                console.log('Resource timelines:', Object.fromEntries(resourceTimelines));
                                break;
                            case 'alap':
                                // ALAP scheduling - schedule as late as possible
                                console.log('üöÄ Applying ALAP scheduling...');
                                
                                // Get the event store and dependency store
                                const eventStoreALAP = window.scheduler.eventStore;
                                const dependencyStoreALAP = window.scheduler.dependencyStore;
                                
                                // First, collect all events and their resource assignments
                                const eventsByResourceALAP = {};
                                eventStoreALAP.records.forEach(event => {
                                    const resourceId = event.resourceId;
                                    if (!eventsByResourceALAP[resourceId]) {
                                        eventsByResourceALAP[resourceId] = [];
                                    }
                                    eventsByResourceALAP[resourceId].push(event);
                                });
                                
                                // Build a reverse dependency graph (successors for each event)
                                const successorGraph = {};
                                const hasSuccessor = new Set();
                                dependencyStoreALAP.records.forEach(dep => {
                                    if (!successorGraph[dep.to]) {
                                        successorGraph[dep.to] = [];
                                    }
                                    successorGraph[dep.to].push(dep.from);
                                    hasSuccessor.add(dep.from);
                                });
                                
                                // Find ending events (no outgoing dependencies)
                                const endingEvents = eventStoreALAP.records.filter(event => 
                                    !hasSuccessor.has(event.id)
                                );
                                
                                // Set project end date (e.g., 30 days from now)
                                const projectEnd = new Date();
                                projectEnd.setDate(projectEnd.getDate() + 30);
                                projectEnd.setHours(17, 0, 0, 0); // End at 5 PM
                                
                                // Process each resource's events separately to avoid overlaps
                                Object.entries(eventsByResourceALAP).forEach(([resourceId, resourceEvents]) => {
                                    // Sort events by their current end date in reverse (or by ID if no end date)
                                    resourceEvents.sort((a, b) => {
                                        if (b.endDate && a.endDate) {
                                            return b.endDate.getTime() - a.endDate.getTime();
                                        }
                                        return b.id - a.id;
                                    });
                                    
                                    // Track the latest available time for this resource (working backwards)
                                    let resourceLatestTime = projectEnd.getTime();
                                    
                                    // Schedule each event on this resource (working backwards)
                                    resourceEvents.forEach((event, index) => {
                                        // Calculate duration in milliseconds
                                        const durationMs = event.duration * 60 * 60 * 1000; // Convert hours to ms
                                        
                                        // Check for dependencies - if this event has a successor, must finish before it starts
                                        let latestEnd = resourceLatestTime;
                                        
                                        // Check all dependencies where this event is the predecessor
                                        dependencyStoreALAP.records.forEach(dep => {
                                            if (dep.from === event.id) {
                                                const successor = eventStoreALAP.getById(dep.to);
                                                if (successor && successor.startDate) {
                                                    const successorStartTime = successor.startDate.getTime();
                                                    // Subtract lag if specified
                                                    const lagMs = (dep.lag || 0) * 60 * 60 * 1000;
                                                    latestEnd = Math.min(latestEnd, successorStartTime - lagMs);
                                                }
                                            }
                                        });
                                        
                                        // Set the event end time (ALAP = latest possible)
                                        event.endDate = new Date(latestEnd);
                                        event.startDate = new Date(latestEnd - durationMs);
                                        
                                        // Update resource availability for previous event (working backwards)
                                        resourceLatestTime = event.startDate.getTime();
                                        
                                        console.log(`‚úÖ Scheduled "${event.name}" on ${resourceId}: ${event.startDate.toLocaleString()} - ${event.endDate.toLocaleString()}`);
                                    });
                                });
                                
                                // Force a refresh of the scheduler view
                                window.scheduler.refresh();
                                
                                console.log('‚úÖ ALAP scheduling completed - no overlaps!');
                                break;
                            case 'criticalPath':
                                // Critical path method
                                if (window.scheduler.project.calculateCriticalPath) {
                                    window.scheduler.project.calculateCriticalPath();
                                } else {
                                    console.warn('Critical path calculation not available');
                                }
                                break;
                            case 'levelResources':
                                // Resource leveling
                                if (window.scheduler.project.levelResources) {
                                    window.scheduler.project.levelResources();
                                } else {
                                    console.warn('Resource leveling not available');
                                }
                                break;
                            case 'drum':
                                // Theory of Constraints / Drum scheduling
                                console.log('Drum/TOC scheduling - custom implementation needed');
                                break;
                            default:
                                console.warn('Unknown algorithm:', algorithm);
                        }
                        
                        // Re-enable state saving if it was enabled
                        if (originalStateId) {
                            window.scheduler.stateId = originalStateId;
                        }
                        
                        // Show success feedback
                        const notification = document.createElement('div');
                        notification.className = 'scheduler-notification success';
                        notification.textContent = `‚úÖ ${algorithm.toUpperCase()} algorithm applied successfully`;
                        notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000; animation: slideIn 0.3s ease-out;';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            notification.style.animation = 'slideOut 0.3s ease-out';
                            setTimeout(() => notification.remove(), 300);
                        }, 3000);
                    } else {
                        console.error('Scheduler not initialized');
                    }
                } catch (error) {
                    console.error('‚ùå Error applying algorithm:', error);
                    
                    // Show error notification
                    const errorNotification = document.createElement('div');
                    errorNotification.className = 'scheduler-notification error';
                    errorNotification.textContent = `‚ùå Failed to apply algorithm: ${error.message || 'Unknown error'}`;
                    errorNotification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ef4444; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000; animation: slideIn 0.3s ease-out;';
                    document.body.appendChild(errorNotification);
                    
                    setTimeout(() => {
                        errorNotification.style.animation = 'slideOut 0.3s ease-out';
                        setTimeout(() => errorNotification.remove(), 300);
                    }, 5000);
                }
            });
            */ // END OF OLD MANUAL CODE BLOCK
            
            // Add functionality for Save button to update main database
            document.getElementById('saveSchedule').addEventListener('click', async () => {
                try {
                    // Show saving status
                    const saveBtn = document.getElementById('saveSchedule');
                    const originalHTML = saveBtn.innerHTML;
                    saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin"><path d="M21 12a9 9 0 1 1-6-8.485"></path></svg><span>Saving...</span>';
                    saveBtn.disabled = true;
                    
                    // Collect all events with their scheduled times
                    if (window.scheduler && window.scheduler.eventStore) {
                        const events = window.scheduler.eventStore.records;
                        
                        // Prepare operations update data - filter out unscheduled operations
                        const operations = events
                            .filter(event => event.resourceId !== 'unscheduled' && event.startDate && event.endDate)
                            .map(event => {
                                // The event.id corresponds to the ptjoboperations table ID
                                const op = {
                                    id: parseInt(event.id), // Ensure it's a number for the database
                                    start: event.startDate ? event.startDate.toISOString() : null,
                                    end: event.endDate ? event.endDate.toISOString() : null,
                                    manuallyScheduled: event.manuallyScheduled || false
                                };
                                console.log(`üìù Saving operation: ${event.name} (ID: ${op.id}) - Start: ${op.start}, End: ${op.end}`);
                                return op;
                            });
                        
                        if (operations.length === 0) {
                            alert('No scheduled operations to save. Please schedule some operations first.');
                            saveBtn.innerHTML = originalHTML;
                            saveBtn.disabled = false;
                            return;
                        }
                        
                        console.log(`üìù Updating ${operations.length} scheduled operations in database...`);
                        
                        // Get auth token from parent window or localStorage
                        const authToken = window.parent?.localStorage?.getItem('auth_token') || localStorage.getItem('auth_token');
                        
                        // Update main database with new schedule times
                        const response = await fetch('/api/pt-operations/schedule', {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': authToken ? `Bearer ${authToken}` : ''
                            },
                            body: JSON.stringify({ operations })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            // Update last update time
                            document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                            
                            console.log(`‚úÖ Updated ${result.updated}/${result.total} operations in database`);
                            
                            // Show success message
                            saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg><span>Schedule Updated!</span>';
                            
                            // Optional: Also save a version/snapshot for history
                            // This happens automatically with the existing saved-schedules system
                            try {
                                const scheduleData = {
                                    name: `Auto-save - ${new Date().toLocaleString()}`,
                                    description: `Algorithm: ${document.getElementById('schedulingAlgorithm').options[document.getElementById('schedulingAlgorithm').selectedIndex].text}`,
                                    scheduleData: {
                                        events: window.scheduler.eventStore.toJSON(),
                                        resources: window.scheduler.resourceStore.toJSON(),
                                        dependencies: window.scheduler.dependencyStore ? window.scheduler.dependencyStore.toJSON() : []
                                    },
                                    metadata: {
                                        algorithm: document.getElementById('schedulingAlgorithm').value,
                                        savedAt: new Date().toISOString(),
                                        stats: {
                                            operations: result.updated,
                                            utilization: window.currentResourceUtilization || 0,
                                            totalHours: window.currentTotalHours || 0,
                                            resources: window.scheduler.resourceStore.count
                                        }
                                    }
                                };
                                
                                // Save version in background (don't wait for response)
                                fetch('/api/saved-schedules', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': authToken ? `Bearer ${authToken}` : ''
                                    },
                                    body: JSON.stringify(scheduleData)
                                }).then(res => {
                                    if (res.ok) {
                                        console.log('üìö Schedule version saved for history');
                                    }
                                }).catch(err => {
                                    console.warn('Failed to save schedule version:', err);
                                });
                            } catch (versionError) {
                                // Silently fail version save - main update already succeeded
                                console.warn('Could not save schedule version:', versionError);
                            }
                        } else {
                            const error = await response.text();
                            console.error('Failed to update schedule:', error);
                            
                            // Show error
                            saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><span>Update Failed</span>';
                            
                            alert('Failed to update schedule in database. Please try again.');
                        }
                        
                        // Reset button after delay
                        setTimeout(() => {
                            saveBtn.innerHTML = originalHTML;
                            saveBtn.disabled = false;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('‚ùå Error updating schedule:', error);
                    alert('Failed to update schedule. Please check console for details.');
                    
                    // Properly reset the save button
                    const saveBtn = document.getElementById('saveSchedule');
                    if (saveBtn) {
                        saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg><span>Save Schedule</span>';
                        saveBtn.disabled = false;
                    }
                }
            });
            
            // Add Load Schedule functionality
            window.loadSchedule = async function() {
                try {
                    // Get auth token
                    const authToken = window.parent?.localStorage?.getItem('auth_token') || localStorage.getItem('auth_token');
                    
                    // Fetch saved schedules from database
                    const response = await fetch('/api/saved-schedules', {
                        headers: {
                            'Authorization': authToken ? `Bearer ${authToken}` : ''
                        }
                    });
                    
                    if (response.ok) {
                        const schedules = await response.json();
                        
                        if (schedules.length === 0) {
                            // Use Bryntum's MessageDialog instead of alert
                            if (window.scheduler && window.scheduler.bryntum) {
                                window.scheduler.bryntum.MessageDialog.alert({
                                    title: 'No Schedules',
                                    message: 'No saved schedules found'
                                });
                            } else {
                                alert('No saved schedules found');
                            }
                            return;
                        }
                        
                        // Use Bryntum's built-in combo selection dialog
                        if (window.scheduler && window.scheduler.bryntum) {
                            const { Combo, Popup } = window.scheduler.bryntum;
                            
                            // Prepare schedule items for the combo
                            const scheduleItems = schedules.map((s, i) => ({
                                id: i,
                                text: `${s.name} - ${new Date(s.updatedAt).toLocaleDateString()} ${new Date(s.updatedAt).toLocaleTimeString()}`,
                                schedule: s
                            }));
                            
                            // Create a popup with a combo box
                            const popup = new Popup({
                                autoShow: true,
                                centered: true,
                                closable: true,
                                modal: true,
                                title: 'Select a schedule to load',
                                width: 500,
                                items: [
                                    {
                                        type: 'combo',
                                        ref: 'scheduleCombo',
                                        label: 'Schedule',
                                        displayField: 'text',
                                        valueField: 'id',
                                        items: scheduleItems,
                                        placeholder: 'Choose a schedule...',
                                        style: 'margin: 20px'
                                    }
                                ],
                                bbar: [
                                    {
                                        text: 'OK',
                                        cls: 'b-blue',
                                        onClick: async () => {
                                            const combo = popup.widgetMap.scheduleCombo;
                                            const selectedId = combo.value;
                                            
                                            if (selectedId !== null && selectedId !== undefined) {
                                                const selectedItem = scheduleItems.find(item => item.id === selectedId);
                                                if (selectedItem && selectedItem.schedule) {
                                                    await loadSelectedSchedule(selectedItem.schedule);
                                                }
                                            }
                                            popup.close();
                                        }
                                    },
                                    {
                                        text: 'Cancel',
                                        onClick: () => popup.close()
                                    }
                                ]
                            });
                            
                            return;
                        } else {
                            // Fallback to prompt if Bryntum widgets not available
                            const scheduleList = schedules.map((s, i) => 
                                `${i + 1}. ${s.name} (${new Date(s.updatedAt).toLocaleDateString()})`
                            ).join('\n');
                            
                            const selection = prompt(`Select a schedule to load:\n\n${scheduleList}\n\nEnter number (1-${schedules.length}):`);
                            
                            if (selection) {
                                const index = parseInt(selection) - 1;
                                if (index >= 0 && index < schedules.length) {
                                    await loadSelectedSchedule(schedules[index]);
                                }
                            }
                        }
                    } else {
                        // Handle error or fallback to localStorage
                        loadLocalSchedules();
                    }
                } catch (error) {
                    console.error('‚ùå Error loading schedules:', error);
                    alert('Failed to load schedules. Please try again.');
                }
            };
            
            // Helper function to load a selected schedule
            async function loadSelectedSchedule(selectedSchedule) {
                // Load the schedule using Bryntum's loadInlineData method
                if (window.scheduler && window.scheduler.project) {
                    // Load the project data
                    await window.scheduler.project.loadInlineData(selectedSchedule.scheduleData);
                    
                    // Restore metadata if available
                    if (selectedSchedule.metadata) {
                        if (selectedSchedule.metadata.algorithm) {
                            document.getElementById('schedulingAlgorithm').value = selectedSchedule.metadata.algorithm;
                        }
                        if (selectedSchedule.metadata.constraints) {
                            window.activeConstraints = selectedSchedule.metadata.constraints;
                        }
                    }
                    
                    // Store the schedule ID for future updates
                    window.currentScheduleId = selectedSchedule.id;
                    
                    // Zoom to fit the entire schedule in view
                    const events = window.scheduler.eventStore.records;
                    if (events && events.length > 0) {
                        // Find the earliest and latest dates in the schedule
                        let minDate = null;
                        let maxDate = null;
                        
                        events.forEach(event => {
                            if (!minDate || event.startDate < minDate) {
                                minDate = new Date(event.startDate);
                            }
                            if (!maxDate || event.endDate > maxDate) {
                                maxDate = new Date(event.endDate);
                            }
                        });
                        
                        if (minDate && maxDate) {
                            // Add some padding (1 day before and after)
                            minDate.setDate(minDate.getDate() - 1);
                            maxDate.setDate(maxDate.getDate() + 1);
                            
                            // Set the time span to show all events
                            window.scheduler.setTimeSpan(minDate, maxDate);
                            
                            // Adjust zoom level to fit the view
                            // Calculate the number of days to show
                            const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
                            
                            // Set appropriate zoom level based on days
                            if (daysDiff <= 7) {
                                window.scheduler.zoomLevel = 10; // Hour view
                            } else if (daysDiff <= 14) {
                                window.scheduler.zoomLevel = 8; // Day view
                            } else if (daysDiff <= 30) {
                                window.scheduler.zoomLevel = 6; // Week view
                            } else {
                                window.scheduler.zoomLevel = 4; // Month view
                            }
                        }
                    }
                    
                    // Update status
                    document.getElementById('lastUpdate').textContent = `Loaded: ${selectedSchedule.name}`;
                    updateStatus();
                    
                    console.log('‚úÖ Schedule loaded successfully:', selectedSchedule.name);
                }
            }
            
            // Helper function to load local schedules from localStorage
            async function loadLocalSchedules() {
                try {
                    // Fallback to localStorage
                    const localSchedules = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('savedSchedule_') || key.startsWith('scheduleBackup_'))) {
                            try {
                                const data = JSON.parse(localStorage.getItem(key));
                                localSchedules.push({ key, data });
                            } catch (e) {}
                        }
                    }
                    
                    if (localSchedules.length > 0) {
                        const scheduleList = localSchedules.map((s, i) => 
                            `${i + 1}. ${s.data.name || 'Unnamed'} (Local)`
                        ).join('\n');
                        
                        const selection = prompt(`Select a local schedule to load:\n\n${scheduleList}\n\nEnter number:`);
                        if (selection) {
                            const index = parseInt(selection) - 1;
                            if (index >= 0 && index < localSchedules.length) {
                                const selectedSchedule = localSchedules[index].data;
                                if (selectedSchedule.scheduleData || selectedSchedule.data) {
                                    await window.scheduler.project.loadInlineData(selectedSchedule.scheduleData || selectedSchedule.data);
                                        
                                        // Zoom to fit the entire schedule in view
                                        const events = window.scheduler.eventStore.records;
                                        if (events && events.length > 0) {
                                            // Find the earliest and latest dates in the schedule
                                            let minDate = null;
                                            let maxDate = null;
                                            
                                            events.forEach(event => {
                                                if (!minDate || event.startDate < minDate) {
                                                    minDate = new Date(event.startDate);
                                                }
                                                if (!maxDate || event.endDate > maxDate) {
                                                    maxDate = new Date(event.endDate);
                                                }
                                            });
                                            
                                            if (minDate && maxDate) {
                                                // Add some padding (1 day before and after)
                                                minDate.setDate(minDate.getDate() - 1);
                                                maxDate.setDate(maxDate.getDate() + 1);
                                                
                                                // Set the time span to show all events
                                                window.scheduler.setTimeSpan(minDate, maxDate);
                                                
                                                // Adjust zoom level to fit the view
                                                // Calculate the number of days to show
                                                const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
                                                
                                                // Set appropriate zoom level based on days
                                                if (daysDiff <= 7) {
                                                    window.scheduler.zoomLevel = 10; // Hour view
                                                } else if (daysDiff <= 14) {
                                                    window.scheduler.zoomLevel = 8; // Day view
                                                } else if (daysDiff <= 30) {
                                                    window.scheduler.zoomLevel = 6; // Week view
                                                } else {
                                                    window.scheduler.zoomLevel = 4; // Month view
                                                }
                                            }
                                        }
                                        
                                        console.log('‚úÖ Local schedule loaded');
                                    }
                                }
                            }
                    } else {
                        alert('No local schedules found');
                    }
                } catch (error) {
                    console.error('‚ùå Error loading local schedules:', error);
                    alert('Failed to load local schedules. Please try again.');
                }
            }
            
            // Add functionality for Refresh button - simply reload the page
            document.getElementById('refreshSchedule').addEventListener('click', () => {
                // Show refreshing status
                const refreshBtn = document.getElementById('refreshSchedule');
                refreshBtn.classList.add('animate-spin');
                refreshBtn.disabled = true;
                
                console.log('üîÑ Refreshing schedule data...');
                
                // Simply reload the page to get fresh data
                // This ensures all data is fetched with proper authentication
                setTimeout(() => {
                    window.location.reload(true); // Force reload from server, not cache
                }, 300); // Small delay for visual feedback
            });
        });
    </script>
</body>
</html>
