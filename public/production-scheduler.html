<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Force refresh timestamp: 2025-10-01 21:40 v2 -->
    <title>Production Schedule - PlanetTogether</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <!-- Bryntum theme will be loaded in body for proper theme switching -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: auto;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 14px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .header h1 {
            color: #000000;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.9);
            padding: 0.75rem 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding-right: 0.75rem;
            border-right: 1px solid #e0e0e0;
            flex-shrink: 0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar label {
            font-size: 0.8125rem;
            color: #666;
            font-weight: 500;
            white-space: nowrap;
        }

        .toolbar select,
        .toolbar button {
            padding: 0.375rem 0.625rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar select:hover,
        .toolbar button:hover {
            background: #f5f5f5;
            border-color: #999;
        }

        .toolbar button {
            background: white;
            color: #333 !important;
            border: 1px solid #e0e0e0;
            font-weight: 400;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            transition: all 0.2s;
        }

        .toolbar button:hover {
            background: #e8f5e9;
            transform: translateY(-1px);
            border-color: #4CAF50;
            color: #2e7d32 !important;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.2);
        }
        
        .toolbar button.icon-only {
            padding: 0.375rem 0.5rem;
            min-width: 32px;
        }
        
        .toolbar button svg {
            width: 16px;
            height: 16px;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .toolbar {
                padding: 0.5rem 1rem;
                gap: 0.5rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .toolbar-group {
                padding-right: 0.75rem;
                flex-shrink: 0;
            }
            
            .toolbar label {
                display: none; /* Hide labels on mobile to save space */
            }
            
            .toolbar button span:not(.icon-text) {
                display: none; /* Hide button text on mobile, keep icons */
            }
            
            .toolbar button {
                padding: 0.5rem;
                min-width: 40px;
                min-height: 40px;
            }
            
            .toolbar select {
                max-width: 120px;
            }
            
            /* Make scheduler touch-friendly */
            .b-sch-event {
                min-height: 30px !important;
            }
            
            .b-grid-cell {
                padding: 4px !important;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1rem;
            }
            
            .toolbar {
                padding: 0.5rem;
            }
            
            /* Stack toolbar items vertically on very small screens */
            .toolbar-group {
                border-right: none;
                width: 100%;
                justify-content: space-between;
            }
        }

        .scheduler-container {
            flex: 1;
            margin: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #scheduler {
            flex: 1;
            min-height: 0;
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.95);
            padding: 0.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            color: #666;
            border-top: 1px solid #e0e0e0;
            flex-shrink: 0;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ff4444;
            color: white;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem;
            text-align: center;
        }
        
        /* Dark theme overrides */
        .dark-theme {
            background: #1a1a1a;
        }
        
        .dark-theme .header {
            background: rgba(30, 30, 30, 0.95);
            color: white;
        }
        
        .dark-theme .header h1 {
            color: #60a5fa;
        }
        
        .dark-theme .toolbar {
            background: rgba(40, 40, 40, 0.9);
            border-bottom-color: #444;
        }
        
        .dark-theme .toolbar label {
            color: #ccc;
        }
        
        .dark-theme .toolbar button {
            background: #2a2a2a;
            color: #e0e0e0 !important;
            border-color: #444;
        }
        
        .dark-theme .toolbar button:hover {
            background: #1b5e20;
            color: #a5d6a7 !important;
            border-color: #4CAF50;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
        }
        
        .dark-theme .toolbar select {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-theme .toolbar select:hover {
            background: #333;
            border-color: #666;
        }
        
        .dark-theme .status-bar {
            background: rgba(30, 30, 30, 0.95);
            color: #ccc;
            border-top-color: #444;
        }
        
        .dark-theme .scheduler-container {
            background: #2a2a2a;
        }
        
        /* Dark theme for scheduler - Stockholm dark overrides */
        .dark-theme #scheduler,
        .b-theme-stockholm-dark #scheduler {
            background: #1a1a1a;
        }
        
        /* Ensure Stockholm dark theme is applied to scheduler elements */
        .b-theme-stockholm-dark .b-sch-header-timeaxis-cell,
        .b-theme-stockholm-dark .b-grid-header {
            background: #2a2a2a !important;
            color: #e0e0e0 !important;
            border-color: #444 !important;
        }
        
        .b-theme-stockholm-dark .b-grid-row {
            background: #1a1a1a !important;
            color: #e0e0e0 !important;
        }
        
        .b-theme-stockholm-dark .b-grid-row:nth-child(odd) {
            background: #222 !important;
        }
        
        .b-theme-stockholm-dark .b-sch-event {
            border-color: #444 !important;
        }
        
        .b-theme-stockholm-dark .b-grid-cell {
            border-color: #333 !important;
            color: #e0e0e0 !important;
        }
        
        /* Dependency lines styling */
        .b-sch-dependency {
            stroke: #666 !important;
            stroke-width: 2 !important;
            opacity: 0.8 !important;
        }
        
        .b-sch-dependency-arrow {
            fill: #666 !important;
            stroke: #666 !important;
        }
        
        .b-sch-dependency:hover {
            stroke: #333 !important;
            stroke-width: 3 !important;
            opacity: 1 !important;
        }
        
        .b-sch-dependency-arrow:hover {
            fill: #333 !important;
            stroke: #333 !important;
        }
        
        /* Critical path dependency styling */
        .b-sch-dependency.b-critical {
            stroke: #ff4444 !important;
            stroke-width: 3 !important;
        }
        
        .b-sch-dependency.b-critical .b-sch-dependency-arrow {
            fill: #ff4444 !important;
            stroke: #ff4444 !important;
        }
        
        /* Header actions styling */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        /* Navigation Menu - Match main app */
        .nav-menu {
            position: fixed;
            top: 0;
            left: -320px;
            width: 320px;
            height: 100vh;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            transition: left 0.3s ease;
            z-index: 2000;
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.15);
        }
        
        .nav-menu.open {
            left: 0;
        }
        
        .nav-menu-header {
            background: #0f172a;
            color: #f8fafc;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }
        
        .nav-menu-header h3 {
            margin: 0;
        }
        
        .close-menu, .close-max-ai {
            background: transparent;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
        }
        
        .nav-menu-items {
            padding: 1rem;
        }
        
        .nav-item {
            display: block;
            padding: 0.75rem 1rem;
            color: #333;
            text-decoration: none;
            border-radius: 4px;
            transition: background 0.2s;
            margin-bottom: 0.5rem;
        }
        
        .nav-item:hover {
            background: #f5f5f5;
        }
        
        .nav-item.active {
            background: #f0f0f0;
            color: #333;
            font-weight: 500;
        }
        
        /* Max AI Panel - Match main app */
        .max-ai-panel {
            position: fixed;
            top: 0;
            right: 0; /* Visible by default to showcase scheduler features */
            width: 400px;
            height: 100vh;
            background: #ffffff;
            border-left: 1px solid #e2e8f0;
            transition: right 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
        }
        
        .max-ai-panel.closed {
            right: -400px;
        }
        
        .max-ai-header {
            background: #0f172a;
            color: #f8fafc;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }
        
        .max-ai-header h3 {
            margin: 0;
        }
        
        .max-ai-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .max-ai-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .max-ai-message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .max-ai-message.assistant {
            background: #f0f0f0;
            font-size: 0.9rem;
        }
        
        .max-ai-message.user {
            background: rgba(59, 130, 246, 0.1);
            margin-left: 2rem;
        }
        
        .max-ai-message ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }
        
        .max-ai-message strong {
            font-weight: 600;
            color: #333;
        }
        
        .max-ai-input {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #e0e0e0;
            gap: 0.5rem;
        }
        
        .max-ai-input input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.875rem;
        }
        
        .max-ai-input button {
            padding: 0.5rem 1rem;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .max-ai-input button:hover {
            background: #555;
        }
        
        /* Dark theme for nav menu and Max AI */
        .dark-theme .nav-menu,
        .dark-theme .max-ai-panel {
            background: #0f172a;
            color: #f8fafc;
            border-color: #334155;
        }
        
        .dark-theme .nav-menu-header,
        .dark-theme .max-ai-header {
            background: #1e293b;
            border-bottom-color: #475569;
        }
        
        .dark-theme .constraint-modal-content {
            background: #2a2a2a;
            color: white;
        }
        
        .dark-theme .constraint-modal-header {
            background: #333;
            border-bottom-color: #444;
        }
        
        .dark-theme .constraint-modal-header h2 {
            color: white;
        }
        
        .dark-theme .constraint-modal-close {
            color: #ccc;
        }
        
        .dark-theme .constraint-modal-close:hover {
            color: white;
        }
        
        .dark-theme .constraint-section h3 {
            color: white;
            border-bottom-color: #444;
        }
        
        .dark-theme .constraint-group h4 {
            color: #ccc;
        }
        
        .dark-theme .constraint-item:hover {
            background: #333;
        }
        
        .dark-theme .constraint-label {
            color: #e0e0e0;
        }
        
        .dark-theme .constraint-modal-footer {
            background: #333;
            border-top-color: #444;
        }
        
        .dark-theme .constraint-modal-footer button {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-theme .constraint-modal-footer button:hover {
            background: #1b5e20;
            color: #a5d6a7;
            border-color: #4CAF50;
        }
        
        .dark-theme .constraint-modal-footer button.apply {
            background: #2e7d32;
            color: white;
            border-color: #2e7d32;
        }
        
        .dark-theme .constraint-modal-footer button.apply:hover {
            background: #4CAF50;
        }
        
        .dark-theme .nav-item {
            color: #ccc;
        }
        
        .dark-theme .nav-item:hover {
            background: #333;
        }
        
        .dark-theme .nav-item.active {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .dark-theme .max-ai-message.assistant {
            background: #333;
            color: #ccc;
        }
        
        .dark-theme .max-ai-message.user {
            background: rgba(59, 130, 246, 0.2);
            color: #ccc;
        }
        
        .dark-theme .max-ai-input {
            border-top-color: #444;
        }
        
        .dark-theme .max-ai-input input {
            background: #333;
            color: white;
            border-color: #444;
        }
        
        /* Quick Actions Styles */
        .max-ai-quick-actions {
            padding: 0.75rem;
            background: linear-gradient(to right, #eff6ff, #e0e7ff);
            border-bottom: 1px solid #e0e0e0;
        }
        
        .dark-theme .max-ai-quick-actions {
            background: linear-gradient(to right, #1a2332, #202842);
            border-bottom: 1px solid #444;
        }
        
        .quick-actions-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .dark-theme .quick-actions-title {
            color: #cbd5e0;
        }
        
        .quick-actions-section {
            margin-bottom: 0.75rem;
        }
        
        .quick-actions-label {
            font-size: 0.75rem;
            color: #718096;
            margin-bottom: 0.5rem;
        }
        
        .dark-theme .quick-actions-label {
            color: #a0aec0;
        }
        
        .quick-actions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .quick-action-btn {
            padding: 0.5rem;
            font-size: 0.75rem;
            background: white;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        
        .dark-theme .quick-action-btn {
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #e0e0e0;
        }
        
        .quick-action-btn:hover {
            background: #edf2f7;
            border-color: #666;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dark-theme .quick-action-btn:hover {
            background: #374151;
            border-color: #666;
        }
        
        /* Animation styles */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* DBR (Theory of Constraints) Visual Styles */
        .bottleneck-resource {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%) !important;
            border-left: 4px solid #8b5cf6 !important;
            position: relative;
        }
        
        .bottleneck-resource::after {
            content: 'ü•Å';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 20px;
        }
        
        .bottleneck-operation {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(168, 85, 247, 0.2) 100%) !important;
            border: 2px solid #8b5cf6 !important;
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.5) !important;
            font-weight: bold !important;
            position: relative;
        }
        
        .bottleneck-operation::before {
            content: 'ü•Å';
            position: absolute;
            left: 4px;
            top: 4px;
            font-size: 14px;
        }
        
        /* Buffer Zone Visual Indicators */
        .buffer-green {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(34, 197, 94, 0.15) 100%) !important;
            border: 1px solid #10b981 !important;
        }
        
        .buffer-yellow {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(251, 191, 36, 0.15) 100%) !important;
            border: 2px solid #f59e0b !important;
            animation: pulse-warning 2s ease-in-out infinite;
        }
        
        .buffer-red {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.15) 0%, rgba(239, 68, 68, 0.15) 100%) !important;
            border: 2px solid #dc2626 !important;
            box-shadow: 0 0 8px rgba(220, 38, 38, 0.4) !important;
            animation: pulse-critical 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-warning {
            0%, 100% {
                box-shadow: 0 0 6px rgba(245, 158, 11, 0.3);
            }
            50% {
                box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
            }
        }
        
        /* Shipping Buffer Styles */
        .shipping-buffer {
            position: relative;
        }
        
        .shipping-buffer::after {
            content: 'üì¶';
            position: absolute;
            right: 4px;
            top: 4px;
            font-size: 12px;
        }
        
        /* Assembly Buffer Styles */
        .assembly-buffer {
            position: relative;
        }
        
        .assembly-buffer::after {
            content: 'üîß';
            position: absolute;
            right: 4px;
            top: 4px;
            font-size: 12px;
        }
        
        /* ROPE Material Release Indicators */
        .material-release {
            border-left: 3px dashed #6366f1 !important;
            position: relative;
        }
        
        .material-release::before {
            content: 'ü™¢';
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
        }
        
        /* DBR Metrics Panel Specific Styles */
        #dbr-metrics-panel {
            animation: slideIn 0.5s ease-out;
        }
        
        #dbr-metrics-panel .cpm-metrics-title {
            background: linear-gradient(135deg, #8b5cf6, #a855f7);
            color: white !important;
            padding: 10px;
            margin: -12px -12px 12px -12px;
            border-radius: 6px 6px 0 0;
        }
        
        /* WIP Indicators */
        .high-wip {
            opacity: 0.7;
            filter: grayscale(30%);
        }
        
        .reduced-wip {
            opacity: 1;
            filter: none;
        }
        
        /* Enhanced Critical Path Visualization Styles */
        .critical-path-task {
            border: 2px solid #dc2626 !important;
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.1) 0%, rgba(239, 68, 68, 0.1) 100%) !important;
            box-shadow: 0 0 10px rgba(220, 38, 38, 0.4) !important;
            animation: pulse-critical 2s ease-in-out infinite;
        }
        
        .near-critical-task {
            border: 2px solid #f59e0b !important;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.08) 0%, rgba(251, 191, 36, 0.08) 100%) !important;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.3) !important;
        }
        
        .high-slack-task {
            border: 1px solid #10b981 !important;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.05) 0%, rgba(34, 197, 94, 0.05) 100%) !important;
        }
        
        .critical-path-task .b-sch-event-content {
            font-weight: bold !important;
        }
        
        @keyframes pulse-critical {
            0%, 100% {
                box-shadow: 0 0 10px rgba(220, 38, 38, 0.4);
            }
            50% {
                box-shadow: 0 0 20px rgba(220, 38, 38, 0.6);
            }
        }
        
        /* Resource Leveling Visual Indicators */
        .resource-leveled {
            border: 2px dashed #8b5cf6 !important;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%) !important;
            position: relative;
        }
        
        .resource-leveled::after {
            content: '‚öñ';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 12px;
            color: #8b5cf6;
            font-weight: bold;
        }
        
        .resource-overallocated {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.2) 0%, rgba(239, 68, 68, 0.2) 100%) !important;
            border-left: 4px solid #dc2626 !important;
        }
        
        .resource-overallocated-period {
            background: rgba(220, 38, 38, 0.1) !important;
            border: 1px solid rgba(220, 38, 38, 0.3) !important;
        }
        
        @keyframes pulse-moved {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-2px);
            }
        }
        
        .resource-leveled.animate-move {
            animation: pulse-moved 1s ease-in-out 3;
        }
        
        /* Critical path dependency lines */
        .b-sch-dependency.critical-path {
            stroke: #dc2626 !important;
            stroke-width: 3px !important;
            opacity: 1 !important;
        }
        
        .b-sch-dependency-arrow.critical-path {
            fill: #dc2626 !important;
            stroke: #dc2626 !important;
        }
        
        /* Near-critical dependency lines */
        .b-sch-dependency.near-critical {
            stroke: #f59e0b !important;
            stroke-width: 2px !important;
            opacity: 0.9 !important;
        }
        
        /* CPM Metrics Panel */
        .cpm-metrics-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 0.875rem;
            z-index: 100;
            min-width: 200px;
        }
        
        /* PERT-specific styles */
        .pert-low-uncertainty {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(16, 185, 129, 0.1) 100%) !important;
            border: 2px solid #10b981 !important;
        }
        
        .pert-medium-uncertainty {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(245, 158, 11, 0.15) 100%) !important;
            border: 2px solid #f59e0b !important;
        }
        
        .pert-high-uncertainty {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(220, 38, 38, 0.2) 100%) !important;
            border: 2px solid #dc2626 !important;
            animation: pulse-uncertainty 2s ease-in-out infinite;
        }
        
        @keyframes pulse-uncertainty {
            0%, 100% {
                box-shadow: 0 0 10px rgba(220, 38, 38, 0.3);
            }
            50% {
                box-shadow: 0 0 20px rgba(220, 38, 38, 0.5);
            }
        }
        
        .pert-error-bar {
            position: absolute;
            height: 2px;
            background: rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        .pert-error-bar::before,
        .pert-error-bar::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            top: -3px;
        }
        
        .pert-error-bar::before {
            left: 0;
        }
        
        .pert-error-bar::after {
            right: 0;
        }
        
        /* PERT Dialog Styles */
        .pert-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 3000;
            width: 500px;
            max-width: 90vw;
            display: none;
        }
        
        .pert-dialog.active {
            display: block;
            animation: slideIn 0.3s ease-out;
        }
        
        .pert-dialog-header {
            background: linear-gradient(135deg, #8b5cf6, #a855f7);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pert-dialog-body {
            padding: 1.5rem;
        }
        
        .pert-form-group {
            margin-bottom: 1.5rem;
        }
        
        .pert-form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #374151;
        }
        
        .pert-form-group input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }
        
        .pert-form-group input:focus {
            outline: none;
            border-color: #8b5cf6;
        }
        
        .pert-form-group input.error {
            border-color: #dc2626;
        }
        
        .pert-error-message {
            color: #dc2626;
            font-size: 0.85rem;
            margin-top: 0.25rem;
        }
        
        .pert-calculations {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
        }
        
        .pert-calc-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .pert-calc-label {
            color: #6b7280;
            font-size: 0.9rem;
        }
        
        .pert-calc-value {
            font-weight: 600;
            color: #111827;
        }
        
        .pert-dialog-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }
        
        .pert-dialog-footer button {
            padding: 0.625rem 1.25rem;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .pert-btn-cancel {
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            color: #374151;
        }
        
        .pert-btn-cancel:hover {
            background: #e5e7eb;
        }
        
        .pert-btn-save {
            background: linear-gradient(135deg, #8b5cf6, #a855f7);
            border: none;
            color: white;
        }
        
        .pert-btn-save:hover {
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
            transform: translateY(-1px);
        }
        
        /* PERT Metrics Panel */
        .pert-metrics-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #8b5cf6;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.2);
            font-size: 0.875rem;
            z-index: 100;
            min-width: 280px;
            display: none;
        }
        
        .pert-metrics-panel.active {
            display: block;
        }
        
        .pert-metrics-header {
            background: linear-gradient(135deg, #8b5cf6, #a855f7);
            color: white;
            padding: 10px;
            margin: -15px -15px 15px -15px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pert-metrics-section {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .pert-metrics-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .pert-metrics-title {
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 8px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .pert-confidence-level {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 5px 8px;
            background: #f9fafb;
            border-radius: 4px;
        }
        
        .pert-confidence-label {
            color: #6b7280;
            font-size: 0.85rem;
        }
        
        .pert-confidence-date {
            font-weight: 600;
            color: #111827;
            font-size: 0.85rem;
        }
        
        .pert-high-uncertainty-list {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .pert-uncertainty-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #fef2f2;
            border-left: 3px solid #dc2626;
            border-radius: 4px;
            font-size: 0.825rem;
        }
        
        .pert-uncertainty-name {
            font-weight: 500;
            color: #991b1b;
        }
        
        .pert-uncertainty-cv {
            color: #7f1d1d;
            font-size: 0.8rem;
        }
        
        /* Dark theme support for PERT elements */
        .dark-theme .pert-dialog {
            background: #1f2937;
            color: #f9fafb;
        }
        
        .dark-theme .pert-dialog-body {
            background: #1f2937;
        }
        
        .dark-theme .pert-form-group label {
            color: #d1d5db;
        }
        
        .dark-theme .pert-form-group input {
            background: #111827;
            color: #f9fafb;
            border-color: #374151;
        }
        
        .dark-theme .pert-calculations {
            background: #111827;
        }
        
        .dark-theme .pert-calc-value {
            color: #f9fafb;
        }
        
        .dark-theme .pert-metrics-panel {
            background: rgba(31, 41, 55, 0.98);
            color: #f9fafb;
        }
        
        .dark-theme .pert-confidence-level {
            background: #111827;
        }
        
        .dark-theme .pert-confidence-date {
            color: #f9fafb;
        }
        
        .dark-theme .pert-uncertainty-item {
            background: #7f1d1d20;
        }
        
        .dark-theme .cpm-metrics-panel {
            background: rgba(30, 30, 30, 0.95);
            border-color: #444;
            color: #e0e0e0;
        }
        
        .cpm-metrics-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .dark-theme .cpm-metrics-title {
            color: #e0e0e0;
            border-bottom-color: #444;
        }
        
        .cpm-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .cpm-metric-label {
            color: #666;
        }
        
        .dark-theme .cpm-metric-label {
            color: #a0a0a0;
        }
        
        .cpm-metric-value {
            font-weight: 600;
            color: #333;
        }
        
        .dark-theme .cpm-metric-value {
            color: #e0e0e0;
        }
        
        .cpm-metric-value.critical {
            color: #dc2626;
        }
        
        /* Enhanced task tooltips */
        .cpm-tooltip {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            line-height: 1.4;
            max-width: 300px;
        }
        
        .cpm-tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .cpm-tooltip-label {
            color: #a0a0a0;
            margin-right: 8px;
        }
        
        .cpm-tooltip-value {
            color: white;
            font-weight: 500;
        }
        
        .cpm-tooltip-critical {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .cpm-tooltip-near-critical {
            color: #ffd43b;
        }
        
        .cpm-tooltip-safe {
            color: #51cf66;
        }
        
        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        /* Constraint Settings Styles */
        .constraint-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }
        
        .constraint-modal.active {
            display: flex;
        }
        
        .constraint-modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .constraint-modal-header {
            padding: 1rem 1.5rem;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .constraint-modal-header h2 {
            margin: 0;
            font-size: 1.25rem;
            color: #333;
        }
        
        .constraint-modal-close {
            background: transparent;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .constraint-modal-close:hover {
            color: #333;
        }
        
        .constraint-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .constraint-section {
            margin-bottom: 2rem;
        }
        
        .constraint-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            color: #333;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .constraint-group {
            margin-bottom: 1rem;
        }
        
        .constraint-group h4 {
            margin: 0 0 0.5rem 0;
            font-size: 0.95rem;
            color: #555;
            font-weight: 600;
        }
        
        .constraint-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .constraint-item:hover {
            background: #f9f9f9;
        }
        
        .constraint-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
            margin-right: 1rem;
        }
        
        .constraint-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .constraint-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 22px;
        }
        
        .constraint-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        .constraint-toggle input:checked + .constraint-toggle-slider {
            background-color: #4CAF50;
        }
        
        .constraint-toggle input:checked + .constraint-toggle-slider:before {
            transform: translateX(18px);
        }
        
        .constraint-label {
            flex: 1;
            font-size: 0.875rem;
            color: #333;
            cursor: pointer;
        }
        
        .constraint-modal-footer {
            padding: 1rem 1.5rem;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .constraint-modal-footer button {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
        }
        
        .constraint-modal-footer button:hover {
            background: #f5f5f5;
        }
        
        .constraint-modal-footer button.apply {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .constraint-modal-footer button.apply:hover {
            background: #45a049;
        }
        
        .quick-action-btn.full-width {
            grid-column: span 2;
        }
        
        .view-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .view-control-btn {
            flex: 1;
            padding: 0.4rem;
            font-size: 0.7rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .dark-theme .view-control-btn {
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #e0e0e0;
        }
        
        .view-control-btn:hover {
            background: #f7fafc;
            border-color: #a0aec0;
        }
        
        .dark-theme .view-control-btn:hover {
            background: #374151;
        }
        /* TimeSpanHighlight Styles */
        .b-sch-timespan-highlight {
            pointer-events: auto !important;
            opacity: 0.8 !important;
        }
        
        /* Force uniform row heights for ALL rows including header rows */
        .b-grid-row,
        .b-sch-timeaxis-cell,
        .b-grid-header-container .b-grid-row,
        .b-grid-headers .b-grid-row,
        .b-sch-header-row,
        .b-grid-header {
            height: 45px !important;
            max-height: 45px !important;
            min-height: 45px !important;
            line-height: 45px !important;
        }
        
        /* Ensure time axis header rows are also uniform */
        .b-sch-header-timeaxis-cell {
            height: 22px !important; /* Half height for split time axis headers */
            max-height: 22px !important;
            min-height: 22px !important;
        }
        
        /* Resource column cells should match row height */
        .b-grid-cell {
            height: 45px !important;
            line-height: 45px !important;
        }
        
        /* Fix any padding that might affect row heights */
        .b-grid-row .b-grid-cell-inner {
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            display: flex;
            align-items: center;
        }
        
        .b-sch-timespan-highlight:hover {
            opacity: 1 !important;
        }
        
        .maintenance-window {
            background-color: rgba(255, 152, 0, 0.2) !important;
            border-left: 3px solid #ff9800 !important;
        }
        
        .shift-change {
            background-color: rgba(33, 150, 243, 0.15) !important;
            border-left: 3px solid #2196f3 !important;
        }
        
        .deadline-window {
            background-color: rgba(244, 67, 54, 0.15) !important;
            border-left: 4px solid #f44336 !important;
        }
        
        .peak-period {
            background-color: rgba(76, 175, 80, 0.1) !important;
            border-left: 3px solid #4caf50 !important;
        }
        
        .qc-window {
            background-color: rgba(156, 39, 176, 0.1) !important;
            border-left: 3px solid #9c27b0 !important;
        }
        
        .training-window {
            background-color: rgba(0, 188, 212, 0.1) !important;
            border-left: 3px solid #00bcd4 !important;
        }
        
        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .scheduler-notification {
            transition: all 0.3s ease-out;
        }
        
        /* Constraint visual indicators */
        .b-sch-event.constraint-mso {
            border-left: 4px solid #ff5722 !important;
        }
        
        .b-sch-event.constraint-mfo {
            border-right: 4px solid #ff5722 !important;
        }
        
        .b-sch-event.constraint-snet {
            border-left: 4px solid #2196F3 !important;
        }
        
        .b-sch-event.constraint-fnet {
            border-right: 4px solid #2196F3 !important;
        }
        
        .b-sch-event.constraint-snlt {
            border-left: 4px solid #9C27B0 !important;
        }
        
        .b-sch-event.constraint-fnlt {
            border-right: 4px solid #9C27B0 !important;
        }
        
        /* Constraint badge styles */
        .constraint-badge {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
            z-index: 10;
        }
        
        .constraint-badge.mso {
            background: #ff5722;
        }
        
        .constraint-badge.mfo {
            background: #ff5722;
        }
        
        .constraint-badge.snet {
            background: #2196F3;
        }
        
        .constraint-badge.fnet {
            background: #2196F3;
        }
        
        .constraint-badge.snlt {
            background: #9C27B0;
        }
        
        .constraint-badge.fnlt {
            background: #9C27B0;
        }
        
        /* Force uniform 45px row heights for all rows in the scheduler */
        .b-schedulerpro .b-grid-row,
        .b-schedulerpro .b-sch-timeaxiscolumn,
        .b-schedulerpro .b-grid-headers-normal .b-grid-header-row,
        .b-schedulerpro .b-sch-timeaxis-cell,
        .b-schedulerpro .b-resourceheader,
        .b-schedulerpro .b-depth-0,
        .b-schedulerpro .b-depth-1,
        .b-schedulerpro .b-grid-body-container .b-grid-row {
            height: 45px !important;
            min-height: 45px !important;
            max-height: 45px !important;
            line-height: 45px !important;
        }
        
        /* Ensure all grid cells match the row height */
        .b-schedulerpro .b-grid-cell,
        .b-schedulerpro .b-grid-cell-inner,
        .b-schedulerpro .b-resourceheader-cell {
            height: 45px !important;
            line-height: 45px !important;
            padding: 0 10px !important;
            display: flex !important;
            align-items: center !important;
        }
        
        /* Fix time axis header heights */
        .b-schedulerpro .b-sch-header-row,
        .b-schedulerpro .b-sch-header-timeaxis-main,
        .b-schedulerpro .b-sch-header-row-main,
        .b-schedulerpro .b-sch-simple-timeaxis .b-sch-header-row {
            height: 45px !important;
            min-height: 45px !important;
            max-height: 45px !important;
        }
        
        /* Ensure event bars fit within row height */
        .b-schedulerpro .b-sch-event-wrap,
        .b-schedulerpro .b-sch-event {
            max-height: 35px !important; /* 45px row minus 10px for margins */
        }
        
        /* Fix row containers and background elements */
        .b-schedulerpro .b-scheduler-foreground-canvas,
        .b-schedulerpro .b-sch-timeaxis-tick,
        .b-schedulerpro .b-grid-row > * {
            height: 45px !important;
        }
        
        /* Prevent any flex or auto-sizing from overriding row height */
        .b-schedulerpro .b-grid-body-container {
            font-size: 14px !important; /* Consistent font size */
        }
        
        .b-schedulerpro .b-grid-row {
            flex: 0 0 45px !important; /* Fixed flex height */
        }
    </style>
</head>
<body>
    <!-- Bryntum Stockholm theme link - must be in body for proper theme switching -->
    <link rel="stylesheet" href="/schedulerpro.stockholm.css" id="bryntum-theme">
    
    <div class="header">
        <h1>Production Schedule</h1>
        <div class="header-actions">
            <span id="lastUpdate">Last updated: --</span>
        </div>
    </div>
    

    <div class="toolbar">
        <div class="toolbar-group">
            <label for="viewPreset">View:</label>
            <select id="viewPreset">
                <option value="hourAndDay">Hour & Day</option>
                <option value="dayAndWeek" selected>Day & Week</option>
                <option value="weekAndMonth">Week & Month</option>
                <option value="monthAndYear">Month & Year</option>
            </select>
        </div>

        <div class="toolbar-group" style="display: flex; gap: 0.25rem;">
            <button id="zoomIn" class="icon-only" title="Zoom In">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <button id="zoomOut" class="icon-only" title="Zoom Out">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <button id="zoomToFit" class="icon-only" title="Fit to View">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                </svg>
            </button>
        </div>

        <div class="toolbar-group">
            <label for="schedulingAlgorithm">Algorithm:</label>
            <select id="schedulingAlgorithm">
                <option value="asap">ASAP (Forward)</option>
                <option value="alap">ALAP (Limited Support)</option>
                <option value="criticalPath">Critical Path (Simplified)</option>
                <option value="levelResources">Resource Leveling</option>
                <option value="dbr">Theory of Constraints (DBR)</option>
                <option value="pert">PERT (Probabilistic)</option>
            </select>
            <button id="applyScheduling">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
                <span>Apply</span>
            </button>
            <button id="constraintSettings" title="Configure Constraints">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                </svg>
                <span>Constraints</span>
            </button>
        </div>

        <div class="toolbar-group">
            <button id="saveSchedule">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                    <polyline points="7 3 7 8 15 8"></polyline>
                </svg>
                <span>Save</span>
            </button>
            <button id="loadScheduleBtn" onclick="loadSchedule()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                <span>Load</span>
            </button>
            <button id="refreshSchedule" class="icon-only" title="Refresh">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
            </button>
        </div>

        <div class="toolbar-group">
            <button id="saveVersion" title="Save current state as version">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <polyline points="21 15 16 10 5 21"></polyline>
                </svg>
                <span>Save Version</span>
            </button>
            <button id="viewVersions" title="View saved versions">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                </svg>
                <span>Versions</span>
            </button>
            <button id="compareVersions" title="Compare versions">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="18" cy="18" r="3"></circle>
                    <circle cx="6" cy="6" r="3"></circle>
                    <path d="M13 6h3a2 2 0 0 1 2 2v7"></path>
                    <path d="M11 18H8a2 2 0 0 1-2-2V9"></path>
                </svg>
                <span>Compare</span>
            </button>
        </div>
    </div>

    <div class="scheduler-container">
        <div id="scheduler"></div>
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>
    
    <!-- Constraint Editor Dialog -->
    <div id="constraintDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 1px solid #ccc; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 3000; min-width: 400px;">
        <h3 style="margin-top: 0; color: #333;">Set Operation Constraint</h3>
        <div id="constraintOperationName" style="font-weight: bold; margin-bottom: 15px; color: #666;"></div>
        
        <div style="margin-bottom: 15px;">
            <label for="constraintType" style="display: block; margin-bottom: 5px; font-weight: 500;">Constraint Type:</label>
            <select id="constraintType" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">Select constraint...</option>
                <option value="MSO">MSO - Must Start On</option>
                <option value="MFO">MFO - Must Finish On</option>
                <option value="SNET">SNET - Start No Earlier Than</option>
                <option value="FNET">FNET - Finish No Earlier Than</option>
                <option value="SNLT">SNLT - Start No Later Than</option>
                <option value="FNLT">FNLT - Finish No Later Than</option>
                <option value="None">None - Remove Constraint</option>
            </select>
        </div>
        
        <div id="constraintDateContainer" style="margin-bottom: 20px;">
            <label for="constraintDate" style="display: block; margin-bottom: 5px; font-weight: 500;">Constraint Date:</label>
            <input type="datetime-local" id="constraintDate" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        
        <div style="display: flex; justify-content: flex-end; gap: 10px;">
            <button onclick="closeConstraintDialog()" style="padding: 8px 16px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">Cancel</button>
            <button onclick="saveConstraint()" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Save Constraint</button>
        </div>
    </div>
    
    <!-- Constraint overlay backdrop -->
    <div id="constraintOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2999;"></div>

    <div class="status-bar">
        <span id="operationCount">0 operations scheduled</span>
        <span id="resourceUtilization">Resource utilization: --</span>
    </div>
    
    <!-- Constraint Settings Modal -->
    <div id="constraintModal" class="constraint-modal">
        <div class="constraint-modal-content">
            <div class="constraint-modal-header">
                <h2>Optimization Constraints Configuration</h2>
                <button class="constraint-modal-close" onclick="closeConstraintModal()">√ó</button>
            </div>
            <div class="constraint-modal-body">
                <!-- Physical Constraints Section -->
                <div class="constraint-section">
                    <h3>Physical Constraints</h3>
                    
                    <div class="constraint-group">
                        <h4>General Validation Rules</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="noOverlap" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="noOverlap" class="constraint-label">No overlapping activities (unless overlap features enabled)</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="dateValidation" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="dateValidation" class="constraint-label">Start date must precede end date</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="mandatoryFields" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="mandatoryFields" class="constraint-label">Activities must include mandatory fields</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Dependency Constraints</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="predecessorLogic" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="predecessorLogic" class="constraint-label">Follow predecessor/successor logic (FS, SS, etc.)</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="noCircular" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="noCircular" class="constraint-label">Prevent circular dependencies</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Time Constraints</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="workingHours" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="workingHours" class="constraint-label">Align with working hours and holidays</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="leadLagTimes" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="leadLagTimes" class="constraint-label">Respect lead/lag times for dependencies</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Resource Constraints</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="noOverAllocation" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="noOverAllocation" class="constraint-label">Prevent resource over-allocation</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="skillMatching" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="skillMatching" class="constraint-label">Match resource skills/capabilities</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="capacityLimits" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="capacityLimits" class="constraint-label">Respect capacity limits (e.g., machine throughput)</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Inventory/Material Constraints</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="materialAvailability" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="materialAvailability" class="constraint-label">Required material must be available</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="batchSizeRules" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="batchSizeRules" class="constraint-label">Adhere to min/max batch size rules</label>
                        </div>
                    </div>
                </div>
                
                <!-- Policy Constraints Section -->
                <div class="constraint-section">
                    <h3>Policy Constraints</h3>
                    
                    <div class="constraint-group">
                        <h4>Business Rules</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="priorityRules" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="priorityRules" class="constraint-label">High-priority activities given preference</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="needDates" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="needDates" class="constraint-label">Jobs must meet Need Dates</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="budgetConstraints">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="budgetConstraints" class="constraint-label">Stay within budgeted labor/resource costs</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Time Flexibility</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="weekendWork">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="weekendWork" class="constraint-label">Permit weekend/holiday work for deadlines</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="workloadBalance" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="workloadBalance" class="constraint-label">Balance workload across shifts</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="limitOvertime" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="limitOvertime" class="constraint-label">Limit overtime to control labor costs</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Process Flow</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="parallelProcessing">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="parallelProcessing" class="constraint-label">Allow parallel processing for non-dependent activities</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="alternativeRouting">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="alternativeRouting" class="constraint-label">Permit alternative routing paths</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="skipNonCritical">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="skipNonCritical" class="constraint-label">Skip non-critical steps for low-priority orders</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="preventSameSetup" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="preventSameSetup" class="constraint-label">Prevent same setup type on multiple resources</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Material Handling</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="justInTime">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="justInTime" class="constraint-label">Schedule assuming just-in-time material delivery</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="substituteMaterials">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="substituteMaterials" class="constraint-label">Allow substitute materials if primary unavailable</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="partialMaterial">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="partialMaterial" class="constraint-label">Start with partial material availability</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Cost Control</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="avoidPeakRates" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="avoidPeakRates" class="constraint-label">Avoid high-energy activities during peak utility rates</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="costEfficiency">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="costEfficiency" class="constraint-label">Prioritize cost-efficient activities over urgency</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="restrictPremium" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="restrictPremium" class="constraint-label">Restrict use of premium resources unless necessary</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Quality & Compliance</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="deferredInspections">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="deferredInspections" class="constraint-label">Allow deferred inspections post-production</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="processDeviations">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="processDeviations" class="constraint-label">Accept minor deviations within tolerance</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="auditTrails" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="auditTrails" class="constraint-label">Enable detailed audit trails</label>
                        </div>
                    </div>
                    
                    <div class="constraint-group">
                        <h4>Optimization Preferences</h4>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="minimizeMakespan" checked>
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="minimizeMakespan" class="constraint-label">Minimize makespan to complete jobs quickly</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="maximizeUtilization">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="maximizeUtilization" class="constraint-label">Maximize machine utilization over labor cost</label>
                        </div>
                        <div class="constraint-item">
                            <label class="constraint-toggle">
                                <input type="checkbox" id="prioritizeMargin">
                                <span class="constraint-toggle-slider"></span>
                            </label>
                            <label for="prioritizeMargin" class="constraint-label">Prioritize high-margin orders when capacity limited</label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="constraint-modal-footer">
                <button onclick="resetConstraints()">Reset to Defaults</button>
                <button onclick="closeConstraintModal()">Cancel</button>
                <button class="apply" onclick="applyConstraints()">Apply Constraints</button>
            </div>
        </div>
    </div>

    <!-- Load Bryntum Scheduler Pro UMD -->
    <script src="/schedulerpro.umd.js"></script>
    
    <!-- Initialize the scheduler -->
    <script>
        // Wait for DOM and Bryntum to load
        // Guard to prevent multiple initialization attempts
        let schedulerInitialized = false;
        
        document.addEventListener('DOMContentLoaded', async () => {
            // Prevent multiple initialization
            if (schedulerInitialized) {
                console.log('Scheduler already initialized, skipping...');
                return;
            }
            schedulerInitialized = true;
            
            // Helper function to show notifications
            function showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = 'scheduler-notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 4px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                    z-index: 10000;
                    animation: slideIn 0.3s ease-out;
                    max-width: 400px;
                `;
                
                // Set color based on type
                switch(type) {
                    case 'success':
                        notification.style.background = '#4CAF50';
                        notification.style.color = 'white';
                        break;
                    case 'error':
                        notification.style.background = '#f44336';
                        notification.style.color = 'white';
                        break;
                    case 'warning':
                        notification.style.background = '#ff9800';
                        notification.style.color = 'white';
                        break;
                    default:
                        notification.style.background = '#2196F3';
                        notification.style.color = 'white';
                }
                
                notification.textContent = message;
                document.body.appendChild(notification);
                
                // Auto-remove after 3 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 300);
                }, 3000);
            }
            
            // Make notification function globally available
            window.showNotification = showNotification;
            
            // PERT Data Storage
            window.pertEstimates = {};
            window.currentPertOperationId = null;
            
            // PERT Calculation Engine
            const PERTCalculator = {
                // Calculate expected time: (O + 4M + P) / 6
                calculateExpectedTime: function(optimistic, mostLikely, pessimistic) {
                    return (optimistic + 4 * mostLikely + pessimistic) / 6;
                },
                
                // Calculate variance: ((P - O) / 6)^2
                calculateVariance: function(optimistic, pessimistic) {
                    const diff = (pessimistic - optimistic) / 6;
                    return diff * diff;
                },
                
                // Calculate standard deviation: (P - O) / 6
                calculateStandardDeviation: function(optimistic, pessimistic) {
                    return (pessimistic - optimistic) / 6;
                },
                
                // Calculate coefficient of variation: std dev / expected time
                calculateCoefficientOfVariation: function(stdDev, expectedTime) {
                    if (expectedTime === 0) return 0;
                    return (stdDev / expectedTime) * 100;
                },
                
                // Calculate project metrics from critical path
                calculateProjectMetrics: function(criticalPathEvents) {
                    let totalExpectedDuration = 0;
                    let totalVariance = 0;
                    const highUncertaintyOps = [];
                    
                    criticalPathEvents.forEach(event => {
                        const eventId = event.id;
                        if (window.pertEstimates[eventId]) {
                            const estimates = window.pertEstimates[eventId];
                            totalExpectedDuration += estimates.expectedTime;
                            totalVariance += estimates.variance;
                            
                            if (estimates.cv > 20) {
                                highUncertaintyOps.push({
                                    name: event.name,
                                    cv: estimates.cv.toFixed(1),
                                    stdDev: estimates.stdDev
                                });
                            }
                        } else {
                            // Use current duration if no PERT estimates
                            totalExpectedDuration += event.duration || 2;
                        }
                    });
                    
                    const projectStdDev = Math.sqrt(totalVariance);
                    
                    return {
                        expectedDuration: totalExpectedDuration,
                        variance: totalVariance,
                        stdDev: projectStdDev,
                        highUncertaintyOps: highUncertaintyOps
                    };
                },
                
                // Calculate confidence levels using normal distribution
                calculateConfidenceLevels: function(expectedDuration, stdDev, startDate) {
                    const baseDate = new Date(startDate);
                    
                    // Expected completion date
                    const expectedDate = new Date(baseDate);
                    expectedDate.setHours(expectedDate.getHours() + expectedDuration);
                    
                    // 68% confidence (¬±1œÉ)
                    const date68 = new Date(expectedDate);
                    date68.setHours(date68.getHours() + stdDev);
                    
                    // 95% confidence (¬±2œÉ)
                    const date95 = new Date(expectedDate);
                    date95.setHours(date95.getHours() + (2 * stdDev));
                    
                    // 99.7% confidence (¬±3œÉ)
                    const date99 = new Date(expectedDate);
                    date99.setHours(date99.getHours() + (3 * stdDev));
                    
                    return {
                        confidence68: date68,
                        confidence95: date95,
                        confidence99: date99
                    };
                }
            };
            
            // PERT Dialog Functions
            window.openPertDialog = function(operationId, operationName) {
                window.currentPertOperationId = operationId;
                document.getElementById('pertOperationName').textContent = operationName || 'Operation ' + operationId;
                
                // Clear previous values
                document.getElementById('pertOptimistic').value = '';
                document.getElementById('pertMostLikely').value = '';
                document.getElementById('pertPessimistic').value = '';
                document.getElementById('pertCalculations').style.display = 'none';
                
                // Clear error messages
                document.getElementById('pertOptimisticError').textContent = '';
                document.getElementById('pertMostLikelyError').textContent = '';
                document.getElementById('pertPessimisticError').textContent = '';
                
                // Load existing PERT estimates if available
                if (window.pertEstimates[operationId]) {
                    const estimates = window.pertEstimates[operationId];
                    document.getElementById('pertOptimistic').value = estimates.optimistic;
                    document.getElementById('pertMostLikely').value = estimates.mostLikely;
                    document.getElementById('pertPessimistic').value = estimates.pessimistic;
                    updatePertCalculations();
                }
                
                // Show dialog
                document.getElementById('pertDialog').classList.add('active');
            };
            
            window.closePertDialog = function() {
                document.getElementById('pertDialog').classList.remove('active');
                window.currentPertOperationId = null;
            };
            
            window.savePertEstimates = function() {
                const optimistic = parseFloat(document.getElementById('pertOptimistic').value);
                const mostLikely = parseFloat(document.getElementById('pertMostLikely').value);
                const pessimistic = parseFloat(document.getElementById('pertPessimistic').value);
                
                // Validate inputs
                let hasError = false;
                
                if (!optimistic || optimistic <= 0) {
                    document.getElementById('pertOptimisticError').textContent = 'Please enter a valid positive number';
                    hasError = true;
                } else {
                    document.getElementById('pertOptimisticError').textContent = '';
                }
                
                if (!mostLikely || mostLikely <= 0) {
                    document.getElementById('pertMostLikelyError').textContent = 'Please enter a valid positive number';
                    hasError = true;
                } else {
                    document.getElementById('pertMostLikelyError').textContent = '';
                }
                
                if (!pessimistic || pessimistic <= 0) {
                    document.getElementById('pertPessimisticError').textContent = 'Please enter a valid positive number';
                    hasError = true;
                } else {
                    document.getElementById('pertPessimisticError').textContent = '';
                }
                
                // Check O ‚â§ M ‚â§ P constraint
                if (!hasError) {
                    if (optimistic > mostLikely) {
                        document.getElementById('pertOptimisticError').textContent = 'Optimistic time must be ‚â§ Most Likely time';
                        hasError = true;
                    }
                    if (mostLikely > pessimistic) {
                        document.getElementById('pertPessimisticError').textContent = 'Pessimistic time must be ‚â• Most Likely time';
                        hasError = true;
                    }
                }
                
                if (hasError) return;
                
                // Calculate PERT values
                const expectedTime = PERTCalculator.calculateExpectedTime(optimistic, mostLikely, pessimistic);
                const variance = PERTCalculator.calculateVariance(optimistic, pessimistic);
                const stdDev = PERTCalculator.calculateStandardDeviation(optimistic, pessimistic);
                const cv = PERTCalculator.calculateCoefficientOfVariation(stdDev, expectedTime);
                
                // Store PERT estimates
                window.pertEstimates[window.currentPertOperationId] = {
                    optimistic: optimistic,
                    mostLikely: mostLikely,
                    pessimistic: pessimistic,
                    expectedTime: expectedTime,
                    variance: variance,
                    stdDev: stdDev,
                    cv: cv
                };
                
                // Update the event duration with expected time
                if (window.scheduler && window.scheduler.eventStore) {
                    const event = window.scheduler.eventStore.getById(window.currentPertOperationId);
                    if (event) {
                        event.duration = expectedTime;
                        
                        // Apply uncertainty visual indicators
                        event.cls = event.cls ? event.cls.replace(/pert-\w+-uncertainty/g, '') : '';
                        if (cv < 10) {
                            event.cls = (event.cls || '') + ' pert-low-uncertainty';
                        } else if (cv < 20) {
                            event.cls = (event.cls || '') + ' pert-medium-uncertainty';
                        } else {
                            event.cls = (event.cls || '') + ' pert-high-uncertainty';
                        }
                        
                        // Store PERT data on the event
                        event.pertData = window.pertEstimates[window.currentPertOperationId];
                        
                        window.scheduler.refresh();
                    }
                }
                
                // Update PERT metrics if panel is visible
                if (document.getElementById('pertMetricsPanel').classList.contains('active')) {
                    updatePertMetrics();
                }
                
                showNotification(`PERT estimates saved: Expected time = ${expectedTime.toFixed(2)} hours`, 'success');
                closePertDialog();
            };
            
            // Update PERT calculations in real-time
            function updatePertCalculations() {
                const optimistic = parseFloat(document.getElementById('pertOptimistic').value);
                const mostLikely = parseFloat(document.getElementById('pertMostLikely').value);
                const pessimistic = parseFloat(document.getElementById('pertPessimistic').value);
                
                if (optimistic && mostLikely && pessimistic && optimistic <= mostLikely && mostLikely <= pessimistic) {
                    const expectedTime = PERTCalculator.calculateExpectedTime(optimistic, mostLikely, pessimistic);
                    const variance = PERTCalculator.calculateVariance(optimistic, pessimistic);
                    const stdDev = PERTCalculator.calculateStandardDeviation(optimistic, pessimistic);
                    const cv = PERTCalculator.calculateCoefficientOfVariation(stdDev, expectedTime);
                    
                    document.getElementById('pertExpectedTime').textContent = expectedTime.toFixed(2) + ' hours';
                    document.getElementById('pertStdDev').textContent = stdDev.toFixed(2) + ' hours';
                    document.getElementById('pertVariance').textContent = variance.toFixed(2);
                    document.getElementById('pertCV').textContent = cv.toFixed(1) + '%';
                    
                    document.getElementById('pertCalculations').style.display = 'block';
                } else {
                    document.getElementById('pertCalculations').style.display = 'none';
                }
            }
            
            // Add event listeners for real-time calculation updates
            document.addEventListener('DOMContentLoaded', function() {
                const pertInputs = ['pertOptimistic', 'pertMostLikely', 'pertPessimistic'];
                pertInputs.forEach(id => {
                    const input = document.getElementById(id);
                    if (input) {
                        input.addEventListener('input', updatePertCalculations);
                    }
                });
            });
            
            // Update PERT metrics panel
            function updatePertMetrics() {
                if (!window.scheduler) return;
                
                // Get all events
                const events = window.scheduler.eventStore.records;
                
                // For simplicity, consider all events as critical path
                // In production, you would identify the actual critical path
                const criticalPathEvents = events.filter(e => e.resourceId !== 'unscheduled');
                
                const metrics = PERTCalculator.calculateProjectMetrics(criticalPathEvents);
                
                // Update duration metrics
                document.getElementById('pertProjectDuration').textContent = metrics.expectedDuration.toFixed(1) + ' hours';
                document.getElementById('pertProjectStdDev').textContent = metrics.stdDev.toFixed(2) + ' hours';
                document.getElementById('pertCriticalVariance').textContent = metrics.variance.toFixed(2);
                
                // Calculate confidence dates
                const startDate = new Date(2025, 8, 3, 7, 0, 0);
                const confidenceLevels = PERTCalculator.calculateConfidenceLevels(
                    metrics.expectedDuration,
                    metrics.stdDev,
                    startDate
                );
                
                document.getElementById('pertConfidence68').textContent = confidenceLevels.confidence68.toLocaleDateString();
                document.getElementById('pertConfidence95').textContent = confidenceLevels.confidence95.toLocaleDateString();
                document.getElementById('pertConfidence99').textContent = confidenceLevels.confidence99.toLocaleDateString();
                
                // Update high uncertainty operations list
                const listContainer = document.getElementById('pertHighUncertaintyList');
                if (metrics.highUncertaintyOps.length > 0) {
                    listContainer.innerHTML = metrics.highUncertaintyOps.map(op => `
                        <div class="pert-uncertainty-item">
                            <div class="pert-uncertainty-name">${op.name}</div>
                            <div class="pert-uncertainty-cv">CV: ${op.cv}%</div>
                        </div>
                    `).join('');
                } else {
                    listContainer.innerHTML = '<div style="color: #6b7280; font-size: 0.85rem;">All operations have acceptable uncertainty</div>';
                }
            }
            
            window.closePertMetrics = function() {
                document.getElementById('pertMetricsPanel').classList.remove('active');
            };
            
            // Constraint Management Functions
            window.currentOperationId = null;
            
            // Open constraint dialog for an operation
            window.openConstraintDialog = function(operationId, operationName) {
                window.currentOperationId = operationId;
                document.getElementById('constraintOperationName').textContent = operationName || 'Operation ' + operationId;
                
                // Reset form
                document.getElementById('constraintType').value = '';
                document.getElementById('constraintDate').value = '';
                
                // Check if operation already has constraint
                if (window.scheduler && window.scheduler.eventStore) {
                    const event = window.scheduler.eventStore.getById(operationId);
                    if (event && event.data) {
                        if (event.data.constraintType) {
                            document.getElementById('constraintType').value = event.data.constraintType;
                        }
                        if (event.data.constraintDate) {
                            const date = new Date(event.data.constraintDate);
                            const localDateTime = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                            document.getElementById('constraintDate').value = localDateTime;
                        }
                    }
                }
                
                // Show dialog
                document.getElementById('constraintDialog').style.display = 'block';
                document.getElementById('constraintOverlay').style.display = 'block';
                
                // Handle constraint type change
                document.getElementById('constraintType').onchange = function() {
                    const dateContainer = document.getElementById('constraintDateContainer');
                    if (this.value === 'None' || this.value === '') {
                        dateContainer.style.display = 'none';
                    } else {
                        dateContainer.style.display = 'block';
                    }
                };
                
                // Trigger initial visibility check
                document.getElementById('constraintType').onchange();
            };
            
            // Close constraint dialog
            window.closeConstraintDialog = function() {
                document.getElementById('constraintDialog').style.display = 'none';
                document.getElementById('constraintOverlay').style.display = 'none';
                window.currentOperationId = null;
            };
            
            // Save constraint to backend
            window.saveConstraint = async function() {
                const constraintType = document.getElementById('constraintType').value;
                const constraintDate = document.getElementById('constraintDate').value;
                
                if (!constraintType) {
                    alert('Please select a constraint type');
                    return;
                }
                
                if (constraintType !== 'None' && !constraintDate) {
                    alert('Please select a constraint date');
                    return;
                }
                
                try {
                    // Send constraint update to backend
                    const response = await fetch(`/api/operations/${window.currentOperationId}/constraint`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            constraintType: constraintType,
                            constraintDate: constraintType === 'None' ? null : constraintDate
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Update the event in scheduler
                        if (window.scheduler && window.scheduler.eventStore) {
                            const event = window.scheduler.eventStore.getById(window.currentOperationId);
                            if (event) {
                                event.data.constraintType = constraintType === 'None' ? null : constraintType;
                                event.data.constraintDate = constraintType === 'None' ? null : constraintDate;
                                
                                // Update event rendering to show constraint badge
                                event.cls = event.cls ? event.cls.replace(/constraint-\w+/g, '') : '';
                                if (constraintType !== 'None' && constraintType) {
                                    event.cls = (event.cls || '') + ' constraint-' + constraintType.toLowerCase();
                                }
                                
                                // Refresh the scheduler view
                                window.scheduler.refresh();
                            }
                        }
                        
                        // Show success notification
                        showNotification('Constraint updated successfully', 'success');
                        closeConstraintDialog();
                    } else {
                        alert('Failed to update constraint: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error updating constraint:', error);
                    alert('Failed to update constraint. Please try again.');
                }
            };
            
            // Add click handler to overlay to close dialog
            document.getElementById('constraintOverlay').onclick = function() {
                closeConstraintDialog();
            };
            
            try {
                // Mark first task as in progress
                
                // Initialize scheduler using global bryntum object
                const { SchedulerPro } = bryntum.schedulerpro;
                
                // Set today's date to September 3, 2025
                const today = new Date(2025, 8, 3); // September 3, 2025
                today.setHours(8, 0, 0, 0); // Start at 8 AM
                
                // Helper to create a date relative to September 3, 2025
                function createDate(hoursFromNow) {
                    const date = new Date(2025, 8, 3); // September 3, 2025
                    date.setHours(8 + hoursFromNow, 0, 0, 0); // Start at 8 AM
                    return date;
                }
                
                // Fetch real PT operations and resources from the backend
                let resources = [];
                let ptOperations = [];
                let resourceCapabilities = {};
                
                try {
                    // Fetch resources, PT operations, and dependencies from the backend APIs
                    const [resourcesResponse, operationsResponse, dependenciesResponse, capabilitiesResponse] = await Promise.all([
                        fetch('/api/resources'),
                        fetch('/api/pt-operations'),
                        fetch('/api/pt-dependencies'),
                        fetch('/api/resources-with-capabilities')
                    ]);
                    
                    if (resourcesResponse.ok) {
                        resources = await resourcesResponse.json();
                        console.log('‚úÖ Resources fetched successfully:', resources.length);
                        console.log('First 3 resources:', resources.slice(0, 3));
                        
                        // CRITICAL: Sort resources to ensure proper grouping 
                        // (fermentation tanks together, bright tanks together, packaging together)
                        // Define order for resource types
                        const getOrder = (name) => {
                            const lowerName = name.toLowerCase();
                            // 1. MILLING (top)
                            if (lowerName.includes('mill')) return 1;
                            // 2. MASHING
                            if (lowerName.includes('mash')) return 2;
                            // 3. LAUTERING
                            if (lowerName.includes('lauter')) return 3;
                            // 4. BOILING/KETTLE
                            if (lowerName.includes('boil') || lowerName.includes('kettle')) return 4;
                            // 5. WHIRLPOOL
                            if (lowerName.includes('whirlpool')) return 5;
                            // 6. COOLING
                            if (lowerName.includes('cool')) return 6;
                            // 7. ALL FERMENTATION TANKS (grouped together)
                            if (lowerName.includes('ferment')) return 7;
                            // 8. ALL BRIGHT/CONDITIONING TANKS (grouped together)
                            if (lowerName.includes('bright') || lowerName.includes('condition')) return 8;
                            // 9. PASTEURIZATION
                            if (lowerName.includes('pasteur')) return 9;
                            // 10. ALL PACKAGING/FILLING (bottling and canning grouped together)
                            if (lowerName.includes('bottle') || lowerName.includes('can') || lowerName.includes('filler') || lowerName.includes('packag')) return 10;
                            // 11. Any other resources
                            return 11;
                        };
                        
                        // Sort resources and add explicit sortOrder field
                        resources.sort((a, b) => {
                            const aName = (a.name || '').toLowerCase();
                            const bName = (b.name || '').toLowerCase();
                            
                            const aOrder = getOrder(aName);
                            const bOrder = getOrder(bName);
                            
                            // First sort by type order
                            if (aOrder !== bOrder) {
                                return aOrder - bOrder;
                            }
                            
                            // Within same type, sort alphabetically by name
                            return aName.localeCompare(bName);
                        });
                        
                        // Add explicit sortOrder field to each resource to prevent Bryntum from re-sorting
                        resources = resources.map((resource, index) => ({
                            ...resource,
                            sortOrder: index + 1,  // Add explicit sort order
                            // Override the numeric ID with a string to prevent numeric sorting
                            originalId: resource.id,
                            id: `resource_${index + 1}_${resource.id}`
                        }));
                        
                        console.log('‚úÖ Resources sorted by operational sequence:');
                        resources.forEach((r, idx) => {
                            console.log(`  ${idx + 1}. ${r.name} (sortOrder: ${r.sortOrder}, id: ${r.id})`);
                        });
                    } else {
                        console.error('‚ùå Failed to fetch resources:', resourcesResponse.status);
                        // No fallback - let resources stay empty rather than showing wrong equipment
                        resources = [];
                    }
                    
                    // REMOVED: Unscheduled resource line
                    // resources.unshift({
                    //     id: 'unscheduled',
                    //     name: 'üîÑ Unscheduled Operations',
                    //     category: 'Unscheduled',
                    //     eventColor: '#808080' // Gray color for unscheduled items
                    // });
                    
                    if (operationsResponse.ok) {
                        ptOperations = await operationsResponse.json();
                        console.log('‚úÖ PT Operations fetched successfully:', ptOperations.length);
                        if (ptOperations.length > 0) {
                            console.log('‚úÖ First PT operation sample:', ptOperations[0]);
                        }
                    } else {
                        console.error('‚ùå Failed to fetch PT operations:', operationsResponse.status);
                    }
                    
                    // Process resource capabilities
                    if (capabilitiesResponse && capabilitiesResponse.ok) {
                        const capabilitiesData = await capabilitiesResponse.json();
                        console.log('‚úÖ Resource capabilities fetched successfully');
                        console.log('Capabilities data:', capabilitiesData);
                        capabilitiesData.forEach(resource => {
                            resourceCapabilities[resource.id] = resource.capabilities || [];
                            console.log(`Resource ${resource.name} (ID: ${resource.id}) has capabilities:`, resource.capabilities);
                        });
                        // Log specific resources for debugging
                        console.log('üç∫ Bright Tank 1 capabilities:', resourceCapabilities[8]);
                        console.log('üç∫ Bright Tank 2 capabilities:', resourceCapabilities[9]);
                        console.log('üç∫ Fermenter Tank 1 capabilities:', resourceCapabilities[5]);
                        console.log('üç∫ Fermenter Tank 2 capabilities:', resourceCapabilities[6]);
                        console.log('üç∫ Fermenter Tank 3 capabilities:', resourceCapabilities[7]);
                    }
                } catch (error) {
                    console.error('‚ùå Error fetching data:', error);
                    // No fallback - let resources stay empty rather than showing wrong equipment
                    resources = [];
                }

                // Map resources to create resource lookup by both ID and name
                const resourceMap = new Map();
                const resourceByName = new Map();
                const originalIdMap = new Map(); // Map original numeric IDs to new string IDs
                resources.forEach(resource => {
                    resourceMap.set(resource.id, resource);
                    resourceMap.set(resource.name, resource);
                    // Also create a name-based lookup for better matching
                    resourceByName.set(resource.name?.toLowerCase(), resource);
                    // Map original numeric ID to new string ID
                    if (resource.originalId) {
                        originalIdMap.set(resource.originalId, resource.id);
                    }
                });
                
                
                // Define capability mappings for brewing operations
                // Based on PT Resource Capabilities: 1=MILLING, 2=MASHING, 3=LAUTERING, 
                // 4=BOILING, 5=FERMENTATION, 6=CONDITIONING, 7=DRY_HOPPING, 8=PACKAGING, 9=PASTEURIZATION
                function getRequiredCapability(operationName) {
                    if (!operationName) return null;
                    const name = operationName.toLowerCase();
                    
                    // Check most specific patterns first to avoid mismatches
                    if (name.includes('packag')) return 8;
                    if (name.includes('mill')) return 1;
                    if (name.includes('mash')) return 2;
                    if (name.includes('lauter')) return 3;
                    if (name.includes('boil')) return 4;
                    if (name.includes('ferment')) return 5;
                    if (name.includes('condition')) return 6;
                    if (name.includes('dry hop')) return 7;
                    if (name.includes('pasteur')) return 9;
                    
                    return null; // No specific capability required
                }
                
                // Transform PT operations into Bryntum events format
                // CRITICAL: Load operations but DON'T use overlapping scheduled times
                let events = ptOperations.map((operation, index) => {
                    // Log job names for debugging
                    if (index < 5 || operation.jobName) {
                        console.log(`Operation ${operation.name}: Job = ${operation.jobName || 'NO JOB NAME'}`);
                    }
                    
                    // First try to find a matching resource based on capability
                    let resourceId = findResourceId(operation, resourceMap, resourceByName, resources, originalIdMap);
                    
                    // Check if operation is truly unscheduled (no valid resource assignment)
                    const isUnscheduled = !resourceId || resourceId === 'unscheduled' || !resources.find(r => r.id === resourceId && r.id !== 'unscheduled');
                    
                    let startDate;
                    
                    // Use the actual scheduled times from database (now that overlaps are fixed)
                    if (operation.scheduledStart) {
                        startDate = new Date(operation.scheduledStart);
                        console.log(`üìÖ Using DB scheduled time for ${operation.name}: ${startDate.toISOString()}`);
                    } else {
                        // Fallback: Use base date if no scheduled time exists
                        const baseDate = new Date(2025, 8, 3, 7, 0, 0); // Sept 3, 7 AM
                        startDate = new Date(baseDate.getTime() + index * 30 * 60 * 1000);
                        console.log(`‚ö†Ô∏è No scheduled time for ${operation.name}, using fallback: ${startDate.toISOString()}`);
                    }
                    
                    // If no valid resource found, assign to unscheduled resource
                    if (isUnscheduled) {
                        resourceId = 'unscheduled';
                    }
                    
                    // Calculate duration from scheduled times if available
                    let duration = 2; // Default 2 hours
                    if (operation.scheduledEnd && operation.scheduledStart) {
                        const endDate = new Date(operation.scheduledEnd);
                        const startMs = new Date(operation.scheduledStart).getTime();
                        duration = (endDate.getTime() - startMs) / (1000 * 60 * 60); // Convert to hours
                    } else if (operation.duration) {
                        duration = operation.duration / 60; // Convert minutes to hours
                    }
                    
                    return {
                        id: operation.id,
                        name: operation.name || `${operation.jobName || 'Job'}: ${operation.name || 'Operation'}`,
                        startDate: startDate,
                        duration: duration,
                        durationUnit: 'hour',
                        resourceId: resourceId,
                        percentDone: operation.percent_finished || 0,
                        eventColor: isUnscheduled ? '#808080' : (operation.eventColor || getOperationColor(operation.name)),
                        // Use actual constraint from database if available
                        constraintType: isUnscheduled ? null : (operation.constraintType || operation.constraint_type || 'startnoearlierthan'),
                        constraintDate: isUnscheduled ? null : (operation.constraintDate || operation.constraint_date || startDate),
                        manuallyScheduled: false, // Allow automatic scheduling
                        draggable: true, // Allow dragging to schedule
                        // Additional PT operation data
                        jobId: operation.jobExternalId || operation.jobId || operation.job_id, // Use jobExternalId for dependency generation
                        jobName: operation.jobName,
                        operationName: operation.name,
                        resourceName: operation.resourceName,
                        isUnscheduled: isUnscheduled,
                        ptData: operation, // Keep original PT data for algorithms
                        // Include constraint data for UI rendering
                        data: {
                            constraintType: operation.constraintType || operation.constraint_type,
                            constraintDate: operation.constraintDate || operation.constraint_date
                        }
                    };
                }).filter(event => event.resourceId); // Only include operations with valid resources
                
                // LOG IMMEDIATELY to verify code is running
                console.log('üöÄ SCHEDULER LOADED - Total events:', events.length);
                console.log('First 3 events:', events.slice(0, 3));
                console.log('Event dates range:', events.length > 0 ? {
                    first: events[0]?.startDate,
                    last: events[events.length - 1]?.startDate
                } : 'no events');
                
                // Helper function to find the correct resource ID
                function findResourceId(operation, resourceMap, resourceByName, resources, originalIdMap) {
                    // First try to match by the operation's resource_id which is the original numeric ID
                    if (operation.resourceId && originalIdMap.has(operation.resourceId)) {
                        return originalIdMap.get(operation.resourceId);
                    }
                    if (operation.resource_id && originalIdMap.has(operation.resource_id)) {
                        return originalIdMap.get(operation.resource_id);
                    }
                    
                    // Try various ways to match the resource
                    if (operation.resourceId && resourceMap.has(operation.resourceId)) {
                        return operation.resourceId;
                    }
                    if (operation.resource_id && resourceMap.has(operation.resource_id)) {
                        return operation.resource_id;
                    }
                    // Try to match by exact name
                    if (operation.resourceName) {
                        if (resourceMap.has(operation.resourceName)) {
                            return resourceMap.get(operation.resourceName).id;
                        }
                        // Try case-insensitive match
                        const lowerName = operation.resourceName.toLowerCase();
                        if (resourceByName.has(lowerName)) {
                            return resourceByName.get(lowerName).id;
                        }
                        // If resource name exists but not found in map, create a new resource entry
                        if (operation.resourceName !== 'Resource null' && operation.resourceName !== 'Unassigned') {
                            // Create a dynamic resource ID based on the name
                            const dynamicId = `resource_${operation.resourceName.replace(/\s+/g, '_').toLowerCase()}`;
                            // Add it to resources if not already there
                            if (!resourceMap.has(dynamicId)) {
                                const newResource = {
                                    id: dynamicId,
                                    name: operation.resourceName,
                                    category: 'Manufacturing'
                                };
                                resources.push(newResource);
                                resourceMap.set(dynamicId, newResource);
                                resourceMap.set(operation.resourceName, newResource);
                                resourceByName.set(operation.resourceName.toLowerCase(), newResource);
                            }
                            return dynamicId;
                        }
                    }
                    // Don't fallback to a random resource if not found - return null for unscheduled
                    return null;
                }
                
                // Helper function to assign colors based on operation type (brewing-specific)
                // CRITICAL: Order checks from most specific to least specific to avoid mismatches
                function getOperationColor(operationName) {
                    if (!operationName) return '#2563eb'; // Blue
                    const name = operationName.toLowerCase();
                    
                    // Brewing-specific operations with distinct colors
                    // Check packaging FIRST before lager to avoid "Packaging - Lager" matching lager
                    if (name.includes('packag')) return '#ea580c'; // Orange
                    if (name.includes('milling') || name.includes('mill')) return '#2563eb'; // Blue
                    if (name.includes('mash')) return '#7c3aed'; // Purple  
                    if (name.includes('lauter')) return '#0891b2'; // Cyan
                    if (name.includes('boil')) return '#dc2626'; // Red
                    if (name.includes('ferment')) return '#059669'; // Green
                    if (name.includes('lager') && !name.includes('packag')) return '#059669'; // Green (but not packaging)
                    if (name.includes('condition') || name.includes('dry hop')) return '#0d9488'; // Teal
                    if (name.includes('pasteur')) return '#7c2d12'; // Brown
                    
                    // Generic manufacturing operations
                    if (name.includes('machining')) return '#2563eb'; // Blue
                    if (name.includes('assembly')) return '#059669'; // Green
                    if (name.includes('quality') || name.includes('testing')) return '#7c3aed'; // Purple
                    if (name.includes('filtration')) return '#0d9488'; // Teal
                    if (name.includes('carbonation')) return '#eab308'; // Yellow
                    
                    return '#2563eb'; // Default blue
                }
                
                console.log(`üìä Transformed ${events.length} PT operations into Bryntum events`);
                
                // If we have no PT operations, don't create fake demo data
                if (events.length === 0) {
                    console.log('üìä No PT operations found - scheduler will be empty until operations are added');
                    // Keep events array empty - better to show an empty scheduler than wrong data
                }

                // Load dependencies from database instead of generating them
                let dependencies = [];
                try {
                    if (dependenciesResponse && dependenciesResponse.ok) {
                        const fetchedDeps = await dependenciesResponse.json();
                        dependencies = fetchedDeps.map(dep => ({
                            id: dep.id,
                            from: dep.fromEvent,  // Correct backend field name
                            to: dep.toEvent,      // Correct backend field name  
                            type: dep.type || 2, // Default to Finish-to-Start
                            lag: dep.lag || 0,
                            lagUnit: dep.lagUnit || 'hour'
                        }));
                        console.log('‚úÖ Dependencies fetched from database:', dependencies.length);
                        if (dependencies.length > 0) {
                            console.log('Sample dependency:', dependencies[0]);
                        }
                    } else {
                        console.warn('Failed to fetch dependencies, using empty array');
                    }
                } catch (depError) {
                    console.error('Error processing dependencies:', depError);
                }
                
                console.log('===== DEPENDENCY DATA FROM DATABASE =====');
                console.log('Total events:', events.length);
                console.log('Total dependencies loaded:', dependencies.length);
                
                // First, let's see what brewery operations we have
                const breweryOps = events.filter(event => {
                    const opName = (event.operationName || event.name || '').toLowerCase();
                    return opName.includes('milling') || 
                           opName.includes('mashing') || 
                           opName.includes('lautering') || 
                           opName.includes('boiling') || 
                           opName.includes('whirlpool') || 
                           opName.includes('cooling') || 
                           opName.includes('fermentation');
                });
                
                console.log(`Found ${breweryOps.length} brewery operations`);
                
                // Group by job and show what jobs we have
                const jobGroups = {};
                breweryOps.forEach(op => {
                    const jobId = op.jobId || 'NO_JOB';
                    if (!jobGroups[jobId]) {
                        jobGroups[jobId] = [];
                    }
                    jobGroups[jobId].push(op);
                });
                
                console.log('Jobs found:', Object.keys(jobGroups));
                
                // CREATE DEPENDENCIES FOR ALL JOBS WITH SUCCESSIVE OPERATIONS
                console.log('\nüîó Creating dependencies for all jobs with successive operations...');
                
                // Group ALL operations by job (not just brewery ops)
                const allJobGroups = {};
                events.forEach(op => {
                    const jobId = op.jobId || op.jobName || 'NO_JOB';
                    if (jobId !== 'NO_JOB') {
                        if (!allJobGroups[jobId]) {
                            allJobGroups[jobId] = [];
                        }
                        allJobGroups[jobId].push(op);
                    }
                });
                
                console.log(`Found ${Object.keys(allJobGroups).length} jobs total`);
                
                // Define process order for brewery operations
                const processOrder = {
                    'mill': 1,
                    'mash': 2,
                    'lauter': 3,
                    'boil': 4,
                    'kettle': 4,
                    'whirlpool': 5,
                    'cool': 6,
                    'ferment': 7,
                    'condition': 8,
                    'packag': 9,
                    'dry hop': 6.5  // Between fermentation and conditioning
                };
                
                let totalDepsCreated = 0;
                
                // Process each job
                Object.entries(allJobGroups).forEach(([jobId, jobOps]) => {
                    if (jobOps.length < 2) {
                        // Skip jobs with only one operation
                        return;
                    }
                    
                    console.log(`\n  Job ${jobId}: ${jobOps.length} operations`);
                    
                    // Try to determine process order for each operation
                    jobOps.forEach(op => {
                        const opName = (op.name || '').toLowerCase();
                        let order = 999; // Default high number for unknown operations
                        
                        // Check if it's a brewery operation
                        for (const [key, value] of Object.entries(processOrder)) {
                            if (opName.includes(key)) {
                                order = value;
                                break;
                            }
                        }
                        
                        // If not a brewery operation, try to use scheduled start time as order
                        if (order === 999 && op.startDate) {
                            order = new Date(op.startDate).getTime();
                        }
                        
                        op.processOrder = order;
                    });
                    
                    // Sort operations by process order (or by scheduled time)
                    const sortedOps = jobOps.sort((a, b) => {
                        // First try process order
                        if (a.processOrder !== b.processOrder) {
                            return a.processOrder - b.processOrder;
                        }
                        // Then try scheduled start time
                        if (a.startDate && b.startDate) {
                            return new Date(a.startDate).getTime() - new Date(b.startDate).getTime();
                        }
                        // Finally, use ID as tiebreaker
                        return a.id - b.id;
                    });
                    
                    // Create dependencies between successive operations
                    for (let i = 0; i < sortedOps.length - 1; i++) {
                        const from = sortedOps[i];
                        const to = sortedOps[i + 1];
                        
                        // Check if dependency already exists
                        const existingDep = dependencies.find(d => 
                            d.from === from.id && d.to === to.id
                        );
                        
                        if (!existingDep) {
                            const depId = `dep_job${jobId}_${i}_${from.id}_${to.id}`;
                            dependencies.push({
                                id: depId,
                                from: from.id,
                                to: to.id,
                                type: 2, // Finish-to-Start
                                lag: 0,
                                lagUnit: 'hour'
                            });
                            console.log(`    ‚úÖ ${from.name} ‚Üí ${to.name}`);
                            totalDepsCreated++;
                        }
                    }
                });
                
                console.log(`\n‚úÖ Created ${totalDepsCreated} new dependencies across all jobs`);
                
                console.log(`\n===== DEPENDENCY GENERATION END =====`);
                console.log(`TOTAL DEPENDENCIES CREATED: ${dependencies.length}`);
                if (dependencies.length > 0) {
                    console.log('Sample dependencies:', dependencies.slice(0, 3));
                }
                
                // Add some demo dependencies if we're using demo data
                if (events.length <= 3 && events[0]?.name?.includes('Demo')) {
                    dependencies.push(
                        {
                            id: 'dep1',
                            from: 1,
                            to: 2,
                            type: 2, // Finish-to-Start
                            lag: 1,
                            lagUnit: 'hour'
                        },
                        {
                            id: 'dep2',
                            from: 2,
                            to: 3,
                            type: 2, // Finish-to-Start
                            lag: 0,
                            lagUnit: 'hour'
                        }
                    );
                }
                
                console.log(`üîó Created ${dependencies.length} dependencies between operations`);
                
                // Log first few dependencies for debugging
                if (dependencies.length > 0) {
                    console.log('Sample dependencies:', dependencies.slice(0, 5));
                    
                    // Verify that the event IDs in dependencies match actual events
                    const eventIds = new Set(events.map(e => e.id));
                    let missingFrom = 0;
                    let missingTo = 0;
                    dependencies.forEach(dep => {
                        if (!eventIds.has(dep.from)) {
                            console.warn(`Dependency ${dep.id} has invalid 'from' ID: ${dep.from}`);
                            missingFrom++;
                        }
                        if (!eventIds.has(dep.to)) {
                            console.warn(`Dependency ${dep.id} has invalid 'to' ID: ${dep.to}`);
                            missingTo++;
                        }
                    });
                    if (missingFrom > 0 || missingTo > 0) {
                        console.error(`‚ö†Ô∏è Found ${missingFrom} invalid 'from' IDs and ${missingTo} invalid 'to' IDs in dependencies!`);
                        console.log('Available event IDs:', Array.from(eventIds).slice(0, 20));
                    }
                }

                // Detect mobile device
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                const isTablet = window.innerWidth > 768 && window.innerWidth <= 1024;
                
                // Choose appropriate view preset based on device
                let viewPreset = 'dayAndWeek';
                let resourceColumnWidth = 200;
                let categoryColumnWidth = 150;
                
                if (isMobile) {
                    viewPreset = 'weekAndDay';  // Wider view for mobile
                    resourceColumnWidth = 120;
                    categoryColumnWidth = 0; // Hide category on mobile
                } else if (isTablet) {
                    viewPreset = 'weekAndDay';
                    resourceColumnWidth = 150;
                    categoryColumnWidth = 100;
                }
                
                // Configure columns based on device
                const schedulerColumns = [
                    { text: 'Resource', field: 'name', width: resourceColumnWidth, locked: isMobile }
                ];
                
                // Category column removed as per requirement
                
                // Create scheduler instance with proper Bryntum project engine configuration
                // Make scheduler globally accessible for Max AI
                window.scheduler = new SchedulerPro({
                    appendTo: 'scheduler',
                    
                    columns: schedulerColumns,

                    viewPreset: viewPreset,
                    rowHeight: 45,  // Consistent row height for all rows
                    barMargin: 5,    // Consistent bar margin
                    
                    // Enable horizontal scrolling on mobile
                    scrollable: isMobile ? { overflowX: 'auto', overflowY: 'auto' } : true,
                    
                    // Zoom level for better mobile view
                    zoomLevel: isMobile ? 0 : 5,
                    zoomOnMouseWheel: !isMobile,
                    
                    // Enable pinch zoom on mobile
                    pinchZoom: isMobile,
                    
                    // Listen for the paint event to trigger zoom-to-fit on first render
                    listeners: {
                        paint: ({ source, firstPaint }) => {
                            if (firstPaint && source.eventStore.count > 0) {
                                // Apply zoom-to-fit on first paint when events are loaded
                                setTimeout(() => {
                                    source.zoomToFit({
                                        leftMargin: 50,
                                        rightMargin: 50
                                    });
                                    console.log('‚úÖ Auto zoom-to-fit applied on first paint');
                                }, 200); // Small delay to ensure everything is rendered
                            }
                        },
                        
                        // Auto-save when event is dropped (moved)
                        afterEventDrop: async ({ eventRecords }) => {
                            console.log('üíæ Event dropped, auto-saving changes...');
                            
                            // Mark manually positioned events to preserve them from algorithm changes
                            eventRecords.forEach(event => {
                                event.manuallyScheduled = true;
                                console.log(`üîí Marked ${event.name} as manually scheduled - will be preserved from algorithms`);
                            });
                            
                            await saveOperationChanges(eventRecords);
                        },
                        
                        // Auto-save when event is resized
                        afterEventResize: async ({ eventRecord }) => {
                            console.log('üíæ Event resized, auto-saving changes...');
                            await saveOperationChanges([eventRecord]);
                        }
                    },
                    
                    // CRITICAL: Prevent overlapping events on same resource
                    allowOverlap: false,
                    
                    // Event layout to handle overlaps - 'stack' prevents visual overlaps
                    eventLayout: 'stack',  // 'stack' | 'pack' | 'none' - stack shows overlaps clearly
                    
                    // Sort overlapping events by startDate first (REQUIRED for predictable results)
                    overlappingEventSorter: (a, b) => {
                        // CRITICAL: Must sort by startDate first per Bryntum docs
                        if (a.startDate - b.startDate !== 0) {
                            return a.startDate - b.startDate;
                        }
                        // Then by duration (shorter events on top)
                        if (a.duration - b.duration !== 0) {
                            return a.duration - b.duration;
                        }
                        // Finally by name for consistency
                        return a.name.localeCompare(b.name);
                    },
                    
                    // Disable state persistence to avoid localStorage errors
                    stateId: null,
                    
                    // Disable sync storage to prevent errors
                    syncDataOnLoad: false,

                    // Proper Bryntum Project configuration using the scheduling engine
                    project: {
                        autoLoad: false,
                        autoSync: false,
                        silenceInitialCommit: true, // Prevent initial save attempts
                        
                        // Enable the scheduling engine's automatic calculations
                        autoCalculatePercentDone: true,
                        
                        // Define project calendar with working hours
                        calendar: {
                            intervals: [
                                {
                                    recurrentStartDate: 'on Mon-Fri at 07:00',
                                    recurrentEndDate: 'on Mon-Fri at 17:00',
                                    isWorking: true
                                }
                            ]
                        },
                        
                        // Load inline data - properly structured
                        resourceStore: {
                            data: resources
                        },
                        eventStore: {
                            data: events
                        },
                        dependencyStore: {
                            data: dependencies
                        },
                        
                        // Enable automatic date calculations by the engine
                        autoCalculateStartDate: true,
                        autoCalculateEndDate: true
                    },

                    features: {
                        // Dependencies feature for showing task relationships
                        dependencies: true,
                        
                        // Context menu for events
                        eventMenu: {
                            items: {
                                setConstraint: {
                                    text: 'Set Constraint',
                                    icon: 'b-fa b-fa-link',
                                    onItem: ({ eventRecord }) => {
                                        window.openConstraintDialog(eventRecord.id, eventRecord.name);
                                    }
                                },
                                removeConstraint: {
                                    text: 'Remove Constraint',
                                    icon: 'b-fa b-fa-unlink',
                                    onItem: ({ eventRecord }) => {
                                        window.currentOperationId = eventRecord.id;
                                        if (confirm('Are you sure you want to remove the constraint?')) {
                                            // Set constraint type to None
                                            fetch(`/api/operations/${eventRecord.id}/constraint`, {
                                                method: 'PUT',
                                                headers: {
                                                    'Content-Type': 'application/json'
                                                },
                                                body: JSON.stringify({
                                                    constraintType: 'None',
                                                    constraintDate: null
                                                })
                                            }).then(response => response.json())
                                              .then(result => {
                                                if (result.success) {
                                                    eventRecord.data.constraintType = null;
                                                    eventRecord.data.constraintDate = null;
                                                    eventRecord.cls = eventRecord.cls ? eventRecord.cls.replace(/constraint-\w+/g, '') : '';
                                                    window.scheduler.refresh();
                                                    window.showNotification('Constraint removed successfully', 'success');
                                                }
                                            }).catch(error => {
                                                console.error('Error removing constraint:', error);
                                                alert('Failed to remove constraint');
                                            });
                                        }
                                    }
                                }
                            }
                        },
                        
                        // Event drag feature with validation to prevent incompatible resource assignments
                        eventDrag: {
                            showTooltip: true,
                            constrainDragToResource: false, // Allow dragging between resources
                            // Validation function to check if an operation can be dropped on a resource
                            validatorFn: (context) => {
                                const { eventRecord, newResource } = context;
                                
                                // Helper function to extract operation type from operation name
                                function getOperationType(operationName) {
                                    if (!operationName) return null;
                                    const name = operationName.toLowerCase();
                                    
                                    // Map operation keywords to types
                                    if (name.includes('milling')) return 'milling';
                                    if (name.includes('mashing')) return 'mashing';
                                    if (name.includes('lautering')) return 'lautering';
                                    if (name.includes('boiling')) return 'boiling';
                                    if (name.includes('fermentation')) return 'fermentation';
                                    if (name.includes('conditioning')) return 'conditioning';
                                    if (name.includes('dry hopping') || name.includes('dry-hopping')) return 'dry_hopping';
                                    if (name.includes('packaging')) return 'packaging';
                                    if (name.includes('pasteurization')) return 'pasteurization';
                                    
                                    return null;
                                }

                                // Helper function to check if a resource can handle an operation type
                                function canResourceHandleOperation(resourceName, operationType) {
                                    if (!resourceName || !operationType) return false;
                                    
                                    const resourceNameLower = resourceName.toLowerCase();
                                    
                                    // Define operation-to-resource compatibility mapping
                                    const compatibility = {
                                        'milling': ['grain mill'],
                                        'mashing': ['mash tun'],
                                        'lautering': ['lauter tun'],
                                        'boiling': ['brew kettle'],
                                        'fermentation': ['fermenter tank'],
                                        'conditioning': ['bright tank'],
                                        'dry_hopping': ['bright tank'],
                                        'packaging': ['filler line', 'bottle filler', 'can filler'],
                                        'pasteurization': ['pasteurizer']
                                    };
                                    
                                    const allowedResources = compatibility[operationType];
                                    if (!allowedResources) return true; // If no specific mapping, allow
                                    
                                    // Check if the resource name matches any of the allowed resources
                                    return allowedResources.some(allowed => 
                                        resourceNameLower.includes(allowed.toLowerCase())
                                    );
                                }
                                
                                const operationName = eventRecord.name || '';
                                const operationType = getOperationType(operationName);
                                const resourceName = newResource ? newResource.name : '';
                                
                                // Check if the operation can be assigned to the new resource
                                const isValid = canResourceHandleOperation(resourceName, operationType);
                                
                                if (!isValid) {
                                    console.warn(`‚ö†Ô∏è Cannot assign ${operationName} to ${resourceName} - incompatible resource type`);
                                    // Toast notification removed - drag box message is sufficient
                                    return {
                                        valid: false,
                                        message: `${operationName} cannot be assigned to ${resourceName}`
                                    };
                                }
                                
                                return { valid: true };
                            }
                        },
                        
                        // PercentBar feature - visualize progress on operations
                        percentBar: {
                            disabled: false, // Enable the feature
                            showPercentage: true, // Show percentage text
                            allowResize: true // Allow dragging to change percentage
                        },
                        
                        // ResourceNonWorkingTime feature - highlight non-working intervals
                        resourceNonWorkingTime: {
                            disabled: false // Enable the feature to show non-working time for resources
                        },
                        
                        // Versions feature - capture and manage project snapshots
                        versions: {
                            disabled: false, // Enable the versions feature
                            showTooltip: true, // Show tooltips for version actions
                            autoCreate: false, // We'll manually control when versions are created
                            saveVersion: (version) => {
                                // Store version data (in production, this would go to backend)
                                const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                                versions.push({
                                    ...version,
                                    id: version.id || `v${Date.now()}`,
                                    name: version.name || `Version ${versions.length + 1}`,
                                    timestamp: new Date().toISOString(),
                                    description: version.description || 'Manual snapshot',
                                    data: version.data
                                });
                                localStorage.setItem('schedulerVersions', JSON.stringify(versions));
                                console.log('‚úÖ Version saved:', version.name);
                                showNotification(`Version "${version.name}" saved successfully`, 'success');
                                return Promise.resolve(version);
                            },
                            loadVersion: (versionId) => {
                                // Load version data
                                const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                                const version = versions.find(v => v.id === versionId);
                                if (version) {
                                    console.log('‚úÖ Loading version:', version.name);
                                    return Promise.resolve(version.data);
                                }
                                return Promise.reject('Version not found');
                            },
                            getVersions: () => {
                                // Get all saved versions
                                const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                                return Promise.resolve(versions.map(v => ({
                                    id: v.id,
                                    name: v.name,
                                    timestamp: v.timestamp,
                                    description: v.description
                                })));
                            }
                        },
                        
                        // Event edit dialog feature
                        eventEdit: {
                            // Show edit dialog on double-click
                            disabled: false,
                            listeners: {
                                // Auto-save when user saves via edit dialog
                                afterEventSave: async ({ eventRecord }) => {
                                    console.log('üíæ Event edited via dialog, auto-saving changes...');
                                    await saveOperationChanges([eventRecord]);
                                }
                            }
                        },
                        
                        // Enable resize with overlap validation
                        eventResize: {
                            showTooltip: true,
                            // CRITICAL: Use Bryntum's isDateRangeAvailable to prevent overlaps
                            validatorFn({ eventRecord, startDate, endDate }) {
                                const resource = eventRecord.resource;
                                
                                // Use Bryntum's built-in overlap detection
                                const isAvailable = window.scheduler.eventStore.isDateRangeAvailable(
                                    startDate,
                                    endDate,
                                    eventRecord,  // Exclude the resized event itself
                                    resource      // Check for this specific resource
                                );
                                
                                if (!isAvailable) {
                                    console.warn(`‚ö†Ô∏è Cannot resize ${eventRecord.name}: Time slot occupied`);
                                    
                                    // Find the conflicting event for better error message
                                    const resourceEvents = window.scheduler.eventStore.query(event => 
                                        event.resourceId === eventRecord.resourceId && 
                                        event.id !== eventRecord.id &&
                                        event.startDate < endDate && 
                                        event.endDate > startDate
                                    );
                                    
                                    const conflictingEvent = resourceEvents[0];
                                    if (conflictingEvent) {
                                        const conflictStart = conflictingEvent.startDate.toLocaleString('en-US', { 
                                            month: 'short', 
                                            day: 'numeric', 
                                            hour: 'numeric', 
                                            minute: '2-digit' 
                                        });
                                        const conflictEnd = conflictingEvent.endDate.toLocaleString('en-US', { 
                                            month: 'short', 
                                            day: 'numeric', 
                                            hour: 'numeric', 
                                            minute: '2-digit' 
                                        });
                                        return {
                                            valid: false,
                                            message: `Cannot resize: ${conflictingEvent.name} runs from ${conflictStart} to ${conflictEnd}`
                                        };
                                    }
                                    return {
                                        valid: false,
                                        message: `Time slot is already occupied on this resource`
                                    };
                                }
                                return { valid: true }; // Valid resize
                            }
                        },
                        
                        // Enhanced event tooltips with CPM metrics
                        eventTooltip: {
                            template: ({ eventRecord }) => {
                                // Extract job name/batch from the event data
                                const jobInfo = eventRecord.jobName || eventRecord.data?.jobName || '';
                                const jobDisplay = jobInfo ? `<strong style="color: #0066cc;">Job: ${jobInfo}</strong><br>` : '';
                                
                                // Check if CPM data is available
                                const hasCPMData = eventRecord.cpmData && typeof eventRecord.cpmData.totalSlack !== 'undefined';
                                
                                // Check if PERT data is available
                                const hasPertData = window.pertEstimates && window.pertEstimates[eventRecord.id];
                                
                                let cpmSection = '';
                                if (hasCPMData) {
                                    const cpm = eventRecord.cpmData;
                                    const criticalStyle = cpm.isCritical ? 'color: #dc2626; font-weight: bold;' : 
                                                         cpm.isNearCritical ? 'color: #f59e0b; font-weight: bold;' : 
                                                         'color: #10b981;';
                                    
                                    cpmSection = `
                                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
                                            <strong style="color: #333;">CPM Analysis</strong>
                                            <div style="margin-top: 5px; font-size: 0.85em; line-height: 1.6;">
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Early Start:</span>
                                                    <span style="font-weight: 600;">${cpm.earlyStart.toFixed(1)}h</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Early Finish:</span>
                                                    <span style="font-weight: 600;">${cpm.earlyFinish.toFixed(1)}h</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Late Start:</span>
                                                    <span style="font-weight: 600;">${cpm.lateStart === Infinity ? 'N/A' : cpm.lateStart.toFixed(1) + 'h'}</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Late Finish:</span>
                                                    <span style="font-weight: 600;">${cpm.lateFinish === Infinity ? 'N/A' : cpm.lateFinish.toFixed(1) + 'h'}</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; margin-top: 5px; padding-top: 5px; border-top: 1px solid #eee;">
                                                    <span style="color: #333; font-weight: bold;">Total Slack:</span>
                                                    <span style="${criticalStyle}">
                                                        ${cpm.totalSlack === Infinity ? 'N/A' : cpm.totalSlack.toFixed(1) + 'h'}
                                                    </span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #333; font-weight: bold;">Free Slack:</span>
                                                    <span style="${criticalStyle}">
                                                        ${cpm.freeSlack === Infinity ? 'N/A' : cpm.freeSlack.toFixed(1) + 'h'}
                                                    </span>
                                                </div>
                                                <div style="margin-top: 8px; padding: 5px; background: ${cpm.isCritical ? 'rgba(220, 38, 38, 0.1)' : cpm.isNearCritical ? 'rgba(245, 158, 11, 0.1)' : 'rgba(16, 185, 129, 0.1)'}; border-radius: 4px; text-align: center;">
                                                    ${cpm.isCritical ? 
                                                        '<span style="color: #dc2626; font-weight: bold;">üî¥ CRITICAL PATH</span>' : 
                                                      cpm.isNearCritical ? 
                                                        '<span style="color: #f59e0b; font-weight: bold;">‚ö†Ô∏è Near Critical</span>' : 
                                                        '<span style="color: #10b981;">‚úÖ Has Slack</span>'}
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }
                                
                                // Add PERT section if data exists
                                let pertSection = '';
                                if (hasPertData) {
                                    const pert = window.pertEstimates[eventRecord.id];
                                    const uncertaintyLevel = pert.cv < 10 ? 'Low' : pert.cv < 20 ? 'Medium' : 'High';
                                    const uncertaintyColor = pert.cv < 10 ? '#10b981' : pert.cv < 20 ? '#f59e0b' : '#dc2626';
                                    
                                    pertSection = `
                                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
                                            <strong style="color: #333;">üìä PERT Estimates</strong>
                                            <div style="font-size: 0.85em; margin-top: 5px; line-height: 1.6;">
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Optimistic:</span>
                                                    <span style="font-weight: 600;">${pert.optimistic.toFixed(1)}h</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Most Likely:</span>
                                                    <span style="font-weight: 600;">${pert.mostLikely.toFixed(1)}h</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Pessimistic:</span>
                                                    <span style="font-weight: 600;">${pert.pessimistic.toFixed(1)}h</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; margin-top: 5px; padding-top: 5px; border-top: 1px solid #eee;">
                                                    <span style="color: #2563eb; font-weight: bold;">Expected:</span>
                                                    <span style="color: #2563eb; font-weight: bold;">${pert.expectedTime.toFixed(1)}h</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Std Deviation:</span>
                                                    <span style="font-weight: 600;">¬±${pert.stdDev.toFixed(2)}h</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span style="color: #666;">Range:</span>
                                                    <span style="font-weight: 600;">${pert.optimistic.toFixed(1)}-${pert.pessimistic.toFixed(1)}h</span>
                                                </div>
                                                <div style="margin-top: 8px; padding: 5px; background: ${uncertaintyColor === '#10b981' ? 'rgba(16, 185, 129, 0.1)' : uncertaintyColor === '#f59e0b' ? 'rgba(245, 158, 11, 0.1)' : 'rgba(220, 38, 38, 0.1)'}; border-radius: 4px; text-align: center;">
                                                    <span style="color: ${uncertaintyColor}; font-weight: bold;">
                                                        Uncertainty: ${uncertaintyLevel} (CV: ${pert.cv.toFixed(1)}%)
                                                    </span>
                                                </div>
                                            </div>
                                        </div>`;
                                }
                                
                                return `
                                    <div style="padding: 10px; min-width: 250px; max-width: 350px;">
                                        ${jobDisplay}
                                        <strong>${eventRecord.name}</strong><br>
                                        <div style="margin-top: 5px; font-size: 0.9em;">
                                            Start: ${eventRecord.startDate.toLocaleString()}<br>
                                            End: ${eventRecord.endDate.toLocaleString()}<br>
                                            Duration: ${eventRecord.duration} ${eventRecord.durationUnit}<br>
                                            Progress: ${eventRecord.percentDone}%
                                        </div>
                                        ${eventRecord.isUnscheduled ? '<br><span style="color: orange; font-weight: bold;">‚ö†Ô∏è Unscheduled - Drag to a resource to schedule</span>' : ''}
                                        ${cpmSection}
                                        ${pertSection}
                                    </div>
                                `;
                            }
                        },
                        
                        // Show current time line
                        timeRanges: {
                            showCurrentTimeLine: true
                        },
                        
                        // TimeSpanHighlight feature - Highlight important time periods
                        timeSpanHighlight: {
                            disabled: false,  // Enable the feature
                            store: {
                                // Configure multiple time span highlights for different purposes
                                data: [
                                    // Maintenance Windows - Weekly maintenance periods
                                    {
                                        id: 'maintenance1',
                                        startDate: new Date(2025, 8, 6, 6, 0), // Sept 6, 6:00 AM
                                        endDate: new Date(2025, 8, 6, 10, 0),   // Sept 6, 10:00 AM
                                        name: 'Equipment Maintenance',
                                        cls: 'maintenance-window',
                                        style: 'background-color: rgba(255, 152, 0, 0.2); border-left: 3px solid #ff9800;'
                                    },
                                    {
                                        id: 'maintenance2',
                                        startDate: new Date(2025, 8, 13, 6, 0), // Sept 13, 6:00 AM
                                        endDate: new Date(2025, 8, 13, 10, 0),  // Sept 13, 10:00 AM
                                        name: 'Scheduled Maintenance',
                                        cls: 'maintenance-window',
                                        style: 'background-color: rgba(255, 152, 0, 0.2); border-left: 3px solid #ff9800;'
                                    },
                                    {
                                        id: 'maintenance3',
                                        startDate: new Date(2025, 8, 20, 6, 0), // Sept 20, 6:00 AM
                                        endDate: new Date(2025, 8, 20, 10, 0),  // Sept 20, 10:00 AM
                                        name: 'Preventive Maintenance',
                                        cls: 'maintenance-window',
                                        style: 'background-color: rgba(255, 152, 0, 0.2); border-left: 3px solid #ff9800;'
                                    },
                                    
                                    // Shift Changes - Daily shift transitions
                                    {
                                        id: 'shift1',
                                        startDate: new Date(2025, 8, 3, 7, 0),  // Sept 3, 7:00 AM
                                        endDate: new Date(2025, 8, 3, 7, 30),   // Sept 3, 7:30 AM
                                        name: 'Morning Shift Start',
                                        cls: 'shift-change',
                                        style: 'background-color: rgba(33, 150, 243, 0.15); border-left: 3px solid #2196f3;'
                                    },
                                    {
                                        id: 'shift2',
                                        startDate: new Date(2025, 8, 3, 15, 0), // Sept 3, 3:00 PM
                                        endDate: new Date(2025, 8, 3, 15, 30),  // Sept 3, 3:30 PM
                                        name: 'Afternoon Shift Start',
                                        cls: 'shift-change',
                                        style: 'background-color: rgba(33, 150, 243, 0.15); border-left: 3px solid #2196f3;'
                                    },
                                    {
                                        id: 'shift3',
                                        startDate: new Date(2025, 8, 3, 23, 0), // Sept 3, 11:00 PM
                                        endDate: new Date(2025, 8, 3, 23, 30),  // Sept 3, 11:30 PM
                                        name: 'Night Shift Start',
                                        cls: 'shift-change',
                                        style: 'background-color: rgba(33, 150, 243, 0.15); border-left: 3px solid #2196f3;'
                                    },
                                    
                                    // Important Deadlines
                                    {
                                        id: 'deadline1',
                                        startDate: new Date(2025, 8, 10, 17, 0), // Sept 10, 5:00 PM
                                        endDate: new Date(2025, 8, 10, 23, 59),   // Sept 10, 11:59 PM
                                        name: 'Priority Order Deadline',
                                        cls: 'deadline-window',
                                        style: 'background-color: rgba(244, 67, 54, 0.15); border-left: 4px solid #f44336;'
                                    },
                                    {
                                        id: 'deadline2',
                                        startDate: new Date(2025, 8, 15, 17, 0), // Sept 15, 5:00 PM
                                        endDate: new Date(2025, 8, 15, 23, 59),   // Sept 15, 11:59 PM
                                        name: 'Customer Delivery Deadline',
                                        cls: 'deadline-window',
                                        style: 'background-color: rgba(244, 67, 54, 0.15); border-left: 4px solid #f44336;'
                                    },
                                    {
                                        id: 'deadline3',
                                        startDate: new Date(2025, 8, 25, 17, 0), // Sept 25, 5:00 PM
                                        endDate: new Date(2025, 8, 25, 23, 59),   // Sept 25, 11:59 PM
                                        name: 'Month-End Production Target',
                                        cls: 'deadline-window',
                                        style: 'background-color: rgba(244, 67, 54, 0.15); border-left: 4px solid #f44336;'
                                    },
                                    
                                    // Peak Production Periods
                                    {
                                        id: 'peak1',
                                        startDate: new Date(2025, 8, 8, 8, 0),   // Sept 8, 8:00 AM
                                        endDate: new Date(2025, 8, 8, 17, 0),    // Sept 8, 5:00 PM
                                        name: 'Peak Production Period',
                                        cls: 'peak-period',
                                        style: 'background-color: rgba(76, 175, 80, 0.1); border-left: 3px solid #4caf50;'
                                    },
                                    {
                                        id: 'peak2',
                                        startDate: new Date(2025, 8, 16, 8, 0),  // Sept 16, 8:00 AM
                                        endDate: new Date(2025, 8, 16, 17, 0),   // Sept 16, 5:00 PM
                                        name: 'High Demand Period',
                                        cls: 'peak-period',
                                        style: 'background-color: rgba(76, 175, 80, 0.1); border-left: 3px solid #4caf50;'
                                    },
                                    
                                    // Quality Control Windows
                                    {
                                        id: 'qc1',
                                        startDate: new Date(2025, 8, 5, 14, 0),  // Sept 5, 2:00 PM
                                        endDate: new Date(2025, 8, 5, 16, 0),    // Sept 5, 4:00 PM
                                        name: 'Quality Inspection',
                                        cls: 'qc-window',
                                        style: 'background-color: rgba(156, 39, 176, 0.1); border-left: 3px solid #9c27b0;'
                                    },
                                    {
                                        id: 'qc2',
                                        startDate: new Date(2025, 8, 12, 14, 0), // Sept 12, 2:00 PM
                                        endDate: new Date(2025, 8, 12, 16, 0),   // Sept 12, 4:00 PM
                                        name: 'Quality Audit',
                                        cls: 'qc-window',
                                        style: 'background-color: rgba(156, 39, 176, 0.1); border-left: 3px solid #9c27b0;'
                                    },
                                    
                                    // Training Sessions
                                    {
                                        id: 'training1',
                                        startDate: new Date(2025, 8, 9, 9, 0),   // Sept 9, 9:00 AM
                                        endDate: new Date(2025, 8, 9, 12, 0),    // Sept 9, 12:00 PM
                                        name: 'Staff Training Session',
                                        cls: 'training-window',
                                        style: 'background-color: rgba(0, 188, 212, 0.1); border-left: 3px solid #00bcd4;'
                                    },
                                    {
                                        id: 'training2',
                                        startDate: new Date(2025, 8, 23, 9, 0),  // Sept 23, 9:00 AM
                                        endDate: new Date(2025, 8, 23, 12, 0),   // Sept 23, 12:00 PM
                                        name: 'Safety Training',
                                        cls: 'training-window',
                                        style: 'background-color: rgba(0, 188, 212, 0.1); border-left: 3px solid #00bcd4;'
                                    }
                                ]
                            },
                            // Tooltip configuration for time span highlights
                            tooltipTemplate: ({ timeSpanRecord }) => {
                                let tooltip = `<b>${timeSpanRecord.name}</b><br/>`;
                                const start = new Date(timeSpanRecord.startDate);
                                const end = new Date(timeSpanRecord.endDate);
                                tooltip += `${start.toLocaleDateString()} ${start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                                tooltip += ` - ${end.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                                
                                // Add description based on type
                                if (timeSpanRecord.cls === 'maintenance-window') {
                                    tooltip += '<br/><em>Equipment unavailable during this period</em>';
                                } else if (timeSpanRecord.cls === 'shift-change') {
                                    tooltip += '<br/><em>Shift transition period</em>';
                                } else if (timeSpanRecord.cls === 'deadline-window') {
                                    tooltip += '<br/><em>Critical deadline - must complete by this time</em>';
                                } else if (timeSpanRecord.cls === 'peak-period') {
                                    tooltip += '<br/><em>High production volume expected</em>';
                                } else if (timeSpanRecord.cls === 'qc-window') {
                                    tooltip += '<br/><em>Quality control inspection required</em>';
                                } else if (timeSpanRecord.cls === 'training-window') {
                                    tooltip += '<br/><em>Limited staff availability</em>';
                                }
                                
                                return tooltip;
                            }
                        },
                        
                        // Progress line feature - shows percentage complete
                        percentBar: true,
                        
                        // Non-working time visualization
                        nonWorkingTime: true,
                        
                        // Critical paths feature
                        criticalPaths: false,
                        
                        // Event menu on right-click
                        eventMenu: true,
                        
                        // Schedule menu on right-click
                        scheduleMenu: true,
                        
                        // TaskEdit feature - Double-click to edit operations
                        taskEdit: {
                            // Enable the feature (it's enabled by default, but let's be explicit)
                            disabled: false,
                            
                            // Trigger on double-click (default behavior)
                            triggerEvent: 'eventdblclick',
                            
                            // Configure the editor fields
                            items: {
                                // General tab configuration
                                generalTab: {
                                    items: {
                                        // Operation name field
                                        nameField: {
                                            type: 'text',
                                            name: 'name',
                                            label: 'Operation Name',
                                            required: true,
                                            weight: 100
                                        },
                                        
                                        // Resource assignment field
                                        resourceField: {
                                            type: 'resourcecombo',
                                            name: 'resource',
                                            label: 'Assigned Resource',
                                            required: true,
                                            weight: 200
                                        },
                                        
                                        // Start date field
                                        startDateField: {
                                            type: 'startdatefield',
                                            name: 'startDate',
                                            label: 'Start Date',
                                            required: true,
                                            weight: 300
                                        },
                                        
                                        // End date field
                                        endDateField: {
                                            type: 'enddatefield',
                                            name: 'endDate',
                                            label: 'End Date',
                                            required: true,
                                            weight: 400
                                        },
                                        
                                        // Duration field
                                        durationField: {
                                            type: 'duration',
                                            name: 'duration',
                                            label: 'Duration',
                                            weight: 500
                                        },
                                        
                                        // Progress percentage field
                                        percentDoneField: {
                                            type: 'number',
                                            name: 'percentDone',
                                            label: 'Progress %',
                                            min: 0,
                                            max: 100,
                                            step: 5,
                                            weight: 600
                                        },
                                        
                                        // Effort field (if needed)
                                        effortField: {
                                            type: 'effort',
                                            name: 'effort',
                                            label: 'Effort (hours)',
                                            weight: 700
                                        },
                                        
                                        // Constraint type field
                                        constraintTypeField: {
                                            type: 'constrainttypefield',
                                            name: 'constraintType',
                                            label: 'Constraint Type',
                                            weight: 800
                                        },
                                        
                                        // Constraint date field
                                        constraintDateField: {
                                            type: 'constraintdatefield',
                                            name: 'constraintDate',
                                            label: 'Constraint Date',
                                            weight: 900
                                        }
                                    }
                                },
                                
                                // Notes tab for additional information
                                notesTab: {
                                    items: {
                                        notesField: {
                                            type: 'textarea',
                                            name: 'note',
                                            label: 'Notes',
                                            height: 200,
                                            weight: 100
                                        }
                                    }
                                },
                                
                                // Predecessors tab to manage dependencies
                                predecessorsTab: {
                                    // Show the predecessors grid for managing dependencies
                                    disabled: false
                                },
                                
                                // Successors tab to see dependent tasks
                                successorsTab: {
                                    // Show the successors grid for viewing dependent tasks
                                    disabled: false
                                },
                                
                                // Advanced tab for additional settings
                                advancedTab: {
                                    items: {
                                        // Event color field
                                        eventColorField: {
                                            type: 'combo',
                                            name: 'eventColor',
                                            label: 'Color',
                                            items: [
                                                { value: 'green', text: 'Green' },
                                                { value: 'blue', text: 'Blue' },
                                                { value: 'red', text: 'Red' },
                                                { value: 'orange', text: 'Orange' },
                                                { value: 'purple', text: 'Purple' },
                                                { value: 'yellow', text: 'Yellow' },
                                                { value: 'cyan', text: 'Cyan' },
                                                { value: 'gray', text: 'Gray' }
                                            ],
                                            weight: 100
                                        },
                                        
                                        // Manual scheduling mode field
                                        manuallyScheduledField: {
                                            type: 'checkbox',
                                            name: 'manuallyScheduled',
                                            label: 'Manually scheduled',
                                            weight: 200
                                        },
                                        
                                        // Inactive field
                                        inactiveField: {
                                            type: 'checkbox',
                                            name: 'inactive',
                                            label: 'Inactive',
                                            weight: 300
                                        }
                                    }
                                }
                            },
                            
                            // Customize the editor title
                            editorConfig: {
                                title: 'Edit Operation',
                                // Make the editor wider for better visibility
                                width: '600px',
                                // Center the editor on screen
                                centered: true,
                                // Show close button
                                closable: true,
                                // Allow the editor to be dragged
                                draggable: true
                            },
                            
                            // Before showing the editor
                            beforeShow: ({ taskRecord, editor }) => {
                                // Customize the title based on the operation
                                editor.title = `Edit Operation: ${taskRecord.name}`;
                                console.log('Opening task editor for:', taskRecord.name);
                                return true; // Allow showing the editor
                            },
                            
                            // After save
                            afterSave: ({ taskRecord, editor }) => {
                                console.log('Task saved:', taskRecord.name);
                                // Could add notification here
                                showNotification('Operation updated successfully', 'success');
                            },
                            
                            // Validate before saving
                            beforeSave: ({ taskRecord, editor }) => {
                                // Validation logic if needed
                                if (!taskRecord.name || taskRecord.name.trim() === '') {
                                    showNotification('Operation name is required', 'error');
                                    return false;
                                }
                                return true; // Allow saving
                            }
                        }
                    },

                    eventRenderer({ eventRecord, renderData }) {
                        renderData.eventColor = eventRecord.eventColor;
                        
                        // Add constraint class to event if present
                        if (eventRecord.data && eventRecord.data.constraintType) {
                            const constraintType = eventRecord.data.constraintType.toLowerCase();
                            eventRecord.cls = (eventRecord.cls || '') + ' constraint-' + constraintType;
                        }
                        
                        // Create constraint badge HTML
                        let constraintBadge = '';
                        if (eventRecord.data && eventRecord.data.constraintType && eventRecord.data.constraintType !== 'None') {
                            const constraintType = eventRecord.data.constraintType.toLowerCase();
                            constraintBadge = `<div class="constraint-badge ${constraintType}">${eventRecord.data.constraintType}</div>`;
                        }
                        
                        return {
                            html: `
                                <div style="padding: 4px; position: relative;">
                                    ${constraintBadge}
                                    <div style="font-weight: 500; font-size: 12px;">${eventRecord.name}</div>
                                    <div style="font-size: 11px; opacity: 0.8;">
                                        ${eventRecord.percentDone}% complete
                                    </div>
                                </div>
                            `
                        };
                    },

                    startDate: (() => {
                        // Start from 2 weeks before today to show recent context
                        const start = new Date();
                        start.setDate(start.getDate() - 14); // Go back 2 weeks
                        start.setHours(0, 0, 0, 0);
                        return start;
                    })(),
                    endDate: (() => {
                        // Show 6 weeks from today to ensure all operations are visible
                        const end = new Date();
                        end.setDate(end.getDate() + 42); // Go forward 6 weeks
                        end.setHours(23, 59, 59, 999);
                        return end;
                    })(),
                    // Enable infinite scrolling for better navigation
                    infiniteScroll: true,
                    zoomLevel: 10
                });

                // Setup toolbar handlers
                const scheduler = window.scheduler;
                
                // Add PostMessage listener for AI agent algorithm execution
                window.addEventListener('message', async (event) => {
                    // Log the incoming message for debugging
                    console.log('üìÆ Received PostMessage:', event.data);
                    
                    // Check if this is an algorithm application message
                    if (event.data && event.data.type === 'applyAlgorithm') {
                        const { algorithm, direction } = event.data;
                        
                        console.log(`üéØ Applying algorithm: ${algorithm} (direction: ${direction})`);
                        
                        try {
                            // Apply the appropriate algorithm based on the message
                            if (direction === 'Forward' || algorithm.includes('ASAP')) {
                                // ‚úÖ CORRECTED ASAP algorithm with valid Bryntum constraints
                                console.log('‚è© Applying ASAP (Forward) scheduling');
                                
                                // Set project to forward scheduling
                                scheduler.project.direction = 'Forward';
                                scheduler.project.startDate = new Date(2025, 8, 3, 7, 0, 0);
                                
                                const events = scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                                
                                // Apply ASAP while preserving manual positions
                                events.forEach(event => {
                                    // üîí Skip manually positioned events
                                    if (event.manuallyScheduled) {
                                        console.log(`üîí Preserving manual position for: ${event.name}`);
                                        return;
                                    }
                                    
                                    // For true ASAP, remove constraints to let dependencies drive
                                    event.constraintType = null;
                                    event.constraintDate = null;
                                });
                                
                                // Trigger recalculation
                                await scheduler.project.propagate();
                                
                                // Auto-save only non-manual events
                                const modifiedEvents = events.filter(e => e.isModified && !e.manuallyScheduled);
                                if (modifiedEvents.length > 0) {
                                    await saveOperationChanges(modifiedEvents);
                                }
                                
                                showNotification('‚úÖ ASAP algorithm applied (manual positions preserved)', 'success');
                                
                            } else if (direction === 'Backward' || algorithm.includes('ALAP')) {
                                // ‚úÖ CORRECTED ALAP with workaround for Scheduler Pro
                                console.log('‚è™ Applying ALAP (Manual Late Scheduling)');
                                
                                const events = scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                                
                                // Find project end date (latest end of any task)
                                const projectEnd = new Date(
                                    Math.max(...events.map(e => e.endDate?.getTime() || Date.now()))
                                );
                                
                                // Apply manual ALAP while preserving manual positions
                                events.forEach(event => {
                                    // üîí Skip manually positioned events
                                    if (event.manuallyScheduled) {
                                        console.log(`üîí Preserving manual position for: ${event.name}`);
                                        return;
                                    }
                                    
                                    // Use valid Bryntum constraint: finishnolaterthan
                                    event.constraintType = 'finishnolaterthan';
                                    event.constraintDate = projectEnd;
                                });
                                
                                // Trigger recalculation
                                await scheduler.project.propagate();
                                
                                // Auto-save only non-manual events
                                const modifiedEvents = events.filter(e => e.isModified && !e.manuallyScheduled);
                                if (modifiedEvents.length > 0) {
                                    await saveOperationChanges(modifiedEvents);
                                }
                                
                                showNotification('‚ö†Ô∏è ALAP applied (limited support in Scheduler Pro)', 'warning');
                                console.warn('Note: Full ALAP support requires Bryntum Gantt. Using workaround with FNLT constraints.');
                                
                            } else if (algorithm.includes('Critical Path')) {
                                // ‚úÖ CORRECTED Critical Path with custom CPM implementation
                                console.log('üéØ Applying Custom Critical Path Method');
                                
                                const events = scheduler.eventStore.records.filter(
                                    e => e.resourceId !== 'unscheduled'
                                );
                                
                                // Step 1: Apply ASAP first to get early dates
                                scheduler.project.direction = 'Forward';
                                scheduler.project.startDate = new Date(2025, 8, 3, 7, 0, 0);
                                
                                events.forEach(event => {
                                    if (!event.manuallyScheduled) {
                                        event.constraintType = null;
                                        event.constraintDate = null;
                                    }
                                });
                                
                                await scheduler.project.propagate();
                                
                                // Step 2: Calculate slack and identify critical path
                                const projectEnd = new Date(
                                    Math.max(...events.map(e => e.endDate?.getTime() || 0))
                                );
                                
                                // Custom CPM calculation
                                events.forEach(event => {
                                    if (event.manuallyScheduled) {
                                        console.log(`üîí Preserving manual position for: ${event.name}`);
                                        return;
                                    }
                                    
                                    // Get dependencies
                                    const hasSuccessors = scheduler.dependencyStore.records.some(
                                        dep => dep.fromEvent === event.id
                                    );
                                    
                                    // Simplified critical determination: events with successors
                                    // and events that end near project end
                                    const daysToEnd = (projectEnd - event.endDate) / (1000 * 60 * 60 * 24);
                                    const isCritical = hasSuccessors || daysToEnd < 2;
                                    
                                    if (isCritical) {
                                        // Add critical path styling
                                        event.cls = (event.cls || '') + ' critical-path-task';
                                        event.eventColor = '#dc2626';
                                        console.log(`üéØ Critical: ${event.name}`);
                                    }
                                });
                                
                                scheduler.refresh();
                                
                                // Auto-save all changes
                                const modifiedEvents = events.filter(e => e.isModified && !e.manuallyScheduled);
                                if (modifiedEvents.length > 0) {
                                    await saveOperationChanges(modifiedEvents);
                                }
                                
                                showNotification('‚ö†Ô∏è Critical Path applied (custom implementation)', 'warning');
                                console.warn('Note: Full Critical Path support requires Bryntum Gantt. Using simplified calculation.');
                                
                            } else if (algorithm.includes('Resource Leveling')) {
                                // Apply Resource Leveling
                                console.log('‚öñÔ∏è Applying Resource Leveling');
                                
                                // Resource leveling logic would go here
                                // This is a placeholder as full implementation would require complex balancing logic
                                showNotification('Resource Leveling applied', 'success');
                                
                            } else if (algorithm.includes('Drum') || algorithm.includes('TOC')) {
                                // Apply Theory of Constraints
                                console.log('ü•Å Applying Drum/TOC optimization');
                                
                                // TOC logic would go here
                                // This is a placeholder as full implementation would require bottleneck identification
                                showNotification('Drum/TOC optimization applied', 'success');
                                
                            } else if (algorithm.includes('PERT') || algorithm.includes('pert')) {
                                // Apply PERT algorithm
                                console.log('üìä Applying PERT (Probabilistic) scheduling');
                                
                                const events = scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                                let hasAnyPertData = false;
                                
                                // Apply PERT expected times to events
                                events.forEach(event => {
                                    if (window.pertEstimates[event.id]) {
                                        const estimates = window.pertEstimates[event.id];
                                        
                                        // Update duration to expected time
                                        event.duration = estimates.expectedTime;
                                        
                                        // Apply uncertainty visual indicators
                                        event.cls = event.cls ? event.cls.replace(/pert-\w+-uncertainty/g, '') : '';
                                        if (estimates.cv < 10) {
                                            event.cls = (event.cls || '') + ' pert-low-uncertainty';
                                        } else if (estimates.cv < 20) {
                                            event.cls = (event.cls || '') + ' pert-medium-uncertainty';
                                        } else {
                                            event.cls = (event.cls || '') + ' pert-high-uncertainty';
                                        }
                                        
                                        event.pertData = estimates;
                                        hasAnyPertData = true;
                                    }
                                });
                                
                                // Show PERT metrics panel
                                document.getElementById('pertMetricsPanel').classList.add('active');
                                updatePertMetrics();
                                
                                // Trigger recalculation
                                await scheduler.project.propagate();
                                scheduler.refresh();
                                
                                if (!hasAnyPertData) {
                                    showNotification('‚ö†Ô∏è No PERT estimates found. Right-click on operations to add three-point estimates.', 'warning');
                                } else {
                                    showNotification('‚úÖ PERT algorithm applied with probabilistic scheduling', 'success');
                                }
                                
                            } else {
                                console.warn('Unknown algorithm:', algorithm);
                                showNotification(`Unknown algorithm: ${algorithm}`, 'warning');
                            }
                            
                            // Refresh the scheduler view
                            scheduler.refresh();
                            
                        } catch (error) {
                            console.error('Error applying algorithm:', error);
                            showNotification(`Error applying algorithm: ${error.message}`, 'error');
                        }
                    }
                });
                
                console.log('‚úÖ PostMessage listener added for AI agent algorithm execution');
                
                // Version Management Functions
                function createVersion(description = 'Manual snapshot') {
                    if (!scheduler || !scheduler.project) {
                        console.error('Scheduler not initialized');
                        return;
                    }
                    
                    try {
                        // Get the current project state
                        const projectData = scheduler.project.toJSON();
                        
                        // Create version object
                        const version = {
                            id: `v${Date.now()}`,
                            name: `Version ${new Date().toLocaleTimeString()}`,
                            timestamp: new Date().toISOString(),
                            description: description,
                            data: {
                                events: scheduler.eventStore.toJSON(),
                                resources: scheduler.resourceStore.toJSON(),
                                dependencies: scheduler.dependencyStore.toJSON(),
                                project: projectData
                            }
                        };
                        
                        // Store in localStorage 
                        const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                        versions.push(version);
                        
                        // Keep only last 20 versions
                        if (versions.length > 20) {
                            versions.shift();
                        }
                        
                        localStorage.setItem('schedulerVersions', JSON.stringify(versions));
                        
                        console.log('‚úÖ Version created:', version.name, description);
                        showNotification(`Version saved: ${description}`, 'success');
                        
                        return version;
                    } catch (error) {
                        console.error('Error creating version:', error);
                        showNotification('Failed to create version', 'error');
                    }
                }
                
                function loadVersion(versionId) {
                    const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                    const version = versions.find(v => v.id === versionId);
                    
                    if (!version) {
                        showNotification('Version not found', 'error');
                        return;
                    }
                    
                    try {
                        // Create backup of current state before restoring
                        createVersion('Before restore');
                        
                        // Restore the version data
                        scheduler.eventStore.loadData(version.data.events);
                        scheduler.resourceStore.loadData(version.data.resources);
                        scheduler.dependencyStore.loadData(version.data.dependencies);
                        
                        showNotification(`Version restored: ${version.name}`, 'success');
                        updateStatus();
                    } catch (error) {
                        console.error('Error restoring version:', error);
                        showNotification('Failed to restore version', 'error');
                    }
                }
                
                function showVersionsDialog() {
                    const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                    
                    // Create modal dialog
                    const modal = document.createElement('div');
                    modal.className = 'constraint-modal active';
                    modal.innerHTML = `
                        <div class="constraint-modal-content" style="max-width: 900px;">
                            <div class="constraint-modal-header">
                                <h2>Version History</h2>
                                <button class="constraint-modal-close" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                            </div>
                            <div class="constraint-modal-body">
                                <div style="max-height: 500px; overflow-y: auto;">
                                    <table style="width: 100%; border-collapse: collapse;">
                                        <thead>
                                            <tr style="border-bottom: 2px solid #ddd;">
                                                <th style="padding: 10px; text-align: left;">Version</th>
                                                <th style="padding: 10px; text-align: left;">Time</th>
                                                <th style="padding: 10px; text-align: left;">Description</th>
                                                <th style="padding: 10px; text-align: center;">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${versions.reverse().map(v => `
                                                <tr style="border-bottom: 1px solid #eee;">
                                                    <td style="padding: 10px;">${v.name}</td>
                                                    <td style="padding: 10px;">${new Date(v.timestamp).toLocaleString()}</td>
                                                    <td style="padding: 10px;">${v.description}</td>
                                                    <td style="padding: 10px; text-align: center;">
                                                        <button onclick="loadVersion('${v.id}')" style="margin-right: 5px;">Restore</button>
                                                        <button onclick="deleteVersion('${v.id}')">Delete</button>
                                                    </td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                    ${versions.length === 0 ? '<p style="text-align: center; padding: 20px;">No versions saved yet</p>' : ''}
                                </div>
                            </div>
                            <div class="constraint-modal-footer">
                                <button onclick="clearAllVersions()" style="background: #ff4444; color: white;">Clear All</button>
                                <button onclick="this.parentElement.parentElement.parentElement.remove()">Close</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                }
                
                function compareVersions() {
                    const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                    
                    if (versions.length < 2) {
                        showNotification('Need at least 2 versions to compare', 'warning');
                        return;
                    }
                    
                    // Create comparison modal
                    const modal = document.createElement('div');
                    modal.className = 'constraint-modal active';
                    modal.innerHTML = `
                        <div class="constraint-modal-content" style="max-width: 1000px;">
                            <div class="constraint-modal-header">
                                <h2>Compare Versions</h2>
                                <button class="constraint-modal-close" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                            </div>
                            <div class="constraint-modal-body">
                                <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                                    <div style="flex: 1;">
                                        <label>Version 1:</label>
                                        <select id="version1Select" style="width: 100%; padding: 5px;">
                                            ${versions.map((v, i) => `<option value="${v.id}">${v.name} - ${v.description}</option>`).join('')}
                                        </select>
                                    </div>
                                    <div style="flex: 1;">
                                        <label>Version 2:</label>
                                        <select id="version2Select" style="width: 100%; padding: 5px;">
                                            ${versions.map((v, i) => `<option value="${v.id}" ${i === versions.length - 1 ? 'selected' : ''}>${v.name} - ${v.description}</option>`).join('')}
                                        </select>
                                    </div>
                                    <button onclick="performVersionComparison()" style="padding: 5px 15px;">Compare</button>
                                </div>
                                <div id="comparisonResults" style="max-height: 400px; overflow-y: auto; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                                    <p style="text-align: center; color: #999;">Select versions and click Compare</p>
                                </div>
                            </div>
                            <div class="constraint-modal-footer">
                                <button onclick="this.parentElement.parentElement.parentElement.remove()">Close</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                }
                
                window.performVersionComparison = function() {
                    const v1Id = document.getElementById('version1Select').value;
                    const v2Id = document.getElementById('version2Select').value;
                    
                    const versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                    const v1 = versions.find(v => v.id === v1Id);
                    const v2 = versions.find(v => v.id === v2Id);
                    
                    if (!v1 || !v2) {
                        showNotification('Version not found', 'error');
                        return;
                    }
                    
                    // Compare the versions
                    const differences = [];
                    
                    // Compare event counts
                    const v1Events = v1.data.events.length;
                    const v2Events = v2.data.events.length;
                    if (v1Events !== v2Events) {
                        differences.push(`Event count: ${v1Events} ‚Üí ${v2Events} (${v2Events - v1Events > 0 ? '+' : ''}${v2Events - v1Events})`);
                    }
                    
                    // Compare resource counts
                    const v1Resources = v1.data.resources.length;
                    const v2Resources = v2.data.resources.length;
                    if (v1Resources !== v2Resources) {
                        differences.push(`Resource count: ${v1Resources} ‚Üí ${v2Resources} (${v2Resources - v1Resources > 0 ? '+' : ''}${v2Resources - v1Resources})`);
                    }
                    
                    // Compare dependency counts
                    const v1Deps = v1.data.dependencies.length;
                    const v2Deps = v2.data.dependencies.length;
                    if (v1Deps !== v2Deps) {
                        differences.push(`Dependency count: ${v1Deps} ‚Üí ${v2Deps} (${v2Deps - v1Deps > 0 ? '+' : ''}${v2Deps - v1Deps})`);
                    }
                    
                    // Find modified events
                    const modifiedEvents = [];
                    v1.data.events.forEach(e1 => {
                        const e2 = v2.data.events.find(e => e.id === e1.id);
                        if (e2) {
                            if (JSON.stringify(e1) !== JSON.stringify(e2)) {
                                modifiedEvents.push(e1.name || e1.id);
                            }
                        }
                    });
                    
                    if (modifiedEvents.length > 0) {
                        differences.push(`Modified events: ${modifiedEvents.slice(0, 5).join(', ')}${modifiedEvents.length > 5 ? ` and ${modifiedEvents.length - 5} more` : ''}`);
                    }
                    
                    // Display results
                    const resultsDiv = document.getElementById('comparisonResults');
                    if (differences.length === 0) {
                        resultsDiv.innerHTML = '<p style="color: green;">‚úÖ No differences found between versions</p>';
                    } else {
                        resultsDiv.innerHTML = `
                            <h4>Differences Found:</h4>
                            <ul style="margin: 10px 0;">
                                ${differences.map(d => `<li>${d}</li>`).join('')}
                            </ul>
                            <div style="margin-top: 20px;">
                                <p><strong>Version 1:</strong> ${v1.name} - ${v1.description}</p>
                                <p><strong>Version 2:</strong> ${v2.name} - ${v2.description}</p>
                            </div>
                        `;
                    }
                };
                
                window.deleteVersion = function(versionId) {
                    if (confirm('Delete this version?')) {
                        let versions = JSON.parse(localStorage.getItem('schedulerVersions') || '[]');
                        versions = versions.filter(v => v.id !== versionId);
                        localStorage.setItem('schedulerVersions', JSON.stringify(versions));
                        showNotification('Version deleted', 'success');
                        // Refresh the dialog
                        document.querySelector('.constraint-modal').remove();
                        showVersionsDialog();
                    }
                };
                
                window.clearAllVersions = function() {
                    if (confirm('Clear all saved versions? This cannot be undone.')) {
                        localStorage.setItem('schedulerVersions', '[]');
                        showNotification('All versions cleared', 'success');
                        document.querySelector('.constraint-modal').remove();
                    }
                };
                
                window.loadVersion = loadVersion;  // Make it globally accessible
                
                // Add event listeners to handle dragging from unscheduled resource
                // Track current scheduling mode
                let currentSchedulingMode = 'ASAP'; // Default mode
                
                scheduler.on('eventdrop', async ({ eventRecords, targetResourceRecord, context }) => {
                    // Create a version before the drag operation is finalized
                    const draggedNames = eventRecords.map(e => e.name).join(', ');
                    createVersion(`After drag: ${draggedNames.substring(0, 50)}${draggedNames.length > 50 ? '...' : ''}`);
                    
                    for (const eventRecord of eventRecords) {
                        // Check if the event was dragged from unscheduled to a real resource
                        if (eventRecord.isUnscheduled && targetResourceRecord.id !== 'unscheduled') {
                            // Mark as scheduled now
                            eventRecord.isUnscheduled = false;
                            // Update color to match the operation type
                            eventRecord.eventColor = getOperationColor(eventRecord.name);
                            
                            // Apply appropriate constraints based on scheduling mode
                            if (currentSchedulingMode === 'ASAP') {
                                eventRecord.constraintType = 'startnoearlierthan';
                                eventRecord.constraintDate = eventRecord.startDate;
                            } else if (currentSchedulingMode === 'ALAP') {
                                // For ALAP, only apply constraint if it's a leaf event
                                const hasSuccessors = scheduler.dependencyStore.query(d => d.from === eventRecord.id).length > 0;
                                if (!hasSuccessors) {
                                    eventRecord.constraintType = 'finishnolaterthan';
                                    eventRecord.constraintDate = eventRecord.endDate;
                                } else {
                                    // Clear constraints for non-leaf events to let dependencies drive
                                    eventRecord.constraintType = null;
                                    eventRecord.constraintDate = null;
                                }
                            } else {
                                // For other modes, let the algorithm handle constraints
                                eventRecord.constraintType = null;
                                eventRecord.constraintDate = null;
                            }
                            
                            console.log(`‚úÖ Operation "${eventRecord.name}" scheduled to resource: ${targetResourceRecord.name}`);
                            updateStatus(); // Update metrics
                        } else if (!eventRecord.isUnscheduled && targetResourceRecord.id === 'unscheduled') {
                            // Mark as unscheduled if dragged back to unscheduled
                            eventRecord.isUnscheduled = true;
                            eventRecord.eventColor = '#808080';
                            eventRecord.constraintType = null;
                            eventRecord.constraintDate = null;
                            console.log(`‚ö†Ô∏è Operation "${eventRecord.name}" moved to unscheduled`);
                            updateStatus(); // Update metrics
                        } else if (!eventRecord.isUnscheduled && targetResourceRecord.id !== 'unscheduled') {
                            // Regular drag between scheduled resources - handle based on mode
                            if (currentSchedulingMode === 'ALAP') {
                                // For ALAP mode, handle constraints more intelligently
                                const hasSuccessors = scheduler.dependencyStore.query(d => d.from === eventRecord.id).length > 0;
                                
                                if (hasSuccessors) {
                                    // This event has successors - clear constraints to let dependencies drive
                                    eventRecord.constraintType = null;
                                    eventRecord.constraintDate = null;
                                    console.log(`üîÑ Clearing constraints for "${eventRecord.name}" to let dependencies drive in ALAP mode`);
                                } else {
                                    // Leaf event - can have FNLT constraint
                                    eventRecord.constraintType = 'finishnolaterthan';
                                    eventRecord.constraintDate = eventRecord.endDate;
                                }
                            } else if (currentSchedulingMode === 'ASAP') {
                                // For ASAP, apply SNET constraint as usual
                                eventRecord.constraintType = 'startnoearlierthan';
                                eventRecord.constraintDate = eventRecord.startDate;
                            } else {
                                // For other modes, clear constraints
                                eventRecord.constraintType = null;
                                eventRecord.constraintDate = null;
                            }
                        }
                    }
                    
                    // Recalculate dependencies after drag in ALAP or Critical Path mode
                    if (currentSchedulingMode === 'ALAP' || currentSchedulingMode === 'Critical Path') {
                        await scheduler.project.propagate();
                        console.log('üîÑ Dependencies recalculated after drag operation');
                    }
                });
                
                // Enhanced status update function using real PT data
                function updateStatus() {
                    const operationCount = scheduler.eventStore.count || 0;
                    document.getElementById('operationCount').textContent = `${operationCount} operations scheduled`;
                    
                    // Debug: Log to console for troubleshooting
                    console.log('üìä Status update: Operations =', operationCount);
                    
                    // Calculate detailed resource utilization using PT operations data
                    const events = scheduler.eventStore.records || [];
                    const resources = scheduler.resourceStore.records || [];
                    
                    let totalOperationHours = 0;
                    const resourceUtilization = {};
                    
                    // Find the actual schedule timespan
                    let earliestStart = null;
                    let latestEnd = null;
                    
                    // Calculate utilization per resource and find schedule bounds
                    resources.forEach(resource => {
                        // Skip the unscheduled resource line from calculations
                        if (resource.id === 'unscheduled') return;
                        
                        const resourceEvents = events.filter(e => e.resourceId === resource.id);
                        let resourceHours = 0;
                        
                        resourceEvents.forEach(event => {
                            resourceHours += event.duration || 0;
                            
                            // Track schedule bounds
                            if (event.startDate) {
                                const startTime = new Date(event.startDate).getTime();
                                const endTime = new Date(event.endDate || event.startDate).getTime();
                                
                                if (!earliestStart || startTime < earliestStart) {
                                    earliestStart = startTime;
                                }
                                if (!latestEnd || endTime > latestEnd) {
                                    latestEnd = endTime;
                                }
                            }
                        });
                        
                        resourceUtilization[resource.id] = {
                            name: resource.name,
                            hours: resourceHours,
                            operationCount: resourceEvents.length
                        };
                        totalOperationHours += resourceHours;
                    });
                    
                    // Calculate actual working days and hours in the schedule
                    let scheduleSpanHours = 0;
                    if (earliestStart && latestEnd) {
                        const spanMs = latestEnd - earliestStart;
                        const spanDays = Math.ceil(spanMs / (1000 * 60 * 60 * 24));
                        // Assume 8 working hours per day
                        scheduleSpanHours = spanDays * 8;
                    } else {
                        // Fallback to single day if no schedule
                        scheduleSpanHours = 8;
                    }
                    
                    // Calculate utilization based on actual schedule span
                    // Exclude unscheduled resource from count
                    const activeResources = resources.filter(r => r.id !== 'unscheduled').length;
                    const totalResourceCapacity = activeResources * scheduleSpanHours;
                    const utilization = totalResourceCapacity > 0 ? Math.round((totalOperationHours / totalResourceCapacity) * 100) : 0;
                    
                    document.getElementById('resourceUtilization').textContent = `Resource utilization: ${utilization}% (${totalOperationHours.toFixed(1)}h total)`;
                    document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                    
                    // Store utilization data for Max AI analysis
                    window.currentUtilization = resourceUtilization;
                    window.currentStats = {
                        operations: operationCount,
                        utilization: utilization,
                        totalHours: totalOperationHours,
                        resources: resources.length
                    };
                }

                // Removed standalone navigation - now integrated with main app
                // const maxAIBtn = document.getElementById('maxAIBtn');
                // const maxAI = document.getElementById('maxAI');
                // const closeMaxAI = document.getElementById('closeMaxAI');
                // const maxInput = document.getElementById('maxInput');
                // const maxSend = document.getElementById('maxSend');
                // const maxMessages = document.getElementById('maxMessages');
                
                // maxAIBtn.addEventListener('click', () => {
                //     maxAI.classList.toggle('closed');
                //     const btnText = maxAI.classList.contains('closed') ? 'ü§ñ Max AI' : 'ü§ñ Hide AI';
                //     maxAIBtn.textContent = btnText;
                // });
                
                // closeMaxAI.addEventListener('click', () => {
                //     maxAI.classList.add('closed');
                //     maxAIBtn.textContent = 'ü§ñ Max AI';
                // });
                
                // Listen for messages from parent window (main app's Max AI panel)
                window.addEventListener('message', (event) => {
                    // Handle algorithm run requests from parent
                    if (event.data && event.data.type === 'RUN_ALGORITHM') {
                        runSchedulerAlgorithm(event.data.algorithm);
                    }
                });
                
                // Function to run scheduler algorithms from quick actions
                function runSchedulerAlgorithm(algorithm) {
                    const algorithmDropdown = document.getElementById('schedulingAlgorithm');
                    const applyButton = document.getElementById('applyScheduling');
                    
                    // Map algorithm names to dropdown values
                    const algorithmMap = {
                        'ASAP': 'asap',
                        'ALAP': 'alap',
                        'CRITICAL_PATH': 'criticalPath',
                        'LEVEL_RESOURCES': 'levelResources',
                        'DRUM_TOC': 'drum'
                    };
                    
                    // Set the dropdown value and trigger the algorithm
                    if (algorithmMap[algorithm]) {
                        algorithmDropdown.value = algorithmMap[algorithm];
                        applyButton.click();
                        
                        // Max AI feedback removed - handled by main app's AI panel
                        // const aiMsg = document.createElement('div');
                        // aiMsg.className = 'max-ai-message assistant';
                        // aiMsg.textContent = `‚úÖ ${algorithm.replace(/_/g, ' ')} algorithm applied successfully!`;
                        // maxMessages.appendChild(aiMsg);
                        // maxMessages.scrollTop = maxMessages.scrollHeight;
                    }
                }
                
                // Make functions available globally for onclick handlers
                window.runSchedulerAlgorithm = runSchedulerAlgorithm;
                
                // Max AI chat functionality removed - handled by main app's AI panel
                function sendMaxMessage() {
                    // This function is now handled by the main app's Max AI panel
                    console.log('Max AI chat is handled by the main app panel');
                    return;
                    
                    // Removed code that references deleted elements
                    // const message = maxInput.value.trim();
                    // if (!message) return;
                    // const userMsg = document.createElement('div');
                    // userMsg.className = 'max-ai-message user';
                    // userMsg.textContent = message;
                    // maxMessages.appendChild(userMsg);
                    
                    // Clear input
                    maxInput.value = '';
                    
                    // Process AI response and execute algorithms
                    setTimeout(async () => {
                        const aiMsg = document.createElement('div');
                        aiMsg.className = 'max-ai-message assistant';
                        
                        // Parse message for algorithm commands
                        const lowerMessage = message.toLowerCase();
                        let response = '';
                        let executedAlgorithm = null;
                        
                        // Check for algorithm execution commands
                        if (lowerMessage.includes('run') || lowerMessage.includes('execute') || lowerMessage.includes('apply') || lowerMessage.includes('optimize')) {
                            if (lowerMessage.includes('asap') || lowerMessage.includes('forward')) {
                                executedAlgorithm = 'asap';
                                response = 'üöÄ Executing ASAP (Forward) scheduling algorithm...';
                            } else if (lowerMessage.includes('alap') || lowerMessage.includes('backward')) {
                                executedAlgorithm = 'alap';
                                response = '‚è∞ Executing ALAP (Backward) scheduling algorithm...';
                            } else if (lowerMessage.includes('critical path')) {
                                executedAlgorithm = 'criticalPath';
                                response = 'üéØ Executing Critical Path optimization...';
                            } else if (lowerMessage.includes('level') || lowerMessage.includes('balance resource')) {
                                executedAlgorithm = 'levelResources';
                                response = '‚öñÔ∏è Executing Resource Leveling algorithm...';
                            } else if (lowerMessage.includes('drum') || lowerMessage.includes('toc') || lowerMessage.includes('constraint')) {
                                executedAlgorithm = 'drum';
                                response = 'ü•Å Executing Drum (Theory of Constraints) optimization...';
                            } else {
                                response = 'To optimize the schedule, please specify an algorithm. You can say:\n‚Ä¢ "Run ASAP scheduling"\n‚Ä¢ "Apply ALAP algorithm"\n‚Ä¢ "Execute critical path optimization"\n‚Ä¢ "Level resources"\n‚Ä¢ "Apply drum scheduling"';
                            }
                        } 
                        // Check for analysis or information requests
                        else if (lowerMessage.includes('what') || lowerMessage.includes('explain') || lowerMessage.includes('tell me about')) {
                            if (lowerMessage.includes('asap')) {
                                response = 'ASAP (As Soon As Possible) pushes all operations to the earliest possible time slots. Best for urgent orders or maximizing early throughput. Say "Run ASAP" to apply it.';
                            } else if (lowerMessage.includes('alap')) {
                                response = 'ALAP (As Late As Possible) delays operations to the latest time that still meets due dates. Minimizes inventory holding costs. Say "Run ALAP" to apply it.';
                            } else if (lowerMessage.includes('critical path')) {
                                response = 'Critical Path identifies the longest sequence of dependent tasks and optimizes them first. Minimizes project completion time. Say "Execute critical path" to apply it.';
                            } else if (lowerMessage.includes('level') || lowerMessage.includes('resource')) {
                                response = 'Resource Leveling distributes work evenly across all resources. Prevents overloading and improves efficiency. Say "Level resources" to apply it.';
                            } else if (lowerMessage.includes('drum') || lowerMessage.includes('toc')) {
                                response = 'Drum scheduling (TOC) identifies your bottleneck resource and optimizes around it. Maximizes throughput. Say "Apply drum scheduling" to apply it.';
                            } else if (lowerMessage.includes('current') || lowerMessage.includes('active')) {
                                const currentAlgo = document.getElementById('schedulingAlgorithm').value;
                                const algoNames = {
                                    'asap': 'ASAP (Forward)',
                                    'alap': 'ALAP (Backward)',
                                    'criticalPath': 'Critical Path',
                                    'levelResources': 'Resource Leveling',
                                    'drum': 'Drum (TOC)'
                                };
                                response = `The current active algorithm is: ${algoNames[currentAlgo]}. You can ask me to run any other algorithm to change it.`;
                            } else {
                                response = 'I can help you optimize the schedule. Try asking:\n‚Ä¢ "Run ASAP scheduling"\n‚Ä¢ "What is the current algorithm?"\n‚Ä¢ "Explain critical path"\n‚Ä¢ "Level the resources"';
                            }
                        }
                        // Check for help commands
                        else if (lowerMessage.includes('help') || lowerMessage.includes('commands')) {
                            response = 'üìä **Schedule Optimization Commands:**\n\n**Execute Algorithms:**\n‚Ä¢ Run ASAP\n‚Ä¢ Apply ALAP\n‚Ä¢ Execute critical path\n‚Ä¢ Level resources\n‚Ä¢ Apply drum scheduling\n\n**Get Information:**\n‚Ä¢ What is ASAP?\n‚Ä¢ Explain critical path\n‚Ä¢ Current algorithm?\n\n**Analysis:**\n‚Ä¢ Analyze schedule\n‚Ä¢ Show utilization';
                        }
                        // Check for analysis commands
                        else if (lowerMessage.includes('analyze') || lowerMessage.includes('utilization') || lowerMessage.includes('insights') || lowerMessage.includes('bottleneck')) {
                            // Perform detailed schedule analysis
                            const scheduler = window.scheduler;
                            const events = scheduler.eventStore.records || [];
                            const resources = scheduler.resourceStore.records || [];
                            
                            // Calculate resource utilization details
                            const resourceUsage = {};
                            resources.forEach(resource => {
                                const resourceEvents = events.filter(e => e.resourceId === resource.id);
                                let totalDuration = 0;
                                resourceEvents.forEach(event => {
                                    const duration = (event.endDate - event.startDate) / (1000 * 60 * 60); // hours
                                    totalDuration += duration;
                                });
                                resourceUsage[resource.name] = {
                                    operations: resourceEvents.length,
                                    hoursUsed: totalDuration.toFixed(1),
                                    utilization: resourceEvents.length > 0 ? 100 : 0
                                };
                            });
                            
                            // Find bottlenecks (resources with highest utilization)
                            let bottleneck = null;
                            let maxOps = 0;
                            Object.entries(resourceUsage).forEach(([name, data]) => {
                                if (data.operations > maxOps) {
                                    maxOps = data.operations;
                                    bottleneck = name;
                                }
                            });
                            
                            // Calculate timeline span
                            let earliestStart = null;
                            let latestEnd = null;
                            events.forEach(event => {
                                if (!earliestStart || event.startDate < earliestStart) {
                                    earliestStart = event.startDate;
                                }
                                if (!latestEnd || event.endDate > latestEnd) {
                                    latestEnd = event.endDate;
                                }
                            });
                            
                            const makespan = earliestStart && latestEnd ? 
                                ((latestEnd - earliestStart) / (1000 * 60 * 60)).toFixed(1) : 0;
                            
                            // Build comprehensive analysis
                            response = 'üìä **Production Schedule Analysis**\n\n';
                            response += `üìà **Overall Metrics:**\n`;
                            response += `‚Ä¢ Total Operations: ${events.length}\n`;
                            response += `‚Ä¢ Active Resources: ${Object.values(resourceUsage).filter(r => r.operations > 0).length}/${resources.length}\n`;
                            response += `‚Ä¢ Total Makespan: ${makespan} hours\n`;
                            response += `‚Ä¢ Current Algorithm: ${document.getElementById('schedulingAlgorithm').options[document.getElementById('schedulingAlgorithm').selectedIndex].text}\n\n`;
                            
                            response += `üè≠ **Resource Utilization:**\n`;
                            Object.entries(resourceUsage).forEach(([name, data]) => {
                                if (data.operations > 0) {
                                    response += `‚Ä¢ ${name}: ${data.operations} operations, ${data.hoursUsed} hours\n`;
                                }
                            });
                            
                            if (bottleneck) {
                                response += `\n‚ö†Ô∏è **Bottleneck Identified:**\n`;
                                response += `‚Ä¢ ${bottleneck} has the highest load with ${maxOps} operations\n`;
                            }
                            
                            // Optimization recommendations
                            response += `\nüí° **Optimization Recommendations:**\n`;
                            
                            const currentAlgo = document.getElementById('schedulingAlgorithm').value;
                            if (currentAlgo === 'asap') {
                                response += `‚Ä¢ Current: ASAP - Good for urgent orders\n`;
                                response += `‚Ä¢ Consider: ALAP to reduce inventory costs\n`;
                                response += `‚Ä¢ Consider: Level Resources to balance workload\n`;
                            } else if (currentAlgo === 'alap') {
                                response += `‚Ä¢ Current: ALAP - Minimizing inventory\n`;
                                response += `‚Ä¢ Consider: ASAP for faster delivery\n`;
                                response += `‚Ä¢ Consider: Critical Path to reduce makespan\n`;
                            } else if (currentAlgo === 'criticalPath') {
                                response += `‚Ä¢ Current: Critical Path - Optimized for completion time\n`;
                                response += `‚Ä¢ Consider: Level Resources if some resources are overloaded\n`;
                                response += `‚Ä¢ Consider: Drum/TOC if bottleneck is limiting throughput\n`;
                            } else if (currentAlgo === 'levelResources') {
                                response += `‚Ä¢ Current: Resource Leveling - Balanced workload\n`;
                                response += `‚Ä¢ Consider: Critical Path to reduce total time\n`;
                                response += `‚Ä¢ Consider: Drum/TOC to optimize bottlenecks\n`;
                            } else {
                                response += `‚Ä¢ Current: Drum/TOC - Optimized for bottlenecks\n`;
                                response += `‚Ä¢ Consider: ASAP for urgent completion\n`;
                                response += `‚Ä¢ Consider: Level Resources for even distribution\n`;
                            }
                            
                            response += `\nWould you like me to apply a different algorithm to optimize the schedule?`;
                        }
                        else {
                            response = `I understand you're asking about "${message}". I can help you optimize the schedule using different algorithms. Say "help" to see available commands.`;
                        }
                        
                        // Execute the algorithm if one was selected
                        if (executedAlgorithm) {
                            aiMsg.textContent = response;
                            maxMessages.appendChild(aiMsg);
                            maxMessages.scrollTop = maxMessages.scrollHeight;
                            
                            // Change the dropdown and execute
                            document.getElementById('schedulingAlgorithm').value = executedAlgorithm;
                            
                            // Execute the algorithm after a brief delay
                            setTimeout(() => {
                                // Click the apply button to trigger the algorithm
                                document.getElementById('applyScheduling').click();
                                
                                // Add success message after algorithm completes
                                setTimeout(() => {
                                    const successMsg = document.createElement('div');
                                    successMsg.className = 'max-ai-message assistant';
                                    const algoNames = {
                                        'asap': 'ASAP (Forward)',
                                        'alap': 'ALAP (Backward)',
                                        'criticalPath': 'Critical Path',
                                        'levelResources': 'Resource Leveling',
                                        'drum': 'Drum (TOC)'
                                    };
                                    
                                    // Get updated stats
                                    const utilization = document.getElementById('resourceUtilization').textContent;
                                    const totalOps = document.getElementById('operationCount').textContent;
                                    
                                    successMsg.textContent = `‚úÖ Successfully applied ${algoNames[executedAlgorithm]} algorithm!\n\nResults:\n‚Ä¢ ${totalOps}\n‚Ä¢ ${utilization}\n\nThe schedule has been optimized. Would you like to try a different algorithm?`;
                                    maxMessages.appendChild(successMsg);
                                    maxMessages.scrollTop = maxMessages.scrollHeight;
                                }, 1500); // Wait for algorithm to complete
                            }, 500);
                        } else {
                            aiMsg.textContent = response;
                            maxMessages.appendChild(aiMsg);
                            maxMessages.scrollTop = maxMessages.scrollHeight;
                        }
                    }, 300);
                    
                    maxMessages.scrollTop = maxMessages.scrollHeight;
                }
                
                // Max AI event listeners removed - using main app's AI panel
                // maxSend.addEventListener('click', sendMaxMessage);
                // maxInput.addEventListener('keypress', (e) => {
                //     if (e.key === 'Enter') sendMaxMessage();
                // });
                
                // Theme toggle removed - using consistent light theme with blue-purple gradient
                
                // View preset selector - preserve current date when changing views
                document.getElementById('viewPreset').addEventListener('change', (e) => {
                    // Save the current center date before changing view
                    const currentCenterDate = scheduler.viewportCenterDate || new Date();
                    
                    // Change the view preset
                    scheduler.viewPreset = e.target.value;
                    
                    // Restore the center date so we stay in the same time period
                    setTimeout(() => {
                        scheduler.scrollToDate(currentCenterDate, { block: 'center' });
                        console.log(`‚úÖ View changed to: ${e.target.value}, centered on: ${currentCenterDate.toISOString().split('T')[0]}`);
                    }, 100);
                });
                
                // Zoom controls
                document.getElementById('zoomIn').addEventListener('click', () => {
                    scheduler.zoomLevel = Math.min(scheduler.zoomLevel + 2, 20);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    scheduler.zoomLevel = Math.max(scheduler.zoomLevel - 2, 0);
                });
                
                document.getElementById('zoomToFit').addEventListener('click', () => {
                    // Zoom to fit all events according to Bryntum official documentation
                    // https://bryntum.com/products/schedulerpro/docs/api/Scheduler/view/mixin/TimelineZoomable#function-zoomToFit
                    scheduler.zoomToFit({
                        leftMargin: 50,   // Margin in pixels between first event start and first visible date
                        rightMargin: 50   // Margin in pixels between last event end and last visible date
                    });
                    console.log('Zoom to fit applied with 50px margins');
                });
                
                // Version Management Button Handlers
                document.getElementById('saveVersion').addEventListener('click', () => {
                    const description = prompt('Enter version description:', 'Manual snapshot');
                    if (description !== null) {
                        createVersion(description);
                    }
                });
                
                document.getElementById('viewVersions').addEventListener('click', () => {
                    showVersionsDialog();
                });
                
                document.getElementById('compareVersions').addEventListener('click', () => {
                    compareVersions();
                });
                
                // Apply Scheduling Algorithm button
                document.getElementById('applyScheduling').addEventListener('click', () => {
                    const algorithm = document.getElementById('schedulingAlgorithm').value;
                    document.getElementById('loadingOverlay').style.display = 'flex';
                    
                    // Store current view settings to maintain consistent timeline
                    const currentZoomLevel = scheduler.zoomLevel;
                    const currentStartDate = scheduler.startDate;
                    const currentEndDate = scheduler.endDate;
                    
                    // Save a version before applying algorithm
                    const algorithmNames = {
                        'asap': 'ASAP Forward',
                        'alap': 'ALAP Backward',
                        'criticalPath': 'Critical Path',
                        'levelResources': 'Resource Leveling',
                        'drum': 'Drum TOC',
                        'dbr': 'Theory of Constraints (DBR)',
                        'pert': 'PERT (Probabilistic)'
                    };
                    
                    createVersion(`Before ${algorithmNames[algorithm]} Algorithm`);
                    
                    requestAnimationFrame(() => {
                        setTimeout(async () => {
                            try {
                                const project = scheduler.project;
                                let message = '';
                                let color = 'green';
                                
                                switch(algorithm) {
                                    case 'asap':
                                        // ASAP - As Soon As Possible (Forward Scheduling)
                                        await asapScheduling();
                                        message = 'ASAP scheduling applied - operations scheduled as early as possible!';
                                        break;
                                        
                                    case 'alap':
                                        // ALAP - As Late As Possible (Backward Scheduling)
                                        await alapScheduling();
                                        message = 'ALAP scheduling applied - operations scheduled as late as possible!';
                                        color = 'blue';
                                        break;
                                        
                                    case 'criticalPath':
                                        // Critical Path Method
                                        await criticalPathScheduling();
                                        message = 'Critical Path identified and optimized!';
                                        color = 'orange';
                                        break;
                                        
                                    case 'levelResources':
                                        // Resource Leveling
                                        await levelResourcesScheduling();
                                        message = 'Resources leveled - workload balanced across resources!';
                                        color = 'purple';
                                        break;
                                        
                                    case 'drum':
                                        // Drum (Theory of Constraints)
                                        await drumScheduling();
                                        message = 'Drum scheduling applied - optimized around bottleneck!';
                                        color = 'brown';
                                        break;
                                        
                                    case 'dbr':
                                        // Theory of Constraints DBR (Drum-Buffer-Rope)
                                        await dbrScheduling();
                                        message = 'Theory of Constraints (DBR) applied - Bottleneck optimized with buffers!';
                                        color = '#8b5cf6';
                                        break;
                                }
                                
                                // Refresh the scheduler
                                scheduler.refresh();
                                
                                // Restore the original view settings to maintain consistent timeline
                                scheduler.zoomLevel = currentZoomLevel;
                                scheduler.setTimeSpan(currentStartDate, currentEndDate);
                                
                                // Hide loading and show success message
                                document.getElementById('loadingOverlay').style.display = 'none';
                                updateStatus();
                                
                                // Show message in status bar
                                const statusElement = document.getElementById('operationCount');
                                const originalText = statusElement.textContent;
                                statusElement.innerHTML = `<span style="color: ${color}; font-weight: bold;">${message}</span>`;
                                
                                setTimeout(() => {
                                    statusElement.textContent = originalText;
                                    updateStatus();
                                }, 3000);
                                
                            } catch (error) {
                                console.error('Scheduling error:', error);
                                document.getElementById('loadingOverlay').style.display = 'none';
                                
                                const statusElement = document.getElementById('operationCount');
                                const originalText = statusElement.textContent;
                                statusElement.innerHTML = `<span style="color: red;">Scheduling failed - ${error.message}</span>`;
                                
                                setTimeout(() => {
                                    statusElement.textContent = originalText;
                                    updateStatus();
                                }, 3000);
                            }
                        }, 300);
                    });
                });
                
                // Auto-save operation changes after drag/drop or resize
                async function saveOperationChanges(eventRecords) {
                    try {
                        const operations = eventRecords.map(event => ({
                            id: event.id,
                            start: event.startDate.toISOString(),
                            end: event.endDate.toISOString(),
                            manuallyScheduled: event.manuallyScheduled || false
                        }));
                        
                        console.log(`üíæ Auto-saving ${operations.length} operation(s) to database...`);
                        
                        const response = await fetch('/api/pt-operations/schedule', {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ operations })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log(`‚úÖ Auto-saved ${result.updated} operation(s)`);
                            
                            // Update last update time
                            const lastUpdateElement = document.getElementById('lastUpdate');
                            if (lastUpdateElement) {
                                lastUpdateElement.textContent = `Last update: ${new Date().toLocaleTimeString()}`;
                            }
                        } else {
                            console.error('‚ùå Failed to auto-save operations:', await response.text());
                        }
                    } catch (error) {
                        console.error('‚ùå Error auto-saving operations:', error);
                    }
                }
                
                // Save schedule to database
                async function saveSchedule() {
                    try {
                        const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                        const operations = events.map(event => ({
                            id: event.id,
                            start: event.startDate.toISOString(),
                            end: event.endDate.toISOString()
                        }));
                        
                        console.log(`üíæ Saving schedule to database (${operations.length} operations)...`);
                        
                        const response = await fetch('/api/pt-operations/schedule', {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ operations })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Save failed: ${response.statusText}`);
                        }
                        
                        const result = await response.json();
                        console.log(`‚úÖ Schedule saved: ${result.updated}/${result.total} operations updated`);
                        return true;
                    } catch (error) {
                        console.error('‚ùå Failed to save schedule:', error);
                        return false;
                    }
                }
                
                // Scheduling Algorithm Implementations using Bryntum's constraint system
                async function asapScheduling() {
                    // ASAP - Use Bryntum's constraint system for forward scheduling
                    console.log('üöÄ Applying ASAP scheduling using Bryntum engine...');
                    currentSchedulingMode = 'ASAP'; // Set mode for drag handler
                    
                    const project = scheduler.project;
                    const baseDate = new Date(2025, 8, 3, 7, 0, 0); // September 3, 2025 at 7 AM
                    
                    // Set project start date for forward scheduling
                    project.startDate = baseDate;
                    
                    // Get all scheduled events (exclude unscheduled)
                    const events = scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                    console.log(`  Total operations to schedule: ${events.length}`);
                    
                    // Apply ASAP constraints to all events (except manually scheduled ones)
                    events.forEach(event => {
                        // Skip events that were manually positioned by the user
                        if (event.manuallyScheduled) {
                            console.log(`üîí Preserving manual position for: ${event.name}`);
                            return;
                        }
                        
                        // Clear any existing constraints
                        event.constraintType = null;
                        event.constraintDate = null;
                        
                        // Apply Start No Earlier Than constraint for ASAP behavior
                        event.constraintType = 'startnoearlierthan';
                        event.constraintDate = baseDate;
                    });
                    
                    // Create dependencies between sequential operations on the same resource
                    // This prevents overlaps automatically
                    const resources = scheduler.resourceStore.records.filter(r => r.id !== 'unscheduled');
                    
                    for (const resource of resources) {
                        // Get all events assigned to this resource
                        const resourceEvents = events.filter(e => e.resourceId === resource.id);
                        
                        if (resourceEvents.length < 2) continue;
                        
                        // Sort by current start date or ID
                        resourceEvents.sort((a, b) => {
                            if (a.startDate && b.startDate) {
                                return a.startDate.getTime() - b.startDate.getTime();
                            }
                            return a.id - b.id;
                        });
                        
                        // Create Finish-to-Start dependencies between sequential operations
                        for (let i = 0; i < resourceEvents.length - 1; i++) {
                            const fromEvent = resourceEvents[i];
                            const toEvent = resourceEvents[i + 1];
                            
                            // Check if dependency already exists
                            const existingDep = scheduler.dependencyStore.find(d =>
                                d.from === fromEvent.id && d.to === toEvent.id
                            );
                            
                            if (!existingDep) {
                                // Add dependency to prevent overlaps
                                scheduler.dependencyStore.add({
                                    id: `asap_dep_${fromEvent.id}_${toEvent.id}`,
                                    from: fromEvent.id,
                                    to: toEvent.id,
                                    type: 2, // Finish-to-Start
                                    lag: 0.5, // 30 minute buffer
                                    lagUnit: 'hour'
                                });
                                console.log(`    Added dependency: ${fromEvent.name} ‚Üí ${toEvent.name}`);
                            }
                        }
                    }
                    
                    // Let the Bryntum engine recalculate all dates
                    await project.commitAsync();
                    
                    console.log('‚úÖ ASAP scheduling completed by Bryntum engine');
                    
                    // Verify results
                    let totalScheduled = 0;
                    let earliestStart = null;
                    let latestEnd = null;
                    
                    events.forEach(event => {
                        if (event.startDate && event.endDate) {
                            totalScheduled++;
                            if (!earliestStart || event.startDate < earliestStart) {
                                earliestStart = event.startDate;
                            }
                            if (!latestEnd || event.endDate > latestEnd) {
                                latestEnd = event.endDate;
                            }
                        }
                    });
                    
                    console.log(`  Scheduled ${totalScheduled}/${events.length} operations`);
                    if (earliestStart && latestEnd) {
                        console.log(`  Timeline: ${earliestStart.toLocaleDateString()} to ${latestEnd.toLocaleDateString()}`);
                    }
                    
                    await saveSchedule();
                }
                
                async function alapScheduling() {
                    // ALAP - Use Bryntum's constraint system for backward scheduling
                    console.log('‚è∞ Applying ALAP scheduling using Bryntum constraints...');
                    currentSchedulingMode = 'ALAP'; // Set mode for drag handler
                    
                    const project = scheduler.project;
                    const dueDate = new Date(2025, 8, 17, 17, 0, 0); // September 17, 2025 at 5 PM
                    
                    // Get all scheduled events
                    const events = scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                    console.log(`  Total operations to schedule: ${events.length}`);
                    
                    // Configure project for backward scheduling using proper API
                    await project.setDirection('Backward');
                    project.setConstraint({ 
                        type: 'finishnolaterthan', 
                        date: dueDate 
                    });
                    await project.propagate();
                    
                    // First ensure dependencies exist between sequential operations on same resource
                    const resources = scheduler.resourceStore.records.filter(r => r.id !== 'unscheduled');
                    
                    for (const resource of resources) {
                        const resourceEvents = events.filter(e => e.resourceId === resource.id);
                        
                        if (resourceEvents.length < 2) continue;
                        
                        // Sort by job and operation sequence for logical order
                        resourceEvents.sort((a, b) => {
                            // Parse job number and operation sequence from names
                            const aMatch = a.name.match(/Job (\d+).*Op (\d+)/);
                            const bMatch = b.name.match(/Job (\d+).*Op (\d+)/);
                            
                            if (aMatch && bMatch) {
                                const aJob = parseInt(aMatch[1]);
                                const bJob = parseInt(bMatch[1]);
                                const aOp = parseInt(aMatch[2]);
                                const bOp = parseInt(bMatch[2]);
                                
                                // Sort by job first, then by operation
                                if (aJob !== bJob) return aJob - bJob;
                                return aOp - bOp;
                            }
                            
                            // Fallback to ID if name parsing fails
                            return a.id - b.id;
                        });
                        
                        // Ensure dependencies exist
                        for (let i = 0; i < resourceEvents.length - 1; i++) {
                            const fromEvent = resourceEvents[i];
                            const toEvent = resourceEvents[i + 1];
                            
                            const existingDep = scheduler.dependencyStore.find(d =>
                                d.from === fromEvent.id && d.to === toEvent.id
                            );
                            
                            if (!existingDep) {
                                scheduler.dependencyStore.add({
                                    id: `alap_dep_${fromEvent.id}_${toEvent.id}`,
                                    from: fromEvent.id,
                                    to: toEvent.id,
                                    type: 2, // Finish-to-Start
                                    lag: 0.5, // 30 minute buffer
                                    lagUnit: 'hour'
                                });
                            }
                        }
                    }
                    
                    // Apply Finish No Later Than constraints to ALL events for ALAP (except manually scheduled)
                    events.forEach(event => {
                        // Skip events that were manually positioned by the user
                        if (event.manuallyScheduled) {
                            console.log(`üîí Preserving manual position for: ${event.name}`);
                            return;
                        }
                        
                        event.constraintType = 'finishnolaterthan';
                        event.constraintDate = dueDate;
                    });
                    
                    // Let the Bryntum engine recalculate with backward scheduling
                    await project.commitAsync();
                    
                    // After initial scheduling, adjust constraints to maintain relationships
                    // Only keep FNLT constraints on events that truly need them
                    const leafEvents = events.filter(event => {
                        const hasSuccessors = scheduler.dependencyStore.query(d => d.from === event.id).length > 0;
                        return !hasSuccessors;
                    });
                    
                    console.log(`  Found ${leafEvents.length} leaf operations (final operations)`);
                    
                    // Clear constraints on non-leaf events to let dependencies drive their dates
                    events.filter(e => !leafEvents.includes(e)).forEach(event => {
                        event.constraintType = null;
                        event.constraintDate = null;
                    });
                    
                    // Commit again to let dependencies drive the schedule
                    await project.commitAsync();
                    
                    console.log('‚úÖ ALAP scheduling completed by Bryntum engine');
                    
                    // Verify results
                    let totalScheduled = 0;
                    let earliestStart = null;
                    let latestEnd = null;
                    
                    events.forEach(event => {
                        if (event.startDate && event.endDate) {
                            totalScheduled++;
                            if (!earliestStart || event.startDate < earliestStart) {
                                earliestStart = event.startDate;
                            }
                            if (!latestEnd || event.endDate > latestEnd) {
                                latestEnd = event.endDate;
                            }
                        }
                    });
                    
                    console.log(`  Scheduled ${totalScheduled}/${events.length} operations`);
                    if (earliestStart && latestEnd) {
                        console.log(`  Timeline: ${earliestStart.toLocaleDateString()} to ${latestEnd.toLocaleDateString()}`);
                    }
                    
                    await saveSchedule();
                }
                
                // Enhanced Critical Path Method Implementation
                async function applyCriticalPathMethod() {
                    console.log('üéØ Starting Enhanced Critical Path Method Analysis...');
                    currentSchedulingMode = 'Critical Path';
                    
                    const project = scheduler.project;
                    const events = scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                    const dependencies = scheduler.dependencyStore.records;
                    
                    if (events.length === 0) {
                        showNotification('No operations to analyze', 'warning');
                        return;
                    }
                    
                    // Build adjacency lists for the dependency graph
                    const successors = new Map(); // Task ID -> Array of successor task IDs
                    const predecessors = new Map(); // Task ID -> Array of predecessor task IDs
                    const eventMap = new Map(); // Task ID -> Event object
                    
                    // Initialize maps
                    events.forEach(event => {
                        eventMap.set(event.id, event);
                        successors.set(event.id, []);
                        predecessors.set(event.id, []);
                        
                        // Initialize CPM data on each event
                        event.cpmData = {
                            earlyStart: 0,
                            earlyFinish: 0,
                            lateStart: Infinity,
                            lateFinish: Infinity,
                            totalSlack: 0,
                            freeSlack: 0,
                            isCritical: false,
                            isNearCritical: false
                        };
                    });
                    
                    // Build dependency graph
                    dependencies.forEach(dep => {
                        if (eventMap.has(dep.from) && eventMap.has(dep.to)) {
                            successors.get(dep.from).push({
                                id: dep.to,
                                lag: dep.lag || 0,
                                type: dep.type || 2 // Default to Finish-to-Start
                            });
                            predecessors.get(dep.to).push({
                                id: dep.from,
                                lag: dep.lag || 0,
                                type: dep.type || 2
                            });
                        }
                    });
                    
                    // Find tasks with no predecessors (start nodes)
                    const startNodes = events.filter(e => predecessors.get(e.id).length === 0);
                    
                    // FORWARD PASS - Calculate Early Start (ES) and Early Finish (EF)
                    console.log('üìà Forward Pass: Calculating ES and EF...');
                    const visited = new Set();
                    const queue = [...startNodes];
                    
                    // Set initial ES for start nodes based on their current positions
                    startNodes.forEach(node => {
                        node.cpmData.earlyStart = 0; // Use relative time from project start
                        node.cpmData.earlyFinish = node.duration || 2; // Duration in hours
                    });
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        if (visited.has(current.id)) continue;
                        
                        visited.add(current.id);
                        const currentSuccessors = successors.get(current.id) || [];
                        
                        currentSuccessors.forEach(succ => {
                            const successor = eventMap.get(succ.id);
                            if (!successor) return;
                            
                            // Calculate earliest start for successor based on dependency type
                            let earliestStart = current.cpmData.earlyFinish;
                            
                            // Add lag time
                            earliestStart += succ.lag;
                            
                            // Update successor's early start if this path provides a later start
                            if (earliestStart > successor.cpmData.earlyStart) {
                                successor.cpmData.earlyStart = earliestStart;
                                successor.cpmData.earlyFinish = earliestStart + (successor.duration || 2);
                            }
                            
                            // Check if all predecessors have been processed
                            const predList = predecessors.get(succ.id) || [];
                            const allPredsVisited = predList.every(p => visited.has(p.id));
                            
                            if (allPredsVisited && !visited.has(succ.id)) {
                                queue.push(successor);
                            }
                        });
                    }
                    
                    // Find project completion time (maximum EF)
                    let projectDuration = 0;
                    events.forEach(event => {
                        if (event.cpmData.earlyFinish > projectDuration) {
                            projectDuration = event.cpmData.earlyFinish;
                        }
                    });
                    
                    // BACKWARD PASS - Calculate Late Start (LS) and Late Finish (LF)
                    console.log('üìâ Backward Pass: Calculating LS and LF...');
                    
                    // Find tasks with no successors (end nodes)
                    const endNodes = events.filter(e => successors.get(e.id).length === 0);
                    
                    // Initialize late finish for end nodes
                    endNodes.forEach(node => {
                        node.cpmData.lateFinish = projectDuration;
                        node.cpmData.lateStart = projectDuration - (node.duration || 2);
                    });
                    
                    // Process backwards through the network
                    const backwardQueue = [...endNodes];
                    const backwardVisited = new Set();
                    
                    while (backwardQueue.length > 0) {
                        const current = backwardQueue.shift();
                        if (backwardVisited.has(current.id)) continue;
                        
                        backwardVisited.add(current.id);
                        const currentPredecessors = predecessors.get(current.id) || [];
                        
                        currentPredecessors.forEach(pred => {
                            const predecessor = eventMap.get(pred.id);
                            if (!predecessor) return;
                            
                            // Calculate latest finish for predecessor
                            let latestFinish = current.cpmData.lateStart - pred.lag;
                            
                            // Update predecessor's late finish if this path requires an earlier finish
                            if (latestFinish < predecessor.cpmData.lateFinish) {
                                predecessor.cpmData.lateFinish = latestFinish;
                                predecessor.cpmData.lateStart = latestFinish - (predecessor.duration || 2);
                            }
                            
                            // Check if all successors have been processed
                            const succList = successors.get(pred.id) || [];
                            const allSuccsVisited = succList.every(s => backwardVisited.has(s.id));
                            
                            if (allSuccsVisited && !backwardVisited.has(pred.id)) {
                                backwardQueue.push(predecessor);
                            }
                        });
                    }
                    
                    // CALCULATE SLACK VALUES
                    console.log('üîÑ Calculating Slack Values...');
                    
                    let criticalCount = 0;
                    let nearCriticalCount = 0;
                    let totalSlack = 0;
                    let nonCriticalCount = 0;
                    
                    events.forEach(event => {
                        // Total Slack = LS - ES (or LF - EF)
                        event.cpmData.totalSlack = event.cpmData.lateStart - event.cpmData.earlyStart;
                        
                        // Free Slack = Min(successor ES) - EF
                        const eventSuccessors = successors.get(event.id) || [];
                        if (eventSuccessors.length > 0) {
                            let minSuccessorES = Infinity;
                            eventSuccessors.forEach(succ => {
                                const successor = eventMap.get(succ.id);
                                if (successor && successor.cpmData.earlyStart < minSuccessorES) {
                                    minSuccessorES = successor.cpmData.earlyStart;
                                }
                            });
                            event.cpmData.freeSlack = minSuccessorES - event.cpmData.earlyFinish;
                        } else {
                            // No successors, free slack equals total slack
                            event.cpmData.freeSlack = event.cpmData.totalSlack;
                        }
                        
                        // Mark critical and near-critical tasks
                        const SLACK_THRESHOLD = 2; // Hours - tasks with less than 2 hours slack are near-critical
                        
                        if (Math.abs(event.cpmData.totalSlack) < 0.01) { // Essentially zero (accounting for float precision)
                            event.cpmData.isCritical = true;
                            criticalCount++;
                        } else if (event.cpmData.totalSlack < SLACK_THRESHOLD) {
                            event.cpmData.isNearCritical = true;
                            nearCriticalCount++;
                            totalSlack += event.cpmData.totalSlack;
                            nonCriticalCount++;
                        } else {
                            totalSlack += event.cpmData.totalSlack;
                            nonCriticalCount++;
                        }
                    });
                    
                    // APPLY VISUALIZATION
                    console.log('üé® Applying CPM Visualization...');
                    
                    events.forEach(event => {
                        // Skip manually positioned events for visualization changes
                        if (event.manuallyScheduled) {
                            console.log(`üîí Preserving manual position for: ${event.name}`);
                            return;
                        }
                        
                        // Apply visual styling based on criticality
                        if (event.cpmData.isCritical) {
                            event.cls = 'critical-path-task';
                            event.eventColor = '#dc2626'; // Red for critical
                        } else if (event.cpmData.isNearCritical) {
                            event.cls = 'near-critical-task';
                            event.eventColor = '#f59e0b'; // Orange for near-critical
                        } else {
                            event.cls = 'high-slack-task';
                            // Use green gradient based on slack amount
                            const slackRatio = Math.min(event.cpmData.totalSlack / 10, 1); // Normalize to 0-1
                            const greenIntensity = Math.round(100 + slackRatio * 155); // 100-255
                            event.eventColor = `rgb(34, ${greenIntensity}, 94)`;
                        }
                    });
                    
                    // Update dependency visualization
                    dependencies.forEach(dep => {
                        const fromEvent = eventMap.get(dep.from);
                        const toEvent = eventMap.get(dep.to);
                        
                        if (fromEvent?.cpmData.isCritical && toEvent?.cpmData.isCritical) {
                            dep.cls = 'critical-path';
                        } else if (fromEvent?.cpmData.isNearCritical || toEvent?.cpmData.isNearCritical) {
                            dep.cls = 'near-critical';
                        } else {
                            dep.cls = '';
                        }
                    });
                    
                    // CREATE METRICS PANEL
                    updateCPMMetricsPanel({
                        projectDuration: projectDuration,
                        criticalCount: criticalCount,
                        nearCriticalCount: nearCriticalCount,
                        averageSlack: nonCriticalCount > 0 ? (totalSlack / nonCriticalCount).toFixed(2) : 0,
                        totalOperations: events.length
                    });
                    
                    // LOG RESULTS
                    console.log('‚úÖ Critical Path Analysis Complete:');
                    console.log(`   üìä Project Duration: ${projectDuration.toFixed(1)} hours`);
                    console.log(`   üî¥ Critical Operations: ${criticalCount}`);
                    console.log(`   üü° Near-Critical Operations: ${nearCriticalCount}`);
                    console.log(`   üü¢ Non-Critical Operations: ${events.length - criticalCount - nearCriticalCount}`);
                    console.log(`   üìà Average Slack (non-critical): ${nonCriticalCount > 0 ? (totalSlack / nonCriticalCount).toFixed(2) : 0} hours`);
                    
                    // List critical path
                    const criticalPath = events
                        .filter(e => e.cpmData.isCritical)
                        .sort((a, b) => a.cpmData.earlyStart - b.cpmData.earlyStart);
                    
                    if (criticalPath.length > 0) {
                        console.log('\nüéØ Critical Path:');
                        criticalPath.forEach((task, idx) => {
                            console.log(`   ${idx + 1}. ${task.name} (ES: ${task.cpmData.earlyStart.toFixed(1)}h, Duration: ${task.duration || 2}h)`);
                        });
                    }
                    
                    // Refresh scheduler and save
                    await scheduler.project.commitAsync();
                    scheduler.refresh();
                    
                    // Save with CPM data
                    await saveSchedule();
                    
                    showNotification(`‚úÖ CPM Analysis Complete: ${criticalCount} critical operations identified`, 'success');
                }
                
                // Wrapper for backward compatibility
                async function criticalPathScheduling() {
                    await applyCriticalPathMethod();
                }
                
                // Helper function to show notifications
                function showNotification(message, type = 'info') {
                    const colors = {
                        success: '#10b981',
                        error: '#dc2626',
                        warning: '#f59e0b',
                        info: '#3b82f6'
                    };
                    
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: white;
                        color: ${colors[type]};
                        padding: 12px 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                        z-index: 10000;
                        font-weight: 500;
                        border-left: 4px solid ${colors[type]};
                        animation: slideIn 0.3s ease-out;
                        max-width: 400px;
                    `;
                    notification.textContent = message;
                    
                    document.body.appendChild(notification);
                    
                    setTimeout(() => {
                        notification.style.animation = 'slideOut 0.3s ease-in';
                        setTimeout(() => notification.remove(), 300);
                    }, 3000);
                }
                
                // Helper function to update CPM metrics panel
                function updateCPMMetricsPanel(metrics) {
                    // Remove existing panel if any
                    const existingPanel = document.querySelector('.cpm-metrics-panel');
                    if (existingPanel) {
                        existingPanel.remove();
                    }
                    
                    // Create new metrics panel
                    const panel = document.createElement('div');
                    panel.className = 'cpm-metrics-panel';
                    panel.innerHTML = `
                        <div class="cpm-metrics-title">CPM Analysis</div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Project Duration:</span>
                            <span class="cpm-metric-value">${metrics.projectDuration.toFixed(1)}h</span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Critical Ops:</span>
                            <span class="cpm-metric-value critical">${metrics.criticalCount}</span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Near-Critical:</span>
                            <span class="cpm-metric-value" style="color: #f59e0b;">${metrics.nearCriticalCount}</span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Avg Slack:</span>
                            <span class="cpm-metric-value">${metrics.averageSlack}h</span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Total Ops:</span>
                            <span class="cpm-metric-value">${metrics.totalOperations}</span>
                        </div>
                    `;
                    
                    // Add to scheduler container
                    const schedulerContainer = document.querySelector('.scheduler-container');
                    if (schedulerContainer) {
                        schedulerContainer.appendChild(panel);
                    }
                }
                
                async function levelResourcesScheduling() {
                    // Enhanced Resource Leveling Algorithm with CPM integration
                    console.log('‚öñÔ∏è Starting Enhanced Resource Leveling Algorithm...');
                    currentSchedulingMode = 'Level Resources';
                    
                    const project = scheduler.project;
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    const resources = [...scheduler.resourceStore.records].filter(r => r.id !== 'unscheduled');
                    const dependencies = scheduler.dependencyStore.records;
                    
                    if (events.length === 0 || resources.length === 0) {
                        showNotification('No operations or resources to level', 'warning');
                        return;
                    }
                    
                    // Initialize metrics tracking
                    const metrics = {
                        initialConflicts: 0,
                        resolvedConflicts: 0,
                        operationsMoved: 0,
                        maxUtilization: 0,
                        efficiencyScore: 0,
                        iterations: 0
                    };
                    
                    // Step 1: Calculate Critical Path and Slack for all operations
                    console.log('Step 1: Calculating Critical Path and Slack...');
                    const cpmAnalysis = await calculateCPMAnalysis(events, dependencies);
                    
                    // Step 2: Build resource utilization profile
                    console.log('Step 2: Building resource utilization profile...');
                    const utilizationProfile = buildResourceUtilizationProfile(events, resources);
                    
                    // Step 3: Identify overallocations
                    console.log('Step 3: Identifying resource overallocations...');
                    const overallocations = identifyOverallocations(utilizationProfile, resources);
                    metrics.initialConflicts = overallocations.length;
                    
                    console.log(`Found ${overallocations.length} overallocation periods`);
                    
                    // Step 4: Resolve conflicts through iterative leveling
                    console.log('Step 4: Resolving resource conflicts...');
                    const maxIterations = 50; // Prevent infinite loops
                    let currentOverallocations = [...overallocations];
                    
                    while (currentOverallocations.length > 0 && metrics.iterations < maxIterations) {
                        metrics.iterations++;
                        console.log(`Iteration ${metrics.iterations}: ${currentOverallocations.length} conflicts remaining`);
                        
                        let movesThisIteration = 0;
                        
                        for (const conflict of currentOverallocations) {
                            // Find movable operations in this conflict
                            const movableOps = findMovableOperations(
                                conflict.operations,
                                cpmAnalysis,
                                events
                            );
                            
                            if (movableOps.length === 0) continue;
                            
                            // Try to move operations to resolve conflict
                            for (const operation of movableOps) {
                                const newTimeSlot = findBestTimeSlot(
                                    operation,
                                    conflict.resourceId,
                                    utilizationProfile,
                                    resources,
                                    dependencies
                                );
                                
                                if (newTimeSlot && newTimeSlot.start !== operation.startDate) {
                                    // Move the operation
                                    moveOperation(operation, newTimeSlot);
                                    metrics.operationsMoved++;
                                    movesThisIteration++;
                                    
                                    // Mark operation as moved for visualization
                                    operation.cls = (operation.cls || '') + ' resource-leveled';
                                    operation.data = operation.data || {};
                                    operation.data.wasLeveled = true;
                                    operation.data.originalStart = operation.startDate;
                                    
                                    console.log(`  Moved ${operation.name} to ${newTimeSlot.start.toLocaleString()}`);
                                    
                                    // Rebuild utilization profile after move
                                    utilizationProfile[conflict.resourceId] = buildResourceUtilizationForResource(
                                        events.filter(e => e.resourceId === conflict.resourceId),
                                        conflict.resourceId
                                    );
                                    
                                    break; // Move one operation per conflict per iteration
                                }
                            }
                        }
                        
                        if (movesThisIteration === 0) {
                            console.log('No more moves possible, stopping iteration');
                            break;
                        }
                        
                        // Recalculate overallocations
                        currentOverallocations = identifyOverallocations(utilizationProfile, resources);
                        metrics.resolvedConflicts = metrics.initialConflicts - currentOverallocations.length;
                    }
                    
                    // Step 5: Calculate final metrics
                    console.log('Step 5: Calculating final metrics...');
                    metrics.maxUtilization = calculateMaxUtilization(utilizationProfile, resources);
                    metrics.efficiencyScore = calculateEfficiencyScore(events, resources, utilizationProfile);
                    
                    // Step 6: Display results
                    displayResourceLevelingResults(metrics, utilizationProfile, resources);
                    
                    // Step 7: Create utilization visualization
                    createUtilizationVisualization(utilizationProfile, resources);
                    
                    // Commit changes
                    await project.commitAsync();
                    scheduler.refresh();
                    
                    console.log(`‚úÖ Resource Leveling completed:
                        - Initial conflicts: ${metrics.initialConflicts}
                        - Resolved conflicts: ${metrics.resolvedConflicts}
                        - Operations moved: ${metrics.operationsMoved}
                        - Max utilization: ${metrics.maxUtilization.toFixed(1)}%
                        - Efficiency score: ${metrics.efficiencyScore.toFixed(1)}%
                        - Iterations: ${metrics.iterations}`);
                    
                    await saveSchedule();
                }
                
                // Helper functions for Resource Leveling
                function calculateCPMAnalysis(events, dependencies) {
                    const analysis = new Map();
                    
                    // Initialize CPM data for each event
                    events.forEach(event => {
                        analysis.set(event.id, {
                            earlyStart: 0,
                            earlyFinish: 0,
                            lateStart: Infinity,
                            lateFinish: Infinity,
                            totalSlack: 0,
                            freeSlack: 0,
                            isCritical: false,
                            isManuallyScheduled: event.manuallyScheduled || false,
                            priority: event.priority || 5,
                            duration: event.duration || 2
                        });
                    });
                    
                    // Build dependency graph
                    const successors = new Map();
                    const predecessors = new Map();
                    
                    events.forEach(event => {
                        successors.set(event.id, []);
                        predecessors.set(event.id, []);
                    });
                    
                    dependencies.forEach(dep => {
                        if (successors.has(dep.from) && predecessors.has(dep.to)) {
                            successors.get(dep.from).push(dep.to);
                            predecessors.get(dep.to).push(dep.from);
                        }
                    });
                    
                    // Forward pass - calculate early start/finish
                    const visited = new Set();
                    const queue = events.filter(e => predecessors.get(e.id).length === 0);
                    
                    while (queue.length > 0) {
                        const event = queue.shift();
                        if (visited.has(event.id)) continue;
                        
                        const data = analysis.get(event.id);
                        const preds = predecessors.get(event.id);
                        
                        if (preds.length > 0) {
                            let maxEarlyFinish = 0;
                            preds.forEach(predId => {
                                const predData = analysis.get(predId);
                                if (predData) {
                                    maxEarlyFinish = Math.max(maxEarlyFinish, predData.earlyFinish);
                                }
                            });
                            data.earlyStart = maxEarlyFinish;
                        }
                        
                        data.earlyFinish = data.earlyStart + data.duration;
                        visited.add(event.id);
                        
                        // Add successors to queue
                        successors.get(event.id).forEach(succId => {
                            const succ = events.find(e => e.id === succId);
                            if (succ && !visited.has(succId)) {
                                queue.push(succ);
                            }
                        });
                    }
                    
                    // Calculate project duration
                    let projectDuration = 0;
                    analysis.forEach(data => {
                        projectDuration = Math.max(projectDuration, data.earlyFinish);
                    });
                    
                    // Backward pass - calculate late start/finish
                    visited.clear();
                    const reverseQueue = events.filter(e => successors.get(e.id).length === 0);
                    
                    // Initialize leaf nodes
                    reverseQueue.forEach(event => {
                        const data = analysis.get(event.id);
                        data.lateFinish = projectDuration;
                        data.lateStart = data.lateFinish - data.duration;
                    });
                    
                    while (reverseQueue.length > 0) {
                        const event = reverseQueue.shift();
                        if (visited.has(event.id)) continue;
                        
                        const data = analysis.get(event.id);
                        const preds = predecessors.get(event.id);
                        
                        visited.add(event.id);
                        
                        // Process predecessors
                        preds.forEach(predId => {
                            const predData = analysis.get(predId);
                            if (predData) {
                                predData.lateFinish = Math.min(predData.lateFinish, data.lateStart);
                                predData.lateStart = predData.lateFinish - predData.duration;
                                
                                const pred = events.find(e => e.id === predId);
                                if (pred && !visited.has(predId)) {
                                    reverseQueue.push(pred);
                                }
                            }
                        });
                    }
                    
                    // Calculate slack and identify critical path
                    analysis.forEach((data, eventId) => {
                        data.totalSlack = data.lateStart - data.earlyStart;
                        data.isCritical = Math.abs(data.totalSlack) < 0.01;
                    });
                    
                    return analysis;
                }
                
                function buildResourceUtilizationProfile(events, resources) {
                    const profile = {};
                    
                    resources.forEach(resource => {
                        profile[resource.id] = buildResourceUtilizationForResource(
                            events.filter(e => e.resourceId === resource.id),
                            resource.id
                        );
                    });
                    
                    return profile;
                }
                
                function buildResourceUtilizationForResource(resourceEvents, resourceId) {
                    const utilization = new Map();
                    const hourlySlots = new Map();
                    
                    resourceEvents.forEach(event => {
                        if (!event.startDate || !event.endDate) return;
                        
                        let currentTime = new Date(event.startDate);
                        const endTime = new Date(event.endDate);
                        
                        while (currentTime < endTime) {
                            const hourKey = getHourKey(currentTime);
                            
                            if (!hourlySlots.has(hourKey)) {
                                hourlySlots.set(hourKey, []);
                            }
                            
                            hourlySlots.get(hourKey).push(event);
                            currentTime.setHours(currentTime.getHours() + 1);
                        }
                    });
                    
                    return hourlySlots;
                }
                
                function getHourKey(date) {
                    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}_${String(date.getHours()).padStart(2, '0')}`;
                }
                
                function identifyOverallocations(utilizationProfile, resources) {
                    const overallocations = [];
                    
                    Object.entries(utilizationProfile).forEach(([resourceId, hourlySlots]) => {
                        const resource = resources.find(r => r.id == resourceId);
                        const capacity = resource?.capacity || 1;
                        
                        hourlySlots.forEach((operations, hourKey) => {
                            if (operations.length > capacity) {
                                overallocations.push({
                                    resourceId: resourceId,
                                    hourKey: hourKey,
                                    operations: operations,
                                    overallocation: operations.length - capacity,
                                    capacity: capacity
                                });
                            }
                        });
                    });
                    
                    return overallocations;
                }
                
                function findMovableOperations(operations, cpmAnalysis, allEvents) {
                    // Sort operations by movability criteria
                    return operations
                        .filter(op => {
                            const cpmData = cpmAnalysis.get(op.id);
                            // Don't move critical path operations or manually scheduled ones
                            return cpmData && !cpmData.isCritical && !cpmData.isManuallyScheduled;
                        })
                        .sort((a, b) => {
                            const aData = cpmAnalysis.get(a.id);
                            const bData = cpmAnalysis.get(b.id);
                            
                            // Sort by: 1) Total slack (more slack = more movable)
                            //          2) Priority (lower priority = more movable)
                            //          3) Duration (shorter = easier to fit elsewhere)
                            
                            if (aData.totalSlack !== bData.totalSlack) {
                                return bData.totalSlack - aData.totalSlack; // More slack first
                            }
                            if (aData.priority !== bData.priority) {
                                return bData.priority - aData.priority; // Lower priority first
                            }
                            return aData.duration - bData.duration; // Shorter duration first
                        });
                }
                
                function findBestTimeSlot(operation, resourceId, utilizationProfile, resources, dependencies) {
                    const resource = resources.find(r => r.id == resourceId);
                    const capacity = resource?.capacity || 1;
                    const resourceUtilization = utilizationProfile[resourceId];
                    
                    // Define search window based on operation's slack
                    const cpmData = window.scheduler.cpmAnalysis?.get(operation.id);
                    const earliestStart = operation.startDate;
                    const latestStart = new Date(earliestStart.getTime() + (cpmData?.totalSlack || 0) * 60 * 60 * 1000);
                    
                    // Find a time slot with available capacity
                    let bestSlot = null;
                    let minConflicts = Infinity;
                    
                    // Try different start times within the allowed window
                    const testTime = new Date(earliestStart);
                    const duration = operation.duration || 2;
                    
                    while (testTime <= latestStart) {
                        // Check if this time slot has capacity
                        let conflicts = 0;
                        let canFit = true;
                        
                        for (let h = 0; h < duration; h++) {
                            const checkTime = new Date(testTime.getTime() + h * 60 * 60 * 1000);
                            const hourKey = getHourKey(checkTime);
                            const existingOps = resourceUtilization.get(hourKey) || [];
                            
                            if (existingOps.filter(op => op.id !== operation.id).length >= capacity) {
                                canFit = false;
                                conflicts++;
                            }
                        }
                        
                        if (canFit) {
                            // Found a slot with capacity
                            bestSlot = {
                                start: new Date(testTime),
                                end: new Date(testTime.getTime() + duration * 60 * 60 * 1000)
                            };
                            break;
                        } else if (conflicts < minConflicts) {
                            // Track best partial fit if no perfect slot found
                            minConflicts = conflicts;
                            bestSlot = {
                                start: new Date(testTime),
                                end: new Date(testTime.getTime() + duration * 60 * 60 * 1000)
                            };
                        }
                        
                        // Move to next hour
                        testTime.setHours(testTime.getHours() + 1);
                    }
                    
                    return bestSlot;
                }
                
                function moveOperation(operation, newTimeSlot) {
                    operation.startDate = newTimeSlot.start;
                    operation.endDate = newTimeSlot.end;
                }
                
                function calculateMaxUtilization(utilizationProfile, resources) {
                    let maxUtilization = 0;
                    
                    Object.entries(utilizationProfile).forEach(([resourceId, hourlySlots]) => {
                        const resource = resources.find(r => r.id == resourceId);
                        const capacity = resource?.capacity || 1;
                        
                        hourlySlots.forEach(operations => {
                            const utilization = (operations.length / capacity) * 100;
                            maxUtilization = Math.max(maxUtilization, utilization);
                        });
                    });
                    
                    return Math.min(maxUtilization, 100);
                }
                
                function calculateEfficiencyScore(events, resources, utilizationProfile) {
                    let totalUsedSlots = 0;
                    let totalAvailableSlots = 0;
                    
                    // Calculate time span of schedule
                    let minStart = null;
                    let maxEnd = null;
                    
                    events.forEach(event => {
                        if (event.startDate) {
                            if (!minStart || event.startDate < minStart) {
                                minStart = event.startDate;
                            }
                        }
                        if (event.endDate) {
                            if (!maxEnd || event.endDate > maxEnd) {
                                maxEnd = event.endDate;
                            }
                        }
                    });
                    
                    if (!minStart || !maxEnd) return 0;
                    
                    const totalHours = Math.ceil((maxEnd - minStart) / (1000 * 60 * 60));
                    totalAvailableSlots = totalHours * resources.length;
                    
                    Object.values(utilizationProfile).forEach(hourlySlots => {
                        hourlySlots.forEach(operations => {
                            totalUsedSlots += Math.min(operations.length, 1);
                        });
                    });
                    
                    return totalAvailableSlots > 0 ? (totalUsedSlots / totalAvailableSlots) * 100 : 0;
                }
                
                function displayResourceLevelingResults(metrics, utilizationProfile, resources) {
                    // Remove existing panel if any
                    const existingPanel = document.querySelector('.resource-leveling-panel');
                    if (existingPanel) {
                        existingPanel.remove();
                    }
                    
                    // Create metrics panel
                    const panel = document.createElement('div');
                    panel.className = 'resource-leveling-panel';
                    panel.style.cssText = `
                        position: absolute;
                        top: 10px;
                        left: 10px;
                        background: rgba(255, 255, 255, 0.95);
                        border: 1px solid #e0e0e0;
                        border-radius: 8px;
                        padding: 12px;
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                        font-size: 0.875rem;
                        z-index: 100;
                        min-width: 250px;
                    `;
                    
                    panel.innerHTML = `
                        <div style="font-weight: bold; color: #333; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid #e0e0e0;">
                            Resource Leveling Results
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #666;">Initial Conflicts:</span>
                            <span style="font-weight: 600; color: #dc2626;">${metrics.initialConflicts}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #666;">Resolved:</span>
                            <span style="font-weight: 600; color: #10b981;">${metrics.resolvedConflicts}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #666;">Operations Moved:</span>
                            <span style="font-weight: 600; color: #333;">${metrics.operationsMoved}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #666;">Max Utilization:</span>
                            <span style="font-weight: 600; color: ${metrics.maxUtilization > 90 ? '#dc2626' : '#333'};">${metrics.maxUtilization.toFixed(1)}%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #666;">Efficiency:</span>
                            <span style="font-weight: 600; color: #333;">${metrics.efficiencyScore.toFixed(1)}%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #666;">Iterations:</span>
                            <span style="font-weight: 600; color: #333;">${metrics.iterations}</span>
                        </div>
                    `;
                    
                    const schedulerContainer = document.querySelector('.scheduler-container');
                    if (schedulerContainer) {
                        schedulerContainer.appendChild(panel);
                    }
                    
                    // Auto-hide after 10 seconds
                    setTimeout(() => {
                        panel.style.transition = 'opacity 0.5s';
                        panel.style.opacity = '0';
                        setTimeout(() => panel.remove(), 500);
                    }, 10000);
                }
                
                function createUtilizationVisualization(utilizationProfile, resources) {
                    // Remove existing visualization if any
                    const existingViz = document.querySelector('.resource-utilization-chart');
                    if (existingViz) {
                        existingViz.remove();
                    }
                    
                    // Create utilization chart container
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'resource-utilization-chart';
                    chartContainer.style.cssText = `
                        position: absolute;
                        bottom: 10px;
                        left: 10px;
                        right: 10px;
                        height: 120px;
                        background: rgba(255, 255, 255, 0.95);
                        border: 1px solid #e0e0e0;
                        border-radius: 8px;
                        padding: 10px;
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                        z-index: 100;
                        display: flex;
                        flex-direction: column;
                    `;
                    
                    // Create chart header
                    const header = document.createElement('div');
                    header.style.cssText = 'font-weight: bold; font-size: 0.875rem; margin-bottom: 10px;';
                    header.textContent = 'Resource Utilization Timeline';
                    chartContainer.appendChild(header);
                    
                    // Create chart area
                    const chartArea = document.createElement('div');
                    chartArea.style.cssText = 'flex: 1; display: flex; gap: 8px; overflow-x: auto;';
                    
                    // Create bars for each resource
                    resources.forEach(resource => {
                        const resourceBar = document.createElement('div');
                        resourceBar.style.cssText = 'display: flex; flex-direction: column; min-width: 100px;';
                        
                        const label = document.createElement('div');
                        label.style.cssText = 'font-size: 0.75rem; color: #666; margin-bottom: 4px; white-space: nowrap;';
                        label.textContent = resource.name;
                        resourceBar.appendChild(label);
                        
                        const bar = document.createElement('div');
                        bar.style.cssText = 'flex: 1; background: #e0e0e0; border-radius: 4px; position: relative; overflow: hidden;';
                        
                        // Calculate utilization percentage for this resource
                        const resourceUtilization = utilizationProfile[resource.id];
                        if (resourceUtilization) {
                            const capacity = resource.capacity || 1;
                            let totalUtilization = 0;
                            let slots = 0;
                            
                            resourceUtilization.forEach(operations => {
                                totalUtilization += Math.min((operations.length / capacity) * 100, 100);
                                slots++;
                            });
                            
                            const avgUtilization = slots > 0 ? totalUtilization / slots : 0;
                            
                            // Create utilization fill
                            const fill = document.createElement('div');
                            fill.style.cssText = `
                                position: absolute;
                                bottom: 0;
                                left: 0;
                                right: 0;
                                height: ${avgUtilization}%;
                                background: ${avgUtilization > 90 ? '#dc2626' : avgUtilization > 70 ? '#f59e0b' : '#10b981'};
                                transition: height 0.3s;
                            `;
                            bar.appendChild(fill);
                            
                            // Add percentage label
                            const percentLabel = document.createElement('div');
                            percentLabel.style.cssText = `
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                font-size: 0.75rem;
                                font-weight: bold;
                                color: ${avgUtilization > 50 ? 'white' : '#333'};
                            `;
                            percentLabel.textContent = `${avgUtilization.toFixed(0)}%`;
                            bar.appendChild(percentLabel);
                        }
                        
                        resourceBar.appendChild(bar);
                        chartArea.appendChild(resourceBar);
                    });
                    
                    chartContainer.appendChild(chartArea);
                    
                    // Add close button
                    const closeBtn = document.createElement('button');
                    closeBtn.style.cssText = `
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: transparent;
                        border: none;
                        font-size: 1.2rem;
                        cursor: pointer;
                        color: #666;
                    `;
                    closeBtn.textContent = '√ó';
                    closeBtn.onclick = () => chartContainer.remove();
                    chartContainer.appendChild(closeBtn);
                    
                    const schedulerContainer = document.querySelector('.scheduler-container');
                    if (schedulerContainer) {
                        schedulerContainer.appendChild(chartContainer);
                    }
                    
                    // Auto-hide after 15 seconds
                    setTimeout(() => {
                        chartContainer.style.transition = 'opacity 0.5s';
                        chartContainer.style.opacity = '0';
                        setTimeout(() => chartContainer.remove(), 500);
                    }, 15000);
                }
                
                // Comprehensive Theory of Constraints DBR Implementation
                async function dbrScheduling() {
                    console.log('ü•Å Starting Theory of Constraints (DBR) Scheduling...');
                    currentSchedulingMode = 'DBR/TOC';
                    
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    const resources = [...scheduler.resourceStore.records].filter(r => r.id !== 'unscheduled');
                    
                    if (events.length === 0) {
                        console.warn('No events to schedule');
                        return;
                    }
                    
                    // =======================================
                    // DRUM: Identify and Schedule the Constraint
                    // =======================================
                    
                    // Calculate resource utilization
                    const resourceUtilization = {};
                    const resourceOperations = {};
                    const totalTimeAvailable = 24 * 5; // 5 days * 24 hours for calculation
                    
                    resources.forEach(resource => {
                        resourceUtilization[resource.id] = {
                            resourceId: resource.id,
                            resourceName: resource.name,
                            totalDuration: 0,
                            operationCount: 0,
                            utilization: 0,
                            operations: []
                        };
                        resourceOperations[resource.id] = [];
                    });
                    
                    // Calculate total duration per resource
                    events.forEach(event => {
                        if (resourceUtilization[event.resourceId]) {
                            resourceUtilization[event.resourceId].totalDuration += event.duration || 0;
                            resourceUtilization[event.resourceId].operationCount += 1;
                            resourceUtilization[event.resourceId].operations.push(event);
                            resourceOperations[event.resourceId].push(event);
                        }
                    });
                    
                    // Calculate utilization percentage and identify bottleneck
                    let bottleneck = null;
                    let maxUtilization = 0;
                    
                    Object.values(resourceUtilization).forEach(util => {
                        util.utilization = (util.totalDuration / totalTimeAvailable) * 100;
                        if (util.utilization > maxUtilization) {
                            maxUtilization = util.utilization;
                            bottleneck = util;
                        }
                    });
                    
                    if (!bottleneck) {
                        console.error('Could not identify bottleneck');
                        return;
                    }
                    
                    console.log(`üî¥ Bottleneck Identified: ${bottleneck.resourceName}`);
                    console.log(`   Utilization: ${bottleneck.utilization.toFixed(1)}%`);
                    console.log(`   Total Load: ${bottleneck.totalDuration.toFixed(1)}h`);
                    console.log(`   Operations: ${bottleneck.operationCount}`);
                    
                    // Schedule the bottleneck (DRUM) for maximum throughput
                    const baseDate = new Date(2025, 8, 3, 7, 0, 0); // Sept 3, 2025, 7 AM
                    let drumTime = new Date(baseDate);
                    
                    // Sort bottleneck operations by priority (can be customized)
                    // For now, sort by duration (longest first) for better throughput
                    const bottleneckOps = bottleneck.operations.sort((a, b) => b.duration - a.duration);
                    
                    bottleneckOps.forEach(event => {
                        event.startDate = new Date(drumTime);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        
                        // Add small buffer between operations on bottleneck (5 minutes)
                        drumTime = new Date(event.endDate.getTime() + 5 * 60 * 1000);
                        
                        // Mark as bottleneck operation for visual styling
                        event.cls = (event.cls || '') + ' bottleneck-operation';
                        event.iconCls = 'b-icon b-icon-drum'; // Drum icon
                    });
                    
                    // =======================================
                    // BUFFER: Add Time Buffers
                    // =======================================
                    
                    // Calculate buffer times (25-50% of lead time)
                    const bufferPercentage = 0.35; // 35% buffer initially
                    
                    // Group events by type for buffer management
                    const shippingEvents = [];
                    const constraintFeederEvents = [];
                    const assemblyEvents = [];
                    const otherEvents = [];
                    
                    events.forEach(event => {
                        if (event.resourceId === bottleneck.resourceId) {
                            // Skip bottleneck operations (already scheduled)
                            return;
                        }
                        
                        const eventName = (event.name || '').toLowerCase();
                        
                        if (eventName.includes('packag') || eventName.includes('ship')) {
                            shippingEvents.push(event);
                        } else if (eventName.includes('assembl') || eventName.includes('final')) {
                            assemblyEvents.push(event);
                        } else if (hasDownstreamDependency(event, bottleneckOps)) {
                            constraintFeederEvents.push(event);
                        } else {
                            otherEvents.push(event);
                        }
                    });
                    
                    // Helper function to check if event feeds into bottleneck
                    function hasDownstreamDependency(event, bottleneckOps) {
                        // Simplified check - in real implementation, check actual dependencies
                        return bottleneckOps.some(bOp => {
                            return event.jobId === bOp.jobId && event.sequenceNumber < bOp.sequenceNumber;
                        });
                    }
                    
                    // Add buffers and schedule non-bottleneck operations
                    const resourceSchedules = {};
                    
                    // Schedule constraint feeder operations with buffer
                    constraintFeederEvents.forEach(event => {
                        const bufferTime = event.duration * bufferPercentage;
                        const bufferMs = bufferTime * 60 * 60 * 1000;
                        
                        // Find corresponding bottleneck operation
                        const bottleneckOp = bottleneckOps.find(bOp => bOp.jobId === event.jobId);
                        if (bottleneckOp) {
                            // Schedule to complete with buffer before bottleneck needs it
                            const targetEnd = new Date(bottleneckOp.startDate.getTime() - bufferMs);
                            const durationMs = event.duration * 60 * 60 * 1000;
                            event.endDate = targetEnd;
                            event.startDate = new Date(targetEnd.getTime() - durationMs);
                            
                            // Calculate buffer consumption (for visualization)
                            const bufferConsumed = calculateBufferConsumption(event, bottleneckOp, bufferMs);
                            event.bufferZone = getBufferZone(bufferConsumed);
                            event.cls = (event.cls || '') + ' buffer-' + event.bufferZone;
                        }
                    });
                    
                    // Schedule shipping operations with shipping buffer
                    let shipTime = new Date(baseDate.getTime() + 48 * 60 * 60 * 1000); // Start shipping 2 days later
                    shippingEvents.forEach(event => {
                        const bufferTime = event.duration * bufferPercentage * 1.5; // Larger buffer for shipping
                        const bufferMs = bufferTime * 60 * 60 * 1000;
                        
                        event.startDate = new Date(shipTime);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        
                        // Add shipping buffer
                        shipTime = new Date(event.endDate.getTime() + bufferMs);
                        
                        event.bufferZone = 'green'; // Initially green
                        event.cls = (event.cls || '') + ' shipping-buffer buffer-green';
                    });
                    
                    // Schedule assembly operations with assembly buffer
                    assemblyEvents.forEach(event => {
                        if (!resourceSchedules[event.resourceId]) {
                            resourceSchedules[event.resourceId] = new Date(baseDate);
                        }
                        
                        const bufferTime = event.duration * bufferPercentage;
                        const bufferMs = bufferTime * 60 * 60 * 1000;
                        
                        event.startDate = new Date(resourceSchedules[event.resourceId]);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        
                        // Update resource schedule with buffer
                        resourceSchedules[event.resourceId] = new Date(event.endDate.getTime() + bufferMs);
                        
                        event.bufferZone = 'green';
                        event.cls = (event.cls || '') + ' assembly-buffer buffer-green';
                    });
                    
                    // =======================================
                    // ROPE: Control Material Release
                    // =======================================
                    
                    // Calculate material release dates (rope)
                    const materialReleases = {};
                    
                    events.forEach(event => {
                        if (!event.jobId) return;
                        
                        if (!materialReleases[event.jobId]) {
                            materialReleases[event.jobId] = {
                                jobId: event.jobId,
                                jobName: event.jobName,
                                operations: [],
                                constraintDate: null,
                                bufferTime: 0,
                                processingTime: 0,
                                releaseDate: null
                            };
                        }
                        
                        materialReleases[event.jobId].operations.push(event);
                        
                        // If this is a bottleneck operation, mark constraint date
                        if (event.resourceId === bottleneck.resourceId) {
                            materialReleases[event.jobId].constraintDate = event.startDate;
                        }
                        
                        materialReleases[event.jobId].processingTime += event.duration;
                    });
                    
                    // Calculate release dates
                    Object.values(materialReleases).forEach(release => {
                        if (release.constraintDate) {
                            // Rope calculation: Release = Constraint - Buffer - Processing
                            const bufferTime = release.processingTime * bufferPercentage;
                            const totalLeadTime = (release.processingTime + bufferTime) * 60 * 60 * 1000;
                            
                            release.releaseDate = new Date(release.constraintDate.getTime() - totalLeadTime);
                            release.bufferTime = bufferTime;
                            
                            // Apply release date to first operation of job
                            const firstOp = release.operations.sort((a, b) => 
                                (a.sequenceNumber || 0) - (b.sequenceNumber || 0))[0];
                            
                            if (firstOp && firstOp.startDate < release.releaseDate) {
                                // Delay release to prevent excess WIP
                                const delay = release.releaseDate.getTime() - firstOp.startDate.getTime();
                                release.operations.forEach(op => {
                                    op.startDate = new Date(op.startDate.getTime() + delay);
                                    op.endDate = new Date(op.endDate.getTime() + delay);
                                });
                            }
                        }
                    });
                    
                    // Schedule remaining operations
                    otherEvents.forEach(event => {
                        if (!resourceSchedules[event.resourceId]) {
                            resourceSchedules[event.resourceId] = new Date(baseDate);
                        }
                        
                        if (!event.startDate || event.startDate < resourceSchedules[event.resourceId]) {
                            event.startDate = new Date(resourceSchedules[event.resourceId]);
                            const durationMs = event.duration * 60 * 60 * 1000;
                            event.endDate = new Date(event.startDate.getTime() + durationMs);
                        }
                        
                        resourceSchedules[event.resourceId] = new Date(event.endDate.getTime() + 15 * 60 * 1000);
                    });
                    
                    // =======================================
                    // Visual Indicators & Metrics
                    // =======================================
                    
                    // Add visual classes to bottleneck resource
                    const bottleneckResource = scheduler.resourceStore.getById(bottleneck.resourceId);
                    if (bottleneckResource) {
                        bottleneckResource.cls = 'bottleneck-resource';
                        bottleneckResource.name = 'ü•Å ' + bottleneckResource.name + ' (BOTTLENECK)';
                    }
                    
                    // Create or update DBR metrics panel
                    updateDBRMetrics(bottleneck, resourceUtilization, materialReleases, events);
                    
                    // Commit changes
                    scheduler.eventStore.commit();
                    scheduler.resourceStore.commit();
                    
                    console.log('‚úÖ DBR Scheduling completed successfully');
                    console.log(`   Bottleneck: ${bottleneck.resourceName} (${bottleneck.utilization.toFixed(1)}%)`);
                    console.log(`   Material Releases: ${Object.keys(materialReleases).length} jobs`);
                    console.log(`   Buffered Operations: ${constraintFeederEvents.length + shippingEvents.length + assemblyEvents.length}`);
                    
                    // Save schedule
                    await saveSchedule();
                }
                
                // Helper function to calculate buffer consumption
                function calculateBufferConsumption(event, bottleneckOp, bufferMs) {
                    const actualGap = bottleneckOp.startDate.getTime() - event.endDate.getTime();
                    const consumption = ((bufferMs - actualGap) / bufferMs) * 100;
                    return Math.max(0, Math.min(100, consumption));
                }
                
                // Helper function to determine buffer zone
                function getBufferZone(consumption) {
                    if (consumption <= 33) return 'green';
                    if (consumption <= 66) return 'yellow';
                    return 'red';
                }
                
                // Function to update DBR metrics panel
                function updateDBRMetrics(bottleneck, utilization, releases, events) {
                    // Remove existing panel if any
                    const existingPanel = document.getElementById('dbr-metrics-panel');
                    if (existingPanel) {
                        existingPanel.remove();
                    }
                    
                    // Calculate metrics
                    const avgUtilization = Object.values(utilization).reduce((sum, u) => sum + u.utilization, 0) / Object.keys(utilization).length;
                    const wipBefore = events.length; // Simplified - all operations
                    const wipAfter = Object.keys(releases).length; // Jobs in progress
                    const reductionPct = ((wipBefore - wipAfter) / wipBefore * 100).toFixed(1);
                    
                    // Count operations by buffer zone
                    let greenCount = 0, yellowCount = 0, redCount = 0;
                    events.forEach(event => {
                        if (event.bufferZone === 'green') greenCount++;
                        else if (event.bufferZone === 'yellow') yellowCount++;
                        else if (event.bufferZone === 'red') redCount++;
                    });
                    
                    // Create metrics panel
                    const panel = document.createElement('div');
                    panel.id = 'dbr-metrics-panel';
                    panel.className = 'cpm-metrics-panel';
                    panel.style.cssText = 'position: absolute; top: 10px; right: 420px; background: rgba(255, 255, 255, 0.95); border: 2px solid #8b5cf6; min-width: 280px;';
                    panel.innerHTML = `
                        <div class="cpm-metrics-title" style="color: #8b5cf6; font-size: 14px; display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 20px;">ü•Å</span> DBR Metrics
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Bottleneck Resource:</span>
                            <span class="cpm-metric-value critical">${bottleneck.resourceName}</span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Bottleneck Utilization:</span>
                            <span class="cpm-metric-value" style="color: ${bottleneck.utilization > 80 ? '#dc2626' : '#333'};">${bottleneck.utilization.toFixed(1)}%</span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Avg Resource Utilization:</span>
                            <span class="cpm-metric-value">${avgUtilization.toFixed(1)}%</span>
                        </div>
                        <div class="cpm-metric" style="border-top: 1px solid #e0e0e0; padding-top: 4px; margin-top: 4px;">
                            <span class="cpm-metric-label">Buffer Zones:</span>
                            <span class="cpm-metric-value" style="font-size: 11px;">
                                <span style="color: #10b981;">‚óè${greenCount}</span>
                                <span style="color: #f59e0b;">‚óè${yellowCount}</span>
                                <span style="color: #dc2626;">‚óè${redCount}</span>
                            </span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">WIP Reduction:</span>
                            <span class="cpm-metric-value" style="color: #10b981;">${reductionPct}%</span>
                        </div>
                        <div class="cpm-metric">
                            <span class="cpm-metric-label">Active Jobs:</span>
                            <span class="cpm-metric-value">${wipAfter} / ${wipBefore}</span>
                        </div>
                        <div class="cpm-metric" style="border-top: 1px solid #e0e0e0; padding-top: 4px; margin-top: 4px;">
                            <span class="cpm-metric-label">Throughput Status:</span>
                            <span class="cpm-metric-value" style="color: #10b981;">Optimized ‚úì</span>
                        </div>
                    `;
                    
                    document.querySelector('.scheduler-container').appendChild(panel);
                    
                    // Auto-hide after 30 seconds
                    setTimeout(() => {
                        panel.style.transition = 'opacity 0.5s';
                        panel.style.opacity = '0';
                        setTimeout(() => panel.remove(), 500);
                    }, 30000);
                }
                
                async function drumScheduling() {
                    // Theory of Constraints - optimize around bottleneck
                    console.log('üöÄ Starting Drum (TOC) scheduling...');
                    currentSchedulingMode = 'Drum/TOC'; // Set mode for drag handler
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    
                    // Find bottleneck resource (most loaded)
                    const resourceLoad = {};
                    events.forEach(event => {
                        if (!resourceLoad[event.resourceId]) {
                            resourceLoad[event.resourceId] = 0;
                        }
                        resourceLoad[event.resourceId] += event.duration;
                    });
                    
                    let drumResourceId = null;
                    let maxLoad = 0;
                    Object.entries(resourceLoad).forEach(([resourceId, load]) => {
                        if (load > maxLoad) {
                            maxLoad = load;
                            drumResourceId = resourceId;
                        }
                    });
                    
                    if (!drumResourceId) {
                        console.log('‚ö†Ô∏è No bottleneck resource found');
                        return;
                    }
                    
                    const drumResource = scheduler.resourceStore.getById(drumResourceId);
                    console.log(`  Bottleneck (drum): ${drumResource?.name || drumResourceId} with ${maxLoad.toFixed(1)}h total load`);
                    
                    const baseDate = new Date(2025, 8, 3);
                    baseDate.setHours(7, 0, 0, 0);
                    
                    // Schedule drum resource optimally
                    const drumEvents = events.filter(e => e.resourceId === drumResourceId);
                    let drumTime = new Date(baseDate);
                    
                    drumEvents.sort((a, b) => b.duration - a.duration); // Longest first
                    
                    drumEvents.forEach(event => {
                        event.startDate = new Date(drumTime);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        drumTime = new Date(event.endDate.getTime() + 15 * 60 * 1000); // 15 min buffer for drum
                    });
                    
                    // Schedule feeding resources
                    const feedingEvents = events.filter(e => e.resourceId !== drumResourceId);
                    const resourceSchedules = {};
                    
                    feedingEvents.forEach(event => {
                        if (!resourceSchedules[event.resourceId]) {
                            const feedTime = new Date(baseDate);
                            feedTime.setHours(7, 0, 0, 0); // Same start time
                            resourceSchedules[event.resourceId] = feedTime;
                        }
                        
                        event.startDate = new Date(resourceSchedules[event.resourceId]);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        resourceSchedules[event.resourceId] = new Date(event.endDate.getTime() + 30 * 60 * 1000); // 30 min buffer
                    });
                    
                    scheduler.eventStore.commit();
                    console.log('‚úÖ Drum (TOC) scheduling completed');
                    
                    // VERIFY no overlaps
                    let overlapsFound = 0;
                    const allResourceEvents = {};
                    events.forEach(event => {
                        if (!allResourceEvents[event.resourceId]) {
                            allResourceEvents[event.resourceId] = [];
                        }
                        allResourceEvents[event.resourceId].push(event);
                    });
                    
                    Object.keys(allResourceEvents).forEach(resourceId => {
                        const resEvents = allResourceEvents[resourceId].sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < resEvents.length - 1; i++) {
                            if (resEvents[i].endDate > resEvents[i + 1].startDate) {
                                overlapsFound++;
                            }
                        }
                    });
                    if (overlapsFound === 0) {
                        console.log('‚úÖ Drum Verification passed');
                        await saveSchedule();
                    } else {
                        console.log(`‚ùå Drum FAILED: ${overlapsFound} overlaps`);
                    }
                }
                
                // Initialize status updates
                updateStatus();
                
                // CRITICAL DATA LOADING FIX: Load the events into the scheduler's event store
                // The events array was created but never actually loaded into the scheduler
                console.log('üìä Loading data into scheduler - resources:', resources.length, 'events:', events.length, 'dependencies:', dependencies.length);
                
                // Load the inline data into the scheduler project
                // CRITICAL: Bryntum requires specific property names ending with 'Data'
                await scheduler.project.loadInlineData({
                    resourcesData: resources,
                    eventsData: events,
                    assignmentsData: [],
                    dependenciesData: dependencies
                });
                
                // Commit the data to finalize the loading
                await scheduler.project.commitAsync();
                
                console.log('‚úÖ Data loaded into scheduler event store:', scheduler.eventStore.count, 'events');
                
                // Database times are now fixed with no overlaps, so we don't need to run ASAP automatically
                console.log('‚úÖ Database scheduled times loaded (already optimized with no overlaps)');
                console.log('üìä Event store has', scheduler.eventStore.count, 'events loaded from database');
                
                // Add welcome message to Max AI indicating schedule is ready
                setTimeout(() => {
                    const maxMessages = document.getElementById('maxMessages');
                    if (maxMessages) {
                        const welcomeMsg = document.createElement('div');
                        welcomeMsg.className = 'max-ai-message assistant';
                        welcomeMsg.innerHTML = '‚úÖ <strong>Schedule loaded from database!</strong> All operations are scheduled with no overlaps. You can use the Apply button to run optimization algorithms if needed.';
                        maxMessages.appendChild(welcomeMsg);
                        maxMessages.scrollTop = maxMessages.scrollHeight;
                    }
                }, 500);
                
                // Periodic status refresh
                setInterval(updateStatus, 30000); // Update every 30 seconds
                
                // Hide loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
                
                // Check for pending scheduler commands from Max AI (after navigation)
                const pendingCommand = sessionStorage.getItem('pendingSchedulerCommand');
                if (pendingCommand) {
                    try {
                        const commandData = JSON.parse(pendingCommand);
                        sessionStorage.removeItem('pendingSchedulerCommand');
                        
                        // Execute the pending command after a short delay to ensure page is ready
                        setTimeout(() => {
                            if (commandData.command === 'RUN_ALGORITHM') {
                                window.postMessage({
                                    type: 'RUN_SCHEDULER_ALGORITHM',
                                    algorithm: commandData.algorithm
                                }, '*');
                            } else if (commandData.command === 'VIEW_CONTROL') {
                                window.postMessage({
                                    type: 'SCHEDULER_VIEW_CONTROL',
                                    action: commandData.action
                                }, '*');
                            }
                        }, 500);
                    } catch (error) {
                        console.error('Failed to execute pending scheduler command:', error);
                    }
                }
                
                // Listen for messages from Max AI
                window.addEventListener('message', (event) => {
                    console.log('Production Scheduler received message:', event.data);
                    
                    // Handle scheduler commands from Max AI
                    if (event.data?.type === 'SCHEDULER_VIEW_CONTROL') {
                        const action = event.data.action;
                        
                        switch (action) {
                            case 'zoom_in':
                                document.getElementById('zoomIn')?.click();
                                break;
                            case 'zoom_out':
                                document.getElementById('zoomOut')?.click();
                                break;
                            case 'zoom_fit':
                                document.getElementById('zoomToFit')?.click();
                                break;
                            case 'week_view':
                                const viewSelect = document.getElementById('viewPreset');
                                if (viewSelect) {
                                    viewSelect.value = 'dayAndWeek';
                                    viewSelect.dispatchEvent(new Event('change'));
                                }
                                break;
                            case 'day_view':
                                const viewSelectDay = document.getElementById('viewPreset');
                                if (viewSelectDay) {
                                    viewSelectDay.value = 'hourAndDay';
                                    viewSelectDay.dispatchEvent(new Event('change'));
                                }
                                break;
                            case 'month_view':
                                const viewSelectMonth = document.getElementById('viewPreset');
                                if (viewSelectMonth) {
                                    viewSelectMonth.value = 'monthAndYear';
                                    viewSelectMonth.dispatchEvent(new Event('change'));
                                }
                                break;
                        }
                    } else if (event.data?.type === 'RUN_SCHEDULER_ALGORITHM') {
                        const algorithm = event.data.algorithm;
                        const algorithmMap = {
                            'ASAP': 'asap',
                            'ALAP': 'alap',
                            'CRITICAL_PATH': 'criticalPath',
                            'LEVEL_RESOURCES': 'levelResources',
                            'DRUM_TOC': 'drum'
                        };
                        
                        const algorithmValue = algorithmMap[algorithm];
                        if (algorithmValue) {
                            const algorithmSelect = document.getElementById('schedulingAlgorithm');
                            const applyButton = document.getElementById('applyScheduling');
                            
                            if (algorithmSelect && applyButton) {
                                algorithmSelect.value = algorithmValue;
                                applyButton.click();
                                console.log(`Applied scheduling algorithm: ${algorithm}`);
                            }
                        }
                    } else if (event.data?.type === 'SET_THEME') {
                        // Apply theme received from parent
                        console.log('üì• [Scheduler] Applying theme from parent:', event.data.theme);
                        applyTheme(event.data.theme);
                        localStorage.setItem('theme', event.data.theme);
                    }
                });
                
            } catch (error) {
                console.error('Failed to initialize scheduler:', error);
                // Only show error if initialization actually failed (not just warnings)
                if (error.message && error.message !== 'undefined') {
                    console.error('Scheduler initialization error details:', error.message);
                }
                // Try to continue with scheduler initialization even if some resources fail
                document.getElementById('loadingOverlay').style.display = 'none';
            }
        });
    </script>
    
    <!-- Constraint Settings Modal Scripts -->
    <script>
        // Initialize constraint settings
        window.activeConstraints = {};
        
        // Constraint modal functions
        function openConstraintModal() {
            const modal = document.getElementById('constraintModal');
            modal.classList.add('active');
            
            // Load saved constraints or use defaults
            const savedConstraints = localStorage.getItem('schedulerConstraints');
            if (savedConstraints) {
                window.activeConstraints = JSON.parse(savedConstraints);
                applyConstraintsToUI();
            } else {
                resetConstraints();
            }
        }
        
        function closeConstraintModal() {
            const modal = document.getElementById('constraintModal');
            modal.classList.remove('active');
        }
        
        function applyConstraints() {
            // Collect all constraint settings
            const constraints = {};
            const checkboxes = document.querySelectorAll('.constraint-toggle input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                constraints[checkbox.id] = checkbox.checked;
            });
            
            window.activeConstraints = constraints;
            
            // Save to localStorage
            localStorage.setItem('schedulerConstraints', JSON.stringify(constraints));
            
            // Apply constraints to current algorithm
            const currentAlgo = document.getElementById('schedulingAlgorithm').value;
            const activeCount = Object.values(constraints).filter(v => v).length;
            console.log(`‚úÖ Applied ${activeCount} active constraints to ${currentAlgo} algorithm`);
            
            // Show confirmation
            const statusBar = document.getElementById('operationCount');
            const originalText = statusBar.textContent;
            statusBar.textContent = `‚úÖ Constraints applied - ${activeCount} active`;
            setTimeout(() => {
                statusBar.textContent = originalText;
            }, 3000);
            
            closeConstraintModal();
            
            // Re-run current algorithm with new constraints
            document.getElementById('applyScheduling').click();
        }
        
        function resetConstraints() {
            // Reset all constraints to default values
            const defaults = {
                // Physical Constraints - mostly enabled by default
                'noOverlap': true,
                'dateValidation': true,
                'mandatoryFields': true,
                'predecessorLogic': true,
                'noCircular': true,
                'workingHours': true,
                'leadLagTimes': true,
                'noOverAllocation': true,
                'skillMatching': true,
                'capacityLimits': true,
                'materialAvailability': true,
                'batchSizeRules': true,
                // Policy Constraints - mixed defaults
                'priorityRules': true,
                'needDates': true,
                'budgetConstraints': false,
                'weekendWork': false,
                'workloadBalance': true,
                'limitOvertime': true,
                'parallelProcessing': false,
                'alternativeRouting': false,
                'skipNonCritical': false,
                'preventSameSetup': true,
                'justInTime': false,
                'substituteMaterials': false,
                'partialMaterial': false,
                'avoidPeakRates': true,
                'costEfficiency': false,
                'restrictPremium': true,
                'deferredInspections': false,
                'processDeviations': false,
                'auditTrails': true,
                'minimizeMakespan': true,
                'maximizeUtilization': false,
                'prioritizeMargin': false
            };
            
            // Apply defaults to UI
            Object.entries(defaults).forEach(([id, value]) => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.checked = value;
                }
            });
            
            window.activeConstraints = defaults;
            console.log('‚úÖ Constraints reset to defaults');
        }
        
        function applyConstraintsToUI() {
            // Apply saved constraints to UI checkboxes
            Object.entries(window.activeConstraints).forEach(([id, value]) => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.checked = value;
                }
            });
        }
        
        // Apply theme immediately (before DOMContentLoaded to prevent flash)
        function applyTheme(theme) {
            console.log('üé® [Production Scheduler] Applying theme:', theme);
            const isDark = theme === 'dark';
            
            // Apply Bryntum Stockholm theme classes
            if (isDark) {
                // Apply dark theme
                document.documentElement.setAttribute('data-theme', 'dark');
                document.body.classList.add('b-theme-stockholm-dark');
                document.body.classList.remove('b-theme-stockholm');
                // Also add general dark theme class
                document.body.classList.add('dark-theme');
                console.log('üåô [Production Scheduler] Dark theme applied with Stockholm dark');
            } else {
                // Apply light theme
                document.documentElement.setAttribute('data-theme', 'light');
                document.body.classList.add('b-theme-stockholm');
                document.body.classList.remove('b-theme-stockholm-dark');
                // Remove dark theme class
                document.body.classList.remove('dark-theme');
                console.log('‚òÄÔ∏è [Production Scheduler] Light theme applied with Stockholm light');
            }
            
            // If scheduler is already initialized, apply theme to it
            if (window.scheduler) {
                // Force scheduler to use the correct theme
                const schedulerEl = window.scheduler.element;
                if (schedulerEl) {
                    if (isDark) {
                        schedulerEl.classList.add('b-theme-stockholm-dark');
                        schedulerEl.classList.remove('b-theme-stockholm');
                    } else {
                        schedulerEl.classList.add('b-theme-stockholm');
                        schedulerEl.classList.remove('b-theme-stockholm-dark');
                    }
                }
            }
        }
        
        // Get theme from URL parameter (most reliable)
        const urlParams = new URLSearchParams(window.location.search);
        const themeFromUrl = urlParams.get('theme');
        
        // Listen for theme messages from parent window
        window.addEventListener('message', (event) => {
            if (event.data?.type === 'SET_THEME') {
                console.log('üì• [Scheduler iframe] Received theme from parent:', event.data.theme);
                applyTheme(event.data.theme);
                // Also save to iframe's localStorage for consistency
                localStorage.setItem('theme', event.data.theme);
            }
        });
        
        // Apply theme immediately - priority: URL param > localStorage > default
        // But first check if we're in an iframe and can get parent theme
        let parentTheme = null;
        if (window.parent !== window) {
            try {
                // Try to get theme from parent's localStorage
                parentTheme = window.parent.localStorage.getItem('theme');
                console.log('üëÜ [Production Scheduler] Parent theme detected:', parentTheme);
            } catch (e) {
                console.log('‚ö†Ô∏è [Production Scheduler] Could not access parent theme (cross-origin)');
            }
        }
        
        const initialTheme = themeFromUrl || parentTheme || localStorage.getItem('theme') || 'light';
        console.log('üîç [Production Scheduler] Initial theme:', initialTheme, '(from:', themeFromUrl ? 'URL' : parentTheme ? 'parent' : 'localStorage', ')');
        applyTheme(initialTheme);
        
        // Setup event listeners when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Constraint settings button
            document.getElementById('constraintSettings').addEventListener('click', openConstraintModal);
            
            // Click outside modal to close
            document.getElementById('constraintModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeConstraintModal();
                }
            });
            
            // Listen for theme changes from parent window
            window.addEventListener('message', (e) => {
                if (e.data && e.data.type === 'SET_THEME') {
                    applyTheme(e.data.theme);
                    localStorage.setItem('theme', e.data.theme);
                }
            });
            
            // Listen for storage changes (theme changes in main app)
            window.addEventListener('storage', (e) => {
                if (e.key === 'theme') {
                    applyTheme(e.newValue);
                }
            });
            
            // Modify the apply scheduling button to use constraints
            const originalApplyHandler = document.getElementById('applyScheduling').onclick;
            document.getElementById('applyScheduling').addEventListener('click', () => {
                try {
                    // Clear any localStorage issues first
                    try {
                        // Test if localStorage is accessible
                        localStorage.setItem('test', 'test');
                        localStorage.removeItem('test');
                    } catch (storageError) {
                        console.warn('‚ö†Ô∏è localStorage is not accessible, some features may be limited');
                        // Continue anyway - Bryntum can work without localStorage
                    }
                    
                    const activeCount = Object.values(window.activeConstraints || {}).filter(v => v).length;
                    if (activeCount > 0) {
                        console.log(`‚öôÔ∏è Applying algorithm with ${activeCount} active constraints`);
                    }
                    
                    const algorithm = document.getElementById('schedulingAlgorithm').value;
                    console.log(`üöÄ Applying ${algorithm.toUpperCase()} algorithm...`);
                    
                    // Apply the algorithm with error handling
                    if (window.scheduler && window.scheduler.project) {
                        // Disable Bryntum's state saving temporarily to avoid storage errors
                        const originalStateId = window.scheduler.stateId;
                        window.scheduler.stateId = null;
                        
                        // Apply the corrected algorithms with valid Bryntum constraints
                        switch(algorithm) {
                            case 'asap':
                                // ‚úÖ CORRECTED ASAP - Remove constraints for true forward scheduling
                                console.log('‚è© Applying ASAP (Forward) scheduling');
                                window.scheduler.project.direction = 'Forward';
                                window.scheduler.project.startDate = new Date(2025, 8, 3, 7, 0, 0);
                                
                                const asapEvents = window.scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                                asapEvents.forEach(event => {
                                    // üîí Skip manually positioned events
                                    if (event.manuallyScheduled) {
                                        console.log(`üîí Preserving manual position for: ${event.name}`);
                                        return;
                                    }
                                    // Remove constraints for true ASAP
                                    event.constraintType = null;
                                    event.constraintDate = null;
                                });
                                
                                await window.scheduler.project.propagate();
                                break;
                                
                            case 'alap':
                                // ‚úÖ CORRECTED ALAP - Use valid finishnolaterthan constraint
                                console.log('‚è™ Applying ALAP (Manual Late Scheduling)');
                                
                                const alapEvents = window.scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                                const projectEnd = new Date(
                                    Math.max(...alapEvents.map(e => e.endDate?.getTime() || Date.now()))
                                );
                                
                                alapEvents.forEach(event => {
                                    // üîí Skip manually positioned events
                                    if (event.manuallyScheduled) {
                                        console.log(`üîí Preserving manual position for: ${event.name}`);
                                        return;
                                    }
                                    // Use valid Bryntum constraint
                                    event.constraintType = 'finishnolaterthan';
                                    event.constraintDate = projectEnd;
                                });
                                
                                await window.scheduler.project.propagate();
                                console.warn('‚ö†Ô∏è Note: Full ALAP support requires Bryntum Gantt. Using workaround.');
                                break;
                                
                            case 'criticalPath':
                                // ‚úÖ CORRECTED Critical Path - Custom CPM implementation
                                console.log('üéØ Applying Custom Critical Path Method');
                                
                                // First apply ASAP
                                window.scheduler.project.direction = 'Forward';
                                window.scheduler.project.startDate = new Date(2025, 8, 3, 7, 0, 0);
                                
                                const cpmEvents = window.scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                                cpmEvents.forEach(event => {
                                    if (!event.manuallyScheduled) {
                                        event.constraintType = null;
                                        event.constraintDate = null;
                                    }
                                });
                                
                                await window.scheduler.project.propagate();
                                
                                // Calculate critical path
                                const cpmProjectEnd = new Date(
                                    Math.max(...cpmEvents.map(e => e.endDate?.getTime() || 0))
                                );
                                
                                cpmEvents.forEach(event => {
                                    if (event.manuallyScheduled) {
                                        console.log(`üîí Preserving manual position for: ${event.name}`);
                                        return;
                                    }
                                    
                                    // Check for successors
                                    const hasSuccessors = window.scheduler.dependencyStore.records.some(
                                        dep => dep.fromEvent === event.id
                                    );
                                    
                                    // Simplified critical determination
                                    const daysToEnd = (cpmProjectEnd - event.endDate) / (1000 * 60 * 60 * 24);
                                    const isCritical = hasSuccessors || daysToEnd < 2;
                                    
                                    if (isCritical) {
                                        event.cls = (event.cls || '') + ' critical-path-task';
                                        event.eventColor = '#dc2626';
                                        console.log(`üéØ Critical: ${event.name}`);
                                    }
                                });
                                
                                window.scheduler.refresh();
                                console.warn('‚ö†Ô∏è Note: Full Critical Path support requires Bryntum Gantt. Using simplified calculation.');
                                break;
                                
                            case 'levelResources':
                                // Call the comprehensive Resource Leveling algorithm
                                await levelResourcesScheduling();
                                break;
                                
                            case 'drum':
                                // Theory of Constraints / Drum scheduling - placeholder
                                console.log('ü•Å Drum/TOC scheduling not yet implemented');
                                break;
                                
                            case 'dbr':
                                // Theory of Constraints DBR scheduling - placeholder
                                console.log('üéØ DBR/TOC scheduling not yet implemented');
                                break;
                                
                            case 'pert':
                                // Apply PERT algorithm
                                console.log('üìä Applying PERT (Probabilistic) scheduling');
                                
                                const pertEventList = window.scheduler.eventStore.records.filter(e => e.resourceId !== 'unscheduled');
                                let hasPertEstimates = false;
                                
                                // Apply PERT expected times
                                pertEventList.forEach(event => {
                                    if (window.pertEstimates && window.pertEstimates[event.id]) {
                                        const estimates = window.pertEstimates[event.id];
                                        
                                        // Update duration to expected time
                                        event.duration = estimates.expectedTime;
                                        
                                        // Apply uncertainty visual indicators
                                        event.cls = event.cls ? event.cls.replace(/pert-\w+-uncertainty/g, '') : '';
                                        if (estimates.cv < 10) {
                                            event.cls = (event.cls || '') + ' pert-low-uncertainty';
                                        } else if (estimates.cv < 20) {
                                            event.cls = (event.cls || '') + ' pert-medium-uncertainty';
                                        } else {
                                            event.cls = (event.cls || '') + ' pert-high-uncertainty';
                                        }
                                        
                                        event.pertData = estimates;
                                        hasPertEstimates = true;
                                    }
                                });
                                
                                // Show PERT metrics panel
                                if (document.getElementById('pertMetricsPanel')) {
                                    document.getElementById('pertMetricsPanel').classList.add('active');
                                    updatePertMetrics();
                                }
                                
                                // Recalculate schedule
                                window.scheduler.project.propagate();
                                
                                if (!hasPertEstimates) {
                                    showNotification('‚ö†Ô∏è No PERT estimates found. Right-click operations to add three-point estimates.', 'warning');
                                } else {
                                    showNotification('‚úÖ PERT algorithm applied with probabilistic scheduling', 'success');
                                }
                                break;
                                
                            default:
                                console.warn('Unknown algorithm:', algorithm);
                        }
                        
                        // Re-enable state saving if it was enabled
                        if (originalStateId) {
                            window.scheduler.stateId = originalStateId;
                        }
                        
                        // Auto-save only non-manual events
                        console.log('üíæ Auto-saving algorithm results to database...');
                        const allEvents = [...window.scheduler.eventStore.records].filter(
                            e => e.resourceId !== 'unscheduled' && !e.manuallyScheduled && e.isModified
                        );
                        if (allEvents.length > 0) {
                            await saveOperationChanges(allEvents);
                        }
                        
                        // Show success feedback
                        const notification = document.createElement('div');
                        notification.className = 'scheduler-notification success';
                        notification.textContent = `‚úÖ ${algorithm.toUpperCase()} algorithm applied and saved successfully`;
                        notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000; animation: slideIn 0.3s ease-out;';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            notification.style.animation = 'slideOut 0.3s ease-out';
                            setTimeout(() => notification.remove(), 300);
                        }, 3000);
                    } else {
                        console.error('Scheduler not initialized');
                    }
                } catch (error) {
                    console.error('‚ùå Error applying algorithm:', error);
                    
                    // Show error notification
                    const errorNotification = document.createElement('div');
                    errorNotification.className = 'scheduler-notification error';
                    errorNotification.textContent = `‚ùå Failed to apply algorithm: ${error.message || 'Unknown error'}`;
                    errorNotification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ef4444; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000; animation: slideIn 0.3s ease-out;';
                    document.body.appendChild(errorNotification);
                    
                    setTimeout(() => {
                        errorNotification.style.animation = 'slideOut 0.3s ease-out';
                        setTimeout(() => errorNotification.remove(), 300);
                    }, 5000);
                }
            });
            
            // Add functionality for Save button using Bryntum's built-in methods
            document.getElementById('saveSchedule').addEventListener('click', async () => {
                try {
                    // Show saving status
                    const saveBtn = document.getElementById('saveSchedule');
                    const originalHTML = saveBtn.innerHTML;
                    saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin"><path d="M21 12a9 9 0 1 1-6-8.485"></path></svg><span>Saving...</span>';
                    saveBtn.disabled = true;
                    
                    // Use Bryntum's built-in project serialization
                    if (window.scheduler && window.scheduler.project) {
                        // Get the project's complete state using Bryntum's toJSON method
                        const projectData = window.scheduler.project.toJSON();
                        
                        // Prompt for save name
                        const scheduleName = prompt('Enter a name for this schedule:', `Schedule - ${new Date().toLocaleDateString()}`);
                        
                        if (!scheduleName) {
                            saveBtn.innerHTML = originalHTML;
                            saveBtn.disabled = false;
                            return;
                        }
                        
                        // Prepare save data
                        const saveData = {
                            name: scheduleName,
                            description: `Algorithm: ${document.getElementById('schedulingAlgorithm').options[document.getElementById('schedulingAlgorithm').selectedIndex].text}`,
                            scheduleData: projectData,
                            metadata: {
                                algorithm: document.getElementById('schedulingAlgorithm').value,
                                savedAt: new Date().toISOString(),
                                constraints: window.activeConstraints || {},
                                stats: window.currentStats || {}
                            }
                        };
                        
                        // Get auth token from parent window or localStorage
                        const authToken = window.parent?.localStorage?.getItem('auth_token') || localStorage.getItem('auth_token');
                        
                        // Save to database
                        const response = await fetch('/api/saved-schedules', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': authToken ? `Bearer ${authToken}` : ''
                            },
                            body: JSON.stringify(saveData)
                        });
                        
                        if (response.ok) {
                            const savedSchedule = await response.json();
                            
                            // Also save to localStorage as backup
                            localStorage.setItem('lastSavedSchedule', JSON.stringify(saveData));
                            
                            // Update last update time
                            document.getElementById('lastUpdate').textContent = `Last saved: ${new Date().toLocaleTimeString()}`;
                            
                            console.log('‚úÖ Schedule saved to database:', savedSchedule.id);
                            
                            // Show success message
                            saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg><span>Saved!</span>';
                            
                            // Store the saved schedule ID for future updates
                            window.currentScheduleId = savedSchedule.id;
                        } else {
                            // Fallback to localStorage if API fails
                            localStorage.setItem('savedSchedule_' + Date.now(), JSON.stringify(saveData));
                            console.warn('‚ö†Ô∏è Saved to local storage (database save failed)');
                            
                            // Show warning
                            saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><span>Saved Locally</span>';
                        }
                        
                        // Reset button after delay
                        setTimeout(() => {
                            saveBtn.innerHTML = originalHTML;
                            saveBtn.disabled = false;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('‚ùå Error saving schedule:', error);
                    
                    // Try to save to localStorage as fallback
                    try {
                        const fallbackData = {
                            name: `Backup - ${new Date().toLocaleTimeString()}`,
                            timestamp: new Date().toISOString(),
                            data: window.scheduler.project.toJSON()
                        };
                        localStorage.setItem('scheduleBackup_' + Date.now(), JSON.stringify(fallbackData));
                        alert('Schedule saved to local storage as backup');
                    } catch (e) {
                        alert('Failed to save schedule. Please try again.');
                    }
                    
                    document.getElementById('saveSchedule').innerHTML = document.getElementById('saveSchedule').innerHTML;
                    document.getElementById('saveSchedule').disabled = false;
                }
            });
            
            // Add Load Schedule functionality
            window.loadSchedule = async function() {
                try {
                    // Get auth token
                    const authToken = window.parent?.localStorage?.getItem('auth_token') || localStorage.getItem('auth_token');
                    
                    // Fetch saved schedules from database
                    const response = await fetch('/api/saved-schedules', {
                        headers: {
                            'Authorization': authToken ? `Bearer ${authToken}` : ''
                        }
                    });
                    
                    if (response.ok) {
                        const schedules = await response.json();
                        
                        if (schedules.length === 0) {
                            alert('No saved schedules found');
                            return;
                        }
                        
                        // Create a simple selection dialog
                        const scheduleList = schedules.map((s, i) => 
                            `${i + 1}. ${s.name} (${new Date(s.updatedAt).toLocaleDateString()})`
                        ).join('\n');
                        
                        const selection = prompt(`Select a schedule to load:\n\n${scheduleList}\n\nEnter number (1-${schedules.length}):`);
                        
                        if (selection) {
                            const index = parseInt(selection) - 1;
                            if (index >= 0 && index < schedules.length) {
                                const selectedSchedule = schedules[index];
                                
                                // Load the schedule using Bryntum's loadInlineData method
                                if (window.scheduler && window.scheduler.project) {
                                    // Load the project data
                                    await window.scheduler.project.loadInlineData(selectedSchedule.scheduleData);
                                    
                                    // Restore metadata if available
                                    if (selectedSchedule.metadata) {
                                        if (selectedSchedule.metadata.algorithm) {
                                            document.getElementById('schedulingAlgorithm').value = selectedSchedule.metadata.algorithm;
                                        }
                                        if (selectedSchedule.metadata.constraints) {
                                            window.activeConstraints = selectedSchedule.metadata.constraints;
                                        }
                                    }
                                    
                                    // Store the schedule ID for future updates
                                    window.currentScheduleId = selectedSchedule.id;
                                    
                                    // Zoom to fit the entire schedule in view
                                    const events = window.scheduler.eventStore.records;
                                    if (events && events.length > 0) {
                                        // Find the earliest and latest dates in the schedule
                                        let minDate = null;
                                        let maxDate = null;
                                        
                                        events.forEach(event => {
                                            if (!minDate || event.startDate < minDate) {
                                                minDate = new Date(event.startDate);
                                            }
                                            if (!maxDate || event.endDate > maxDate) {
                                                maxDate = new Date(event.endDate);
                                            }
                                        });
                                        
                                        if (minDate && maxDate) {
                                            // Add some padding (1 day before and after)
                                            minDate.setDate(minDate.getDate() - 1);
                                            maxDate.setDate(maxDate.getDate() + 1);
                                            
                                            // Set the time span to show all events
                                            window.scheduler.setTimeSpan(minDate, maxDate);
                                            
                                            // Adjust zoom level to fit the view
                                            // Calculate the number of days to show
                                            const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
                                            
                                            // Set appropriate zoom level based on days
                                            if (daysDiff <= 7) {
                                                window.scheduler.zoomLevel = 10; // Hour view
                                            } else if (daysDiff <= 14) {
                                                window.scheduler.zoomLevel = 8; // Day view
                                            } else if (daysDiff <= 30) {
                                                window.scheduler.zoomLevel = 6; // Week view
                                            } else {
                                                window.scheduler.zoomLevel = 4; // Month view
                                            }
                                        }
                                    }
                                    
                                    // Update status
                                    document.getElementById('lastUpdate').textContent = `Loaded: ${selectedSchedule.name}`;
                                    updateStatus();
                                    
                                    console.log('‚úÖ Schedule loaded successfully:', selectedSchedule.name);
                                }
                            }
                        }
                    } else {
                        // Fallback to localStorage
                        const localSchedules = [];
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (key && (key.startsWith('savedSchedule_') || key.startsWith('scheduleBackup_'))) {
                                try {
                                    const data = JSON.parse(localStorage.getItem(key));
                                    localSchedules.push({ key, data });
                                } catch (e) {}
                            }
                        }
                        
                        if (localSchedules.length > 0) {
                            const scheduleList = localSchedules.map((s, i) => 
                                `${i + 1}. ${s.data.name || 'Unnamed'} (Local)`
                            ).join('\n');
                            
                            const selection = prompt(`Select a local schedule to load:\n\n${scheduleList}\n\nEnter number:`);
                            if (selection) {
                                const index = parseInt(selection) - 1;
                                if (index >= 0 && index < localSchedules.length) {
                                    const selectedSchedule = localSchedules[index].data;
                                    if (selectedSchedule.scheduleData || selectedSchedule.data) {
                                        await window.scheduler.project.loadInlineData(selectedSchedule.scheduleData || selectedSchedule.data);
                                        
                                        // Zoom to fit the entire schedule in view
                                        const events = window.scheduler.eventStore.records;
                                        if (events && events.length > 0) {
                                            // Find the earliest and latest dates in the schedule
                                            let minDate = null;
                                            let maxDate = null;
                                            
                                            events.forEach(event => {
                                                if (!minDate || event.startDate < minDate) {
                                                    minDate = new Date(event.startDate);
                                                }
                                                if (!maxDate || event.endDate > maxDate) {
                                                    maxDate = new Date(event.endDate);
                                                }
                                            });
                                            
                                            if (minDate && maxDate) {
                                                // Add some padding (1 day before and after)
                                                minDate.setDate(minDate.getDate() - 1);
                                                maxDate.setDate(maxDate.getDate() + 1);
                                                
                                                // Set the time span to show all events
                                                window.scheduler.setTimeSpan(minDate, maxDate);
                                                
                                                // Adjust zoom level to fit the view
                                                // Calculate the number of days to show
                                                const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
                                                
                                                // Set appropriate zoom level based on days
                                                if (daysDiff <= 7) {
                                                    window.scheduler.zoomLevel = 10; // Hour view
                                                } else if (daysDiff <= 14) {
                                                    window.scheduler.zoomLevel = 8; // Day view
                                                } else if (daysDiff <= 30) {
                                                    window.scheduler.zoomLevel = 6; // Week view
                                                } else {
                                                    window.scheduler.zoomLevel = 4; // Month view
                                                }
                                            }
                                        }
                                        
                                        console.log('‚úÖ Local schedule loaded');
                                    }
                                }
                            }
                        } else {
                            alert('No saved schedules found');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error loading schedule:', error);
                    alert('Failed to load schedule. Please try again.');
                }
            };
            
            // Add functionality for Refresh button - simply reload the page
            document.getElementById('refreshSchedule').addEventListener('click', () => {
                // Show refreshing status
                const refreshBtn = document.getElementById('refreshSchedule');
                refreshBtn.classList.add('animate-spin');
                refreshBtn.disabled = true;
                
                console.log('üîÑ Refreshing schedule data...');
                
                // Simply reload the page to get fresh data
                // This ensures all data is fetched with proper authentication
                setTimeout(() => {
                    window.location.reload(true); // Force reload from server, not cache
                }, 300); // Small delay for visual feedback
            });
        });
    </script>
    
    <!-- PERT Estimation Dialog -->
    <div id="pertDialog" class="pert-dialog">
        <div class="pert-dialog-header">
            <h2>PERT Three-Point Estimation</h2>
            <button class="constraint-modal-close" onclick="closePertDialog()">√ó</button>
        </div>
        <div class="pert-dialog-body">
            <p><strong>Operation:</strong> <span id="pertOperationName"></span></p>
            
            <div class="pert-form-group">
                <label for="pertOptimistic">Optimistic Time (O) - Best Case (hours):</label>
                <input type="number" id="pertOptimistic" step="0.5" min="0.5" placeholder="e.g., 2.0">
                <div class="pert-error-message" id="pertOptimisticError"></div>
            </div>
            
            <div class="pert-form-group">
                <label for="pertMostLikely">Most Likely Time (M) - Normal Case (hours):</label>
                <input type="number" id="pertMostLikely" step="0.5" min="0.5" placeholder="e.g., 3.0">
                <div class="pert-error-message" id="pertMostLikelyError"></div>
            </div>
            
            <div class="pert-form-group">
                <label for="pertPessimistic">Pessimistic Time (P) - Worst Case (hours):</label>
                <input type="number" id="pertPessimistic" step="0.5" min="0.5" placeholder="e.g., 5.0">
                <div class="pert-error-message" id="pertPessimisticError"></div>
            </div>
            
            <div class="pert-calculations" id="pertCalculations" style="display: none;">
                <div class="pert-calc-row">
                    <span class="pert-calc-label">Expected Time (Te):</span>
                    <span class="pert-calc-value" id="pertExpectedTime">-</span>
                </div>
                <div class="pert-calc-row">
                    <span class="pert-calc-label">Standard Deviation (œÉ):</span>
                    <span class="pert-calc-value" id="pertStdDev">-</span>
                </div>
                <div class="pert-calc-row">
                    <span class="pert-calc-label">Variance (œÉ¬≤):</span>
                    <span class="pert-calc-value" id="pertVariance">-</span>
                </div>
                <div class="pert-calc-row">
                    <span class="pert-calc-label">Coefficient of Variation:</span>
                    <span class="pert-calc-value" id="pertCV">-</span>
                </div>
            </div>
        </div>
        <div class="pert-dialog-footer">
            <button class="pert-btn-cancel" onclick="closePertDialog()">Cancel</button>
            <button class="pert-btn-save" onclick="savePertEstimates()">Save Estimates</button>
        </div>
    </div>
    
    <!-- PERT Metrics Panel -->
    <div id="pertMetricsPanel" class="pert-metrics-panel">
        <div class="pert-metrics-header">
            <span>üìä PERT Analysis</span>
            <button onclick="closePertMetrics()" style="background: transparent; border: none; color: white; font-size: 1.2rem; cursor: pointer;">√ó</button>
        </div>
        
        <div class="pert-metrics-section">
            <div class="pert-metrics-title">Project Duration</div>
            <div class="pert-calc-row">
                <span class="pert-calc-label">Expected Duration:</span>
                <span class="pert-calc-value" id="pertProjectDuration">-</span>
            </div>
            <div class="pert-calc-row">
                <span class="pert-calc-label">Standard Deviation:</span>
                <span class="pert-calc-value" id="pertProjectStdDev">-</span>
            </div>
            <div class="pert-calc-row">
                <span class="pert-calc-label">Critical Path Variance:</span>
                <span class="pert-calc-value" id="pertCriticalVariance">-</span>
            </div>
        </div>
        
        <div class="pert-metrics-section">
            <div class="pert-metrics-title">Confidence Levels</div>
            <div class="pert-confidence-level">
                <span class="pert-confidence-label">68% (¬±1œÉ):</span>
                <span class="pert-confidence-date" id="pertConfidence68">-</span>
            </div>
            <div class="pert-confidence-level">
                <span class="pert-confidence-label">95% (¬±2œÉ):</span>
                <span class="pert-confidence-date" id="pertConfidence95">-</span>
            </div>
            <div class="pert-confidence-level">
                <span class="pert-confidence-label">99.7% (¬±3œÉ):</span>
                <span class="pert-confidence-date" id="pertConfidence99">-</span>
            </div>
        </div>
        
        <div class="pert-metrics-section">
            <div class="pert-metrics-title">High Uncertainty Operations</div>
            <div class="pert-high-uncertainty-list" id="pertHighUncertaintyList">
                <div style="color: #6b7280; font-size: 0.85rem;">No PERT estimates yet</div>
            </div>
        </div>
    </div>
</body>
</html>
