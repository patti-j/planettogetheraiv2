<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Force refresh timestamp: 2025-10-09 v7.0.0 -->
    <title>Production Schedule - PlanetTogether</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <!-- FontAwesome (now required separately in v7.0.0) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <!-- Bryntum Scheduler Pro CSS - Using Material3 Light theme for v7.0.0 -->
    <link rel="stylesheet" href="/schedulerpro.css?v=8" id="scheduler-theme">
    
    <!-- CRITICAL: Load Bryntum Scheduler Pro library in HEAD (required for initialization) -->
    <script src="/schedulerpro.umd.js"></script>
    
    <style>
        /* Minimal essential styles only - let Bryntum handle the rest */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: auto;
        }

        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .toolbar {
            padding: 0.75rem 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
            overflow-x: auto;
        }

        .scheduler-container {
            flex: 1;
            margin: 1rem;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #scheduler {
            flex: 1;
            min-height: 0;
            height: 100%;
        }
        
        /* Diagnostic CSS for v7.0.0 alpha - ensure visibility */
        .b-scheduler-pro {
            width: 100% !important;
            height: 100% !important;
        }
        
        .b-grid-header {
            visibility: visible !important;
            display: flex !important;
        }
        
        .b-grid-body-container {
            visibility: visible !important;
        }

        .status-bar {
            padding: 0.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ff4444;
            color: white;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem;
            text-align: center;
        }
        
        /* Hide elements that might conflict */
        .nav-menu, .max-ai-panel, .constraint-modal {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Production Schedule</h1>
        <div class="header-actions">
            <span id="lastUpdated">Last updated: Never</span>
        </div>
    </div>

    <div class="toolbar">
        <div class="toolbar-group">
            <label for="viewSelector">View:</label>
            <select id="viewSelector">
                <option value="day">Day & Week</option>
                <option value="week">Week & Month</option>
                <option value="month">Month</option>
            </select>
        </div>
        
        <div class="toolbar-group">
            <button id="zoomInBtn" title="Zoom In">
                <i class="fa fa-search-plus"></i>
            </button>
            <button id="zoomOutBtn" title="Zoom Out">
                <i class="fa fa-search-minus"></i>
            </button>
            <button id="zoomToFitBtn" title="Zoom to Fit">
                <i class="fa fa-expand"></i>
            </button>
        </div>

        <div class="toolbar-group">
            <label for="algorithmSelector">Algorithm:</label>
            <select id="algorithmSelector">
                <option value="asap">ASAP (Forward)</option>
                <option value="alap">ALAP (Backward)</option>
                <option value="critical">Critical Path</option>
                <option value="resource">Resource Leveling</option>
            </select>
            <button id="applyAlgorithmBtn">
                <i class="fa fa-play"></i> Apply
            </button>
        </div>

        <div class="toolbar-group">
            <button id="saveSchedule">
                <i class="fa fa-save"></i> Save
            </button>
        </div>
    </div>

    <div class="scheduler-container">
        <div id="scheduler"></div>
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <div class="status-bar">
        <div id="statusMessage">35 operations scheduled</div>
        <div id="resourceUtilization">Resource utilization: 99% (95.0h total)</div>
    </div>

    <!-- Load Bryntum Scheduler Pro UMD -->
    <script src="/schedulerpro.umd.js"></script>
    
    <!-- Initialize the scheduler -->
    <script>
        // Wait for DOM and Bryntum to load
        // Guard to prevent multiple initialization attempts
        let schedulerInitialized = false;
        
        async function initializeScheduler() {
            if (schedulerInitialized) {
                console.log('‚ö†Ô∏è Scheduler already initialized, skipping duplicate initialization');
                return;
            }
            
            try {
                console.log('üöÄ Starting Production Scheduler initialization...');
                schedulerInitialized = true;
                
                // Hide loading overlay
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }

                // Check if bryntum is available
                if (typeof bryntum === 'undefined' || !bryntum.schedulerpro) {
                    console.error('‚ùå Bryntum SchedulerPro is not loaded!');
                    throw new Error('Bryntum SchedulerPro library is not available');
                }

                // Initialize scheduler using global bryntum object
                // Try multiple possible locations for SchedulerPro constructor in v7.0.0-alpha.1
                console.log('üîç Looking for SchedulerPro constructor...');
                console.log('Available bryntum properties:', Object.keys(bryntum));
                
                // Check if schedulerpro namespace exists
                if (bryntum.schedulerpro) {
                    console.log('bryntum.schedulerpro properties:', Object.keys(bryntum.schedulerpro));
                }
                
                // For v6.3.2, SchedulerPro should be at bryntum.schedulerpro.SchedulerPro
                // Let's check the exact structure
                const SchedulerPro = bryntum.schedulerpro?.SchedulerPro;
                
                // If not found, try exploring the bryntum object structure
                if (!SchedulerPro && bryntum.schedulerpro) {
                    // Check what classes are available in the schedulerpro namespace
                    for (let key in bryntum.schedulerpro) {
                        if (key.includes('Scheduler')) {
                            console.log(`Found scheduler class: bryntum.schedulerpro.${key}`);
                        }
                    }
                }
                
                if (!SchedulerPro) {
                    console.error('‚ùå SchedulerPro constructor not found!');
                    console.error('Tried all possible locations. Check console for available properties.');
                    
                    // Try to find any constructor-like objects
                    for (let key in bryntum) {
                        if (typeof bryntum[key] === 'function' && key.includes('Scheduler')) {
                            console.log(`Found potential constructor: bryntum.${key}`);
                        }
                    }
                    
                    throw new Error('SchedulerPro constructor not available');
                }
                
                console.log('‚úÖ Found SchedulerPro constructor!', SchedulerPro);
                
                // Set today's date to September 3, 2025
                const today = new Date('2025-09-03');
                
                // Load PT resources from database
                console.log('üìä Loading PT resources from database...');
                let resources = [];
                
                try {
                    const ptResourcesResponse = await fetch('/api/ptresources');
                    if (ptResourcesResponse.ok) {
                        const ptResources = await ptResourcesResponse.json();
                        console.log(`‚úÖ Loaded ${ptResources.length} PT resources from database`);
                        
                        // Map PT resources to Bryntum format with proper sorting
                        resources = ptResources
                            .filter(res => res.active !== false)  // Fixed: use 'active' not 'is_active'
                            .sort((a, b) => {
                                // Sort by name since we don't have resource_type
                                const nameA = a.name || '';
                                const nameB = b.name || '';
                                return nameA.localeCompare(nameB);
                            })
                            .map((resource, index) => ({
                                id: resource.resource_id || `RESOURCE_${resource.id}`,  // Fixed: use resource_id
                                name: resource.name || `Resource ${resource.id}`,
                                resourceType: 'Production',  // Default type since not in DB
                                sortOrder: index
                            }));
                    } else {
                        console.warn('‚ö†Ô∏è Could not load PT resources, using demo data');
                    }
                } catch (error) {
                    console.error('‚ùå Error loading PT resources:', error);
                }
                
                // If no resources from database, create demo resources
                if (resources.length === 0) {
                    console.log('üìä Creating demo resources...');
                    resources = [
                        { id: 'FILLER_001', name: 'Bottle Filler Line', resourceType: 'Packaging', sortOrder: 0 },
                        { id: 'FILLER_002', name: 'Can Filler Line', resourceType: 'Packaging', sortOrder: 1 },
                        { id: 'MIXER_001', name: 'Blending Tank 1', resourceType: 'Production', sortOrder: 2 },
                        { id: 'MIXER_002', name: 'Blending Tank 2', resourceType: 'Production', sortOrder: 3 },
                        { id: 'PACKAGE_001', name: 'Labeling Machine', resourceType: 'Packaging', sortOrder: 4 }
                    ];
                }
                
                // Load PT operations from database
                console.log('üìä Loading PT operations from database...');
                let ptOperations = [];
                
                try {
                    const ptOperationsResponse = await fetch('/api/ptoperations');
                    if (ptOperationsResponse.ok) {
                        ptOperations = await ptOperationsResponse.json();
                        console.log(`‚úÖ Loaded ${ptOperations.length} PT operations from database`);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading PT operations:', error);
                }
                
                // Transform PT operations into Bryntum events format
                let events = ptOperations.map((operation, index) => {
                    // Use actual scheduled dates if available, otherwise generate demo dates
                    let startDate = operation.scheduled_start ? new Date(operation.scheduled_start) : new Date(today);
                    let endDate = operation.scheduled_end ? new Date(operation.scheduled_end) : null;
                    
                    // If no scheduled dates, generate them based on index
                    if (!operation.scheduled_start) {
                        startDate.setDate(startDate.getDate() + Math.floor(index / 4));
                        startDate.setHours(8 + (index % 4) * 3, 0, 0, 0);
                    }
                    
                    if (!endDate) {
                        endDate = new Date(startDate);
                        const durationHours = parseFloat(operation.cycle_hrs) || 2;
                        endDate.setHours(startDate.getHours() + durationHours);
                    }
                    
                    const eventId = operation.external_id || `OP_${operation.id}`;
                    // Assign to resources in round-robin if no specific resource
                    const resourceId = resources[index % resources.length]?.id || resources[0]?.id;
                    
                    return {
                        id: eventId,
                        name: operation.name || `Operation ${operation.id}`,
                        startDate: startDate,
                        endDate: endDate,
                        resourceId: resourceId,
                        eventColor: '#2196F3',  // Default blue color for all operations
                        priority: operation.priority || 50,
                        setupHours: parseFloat(operation.setup_hours) || 0,
                        cycleHrs: parseFloat(operation.cycle_hrs) || 0,
                        constraintType: 'startnoearlierthan',
                        constraintDate: startDate,
                        originalStart: new Date(startDate),
                        originalEnd: new Date(endDate),
                        locked: false,
                        allowOverlap: false
                    };
                });
                
                console.log(`üìä Transformed ${events.length} PT operations into Bryntum events`);
                
                // If no operations from database, create demo operations
                if (events.length === 0) {
                    console.log('üìä Creating demo operations...');
                    const demoStartDate = new Date(today);
                    demoStartDate.setHours(8, 0, 0, 0);
                    
                    events = [
                        {
                            id: 'OP_001',
                            name: 'Mix Batch A-1',
                            startDate: new Date(demoStartDate),
                            endDate: new Date(demoStartDate.getTime() + 2 * 60 * 60 * 1000),
                            resourceId: resources[2]?.id || resources[0]?.id,
                            eventColor: '#4CAF50'
                        },
                        {
                            id: 'OP_002',
                            name: 'Fill Bottles - Batch A-1',
                            startDate: new Date(demoStartDate.getTime() + 3 * 60 * 60 * 1000),
                            endDate: new Date(demoStartDate.getTime() + 5 * 60 * 60 * 1000),
                            resourceId: resources[0]?.id,
                            eventColor: '#2196F3'
                        }
                    ];
                }
                
                // Create scheduler instance with proper Bryntum project engine configuration
                window.scheduler = new SchedulerPro({
                    appendTo: 'scheduler',
                    
                    // Ensure the scheduler has a proper height
                    autoHeight: false,
                    height: '100%',
                    
                    // Basic scheduler configuration
                    startDate: new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1),
                    endDate: new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30),
                    viewPreset: 'weekAndDay',  // Fixed typo: should be 'weekAndDay' not 'dayAndWeek'
                    rowHeight: 50,
                    barMargin: 5,
                    eventColor: '#2196F3',
                    eventStyle: 'plain',
                    
                    // Proper Bryntum Project configuration using the scheduling engine
                    project: {
                        autoLoad: false,
                        autoSync: false,
                        
                        // Event store configuration
                        eventStore: {
                            data: []
                        },
                        
                        // Resource store configuration
                        resourceStore: {
                            data: []
                        },
                        
                        // NO AssignmentStore - using single-assignment mode (resourceId on events)
                        // Scheduler Pro can use EITHER AssignmentStore OR resourceId, not both!
                        
                        // Dependency store for task dependencies
                        dependencyStore: {
                            data: []
                        }
                    },
                    
                    // Column configuration - removed 'tree' type that requires Tree feature
                    columns: [
                        {
                            text: 'Resources',
                            field: 'name',
                            width: 220,
                            minWidth: 100,
                            region: 'locked',  // REQUIRED for v7.0.0 alpha
                            editor: false
                        }
                    ],
                    
                    // Features configuration
                    features: {
                        tree: false,  // Explicitly disable tree feature to avoid conflicts
                        eventDrag: {
                            constrainDragToResource: false,
                            showTooltip: true
                        },
                        eventDragCreate: true,
                        eventResize: {
                            showTooltip: true
                        },
                        dependencies: true,
                        dependencyEdit: {
                            showLagField: true
                        },
                        timeRanges: {
                            showCurrentTimeLine: true
                        },
                        eventTooltip: {
                            template: ({ eventRecord }) => {
                                return `
                                    <div>
                                        <strong>${eventRecord.name}</strong><br/>
                                        Resource: ${eventRecord.resource?.name || 'Unassigned'}<br/>
                                        Start: ${eventRecord.startDate?.toLocaleString() || 'Not scheduled'}<br/>
                                        End: ${eventRecord.endDate?.toLocaleString() || 'Not scheduled'}<br/>
                                        Duration: ${eventRecord.duration || 0} hours
                                    </div>
                                `;
                            }
                        },
                        sort: {
                            field: 'sortOrder',
                            ascending: true
                        }
                    }
                });
                
                // Log the data being loaded
                console.log('üìä Loading data into scheduler:', {
                    resourcesCount: resources.length,
                    eventsCount: events.length,
                    resources: resources.slice(0, 3),  // Show first 3 resources
                    events: events.slice(0, 3)  // Show first 3 events
                });
                
                // Load the inline data into the scheduler project
                // Using single-assignment mode (resourceId on events), NO assignmentsData
                await scheduler.project.loadInlineData({
                    resourcesData: resources,
                    eventsData: events,
                    dependenciesData: []
                });
                
                console.log('‚úÖ Scheduler initialized successfully with loaded data');
                console.log('üìä Scheduler state:', {
                    resourceCount: scheduler.resourceStore.count,
                    eventCount: scheduler.eventStore.count,
                    startDate: scheduler.startDate,
                    endDate: scheduler.endDate,
                    viewPreset: scheduler.viewPreset
                });
                
                // Set up toolbar event handlers
                setupToolbarHandlers();
                
                // Update status
                updateStatus();
                
                // Set up periodic status updates
                setInterval(updateStatus, 30000); // Update every 30 seconds
                
                // Initial zoom to fit
                setTimeout(() => {
                    scheduler.zoomToFit({
                        leftMargin: 50,
                        rightMargin: 50
                    });
                }, 100);
                
            } catch (error) {
                console.error('‚ùå Failed to initialize scheduler:', error);
                schedulerInitialized = false;
                
                // Show error message
                const scheduler = document.getElementById('scheduler');
                if (scheduler) {
                    scheduler.innerHTML = `
                        <div class="error-message">
                            Failed to initialize scheduler: ${error.message}
                        </div>
                    `;
                }
            }
        }
        
        function setupToolbarHandlers() {
            // View selector
            const viewSelector = document.getElementById('viewSelector');
            viewSelector?.addEventListener('change', (e) => {
                const viewMap = {
                    'day': 'dayAndWeek',
                    'week': 'weekAndMonth',
                    'month': 'monthAndYear'
                };
                if (window.scheduler) {
                    window.scheduler.viewPreset = viewMap[e.target.value] || 'dayAndWeek';
                }
            });
            
            // Zoom controls
            document.getElementById('zoomInBtn')?.addEventListener('click', () => {
                if (window.scheduler) {
                    window.scheduler.zoomIn();
                }
            });
            
            document.getElementById('zoomOutBtn')?.addEventListener('click', () => {
                if (window.scheduler) {
                    window.scheduler.zoomOut();
                }
            });
            
            document.getElementById('zoomToFitBtn')?.addEventListener('click', () => {
                if (window.scheduler) {
                    window.scheduler.zoomToFit({
                        leftMargin: 50,
                        rightMargin: 50
                    });
                }
            });
            
            // Algorithm application
            document.getElementById('applyAlgorithmBtn')?.addEventListener('click', async () => {
                const algorithmSelector = document.getElementById('algorithmSelector');
                const algorithm = algorithmSelector?.value || 'asap';
                
                if (window.scheduler) {
                    console.log(`Applying ${algorithm.toUpperCase()} algorithm...`);
                    
                    const loadingOverlay = document.getElementById('loadingOverlay');
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'flex';
                    }
                    
                    try {
                        // Apply the algorithm
                        await applySchedulingAlgorithm(algorithm);
                        console.log(`‚úÖ ${algorithm.toUpperCase()} algorithm applied successfully`);
                    } catch (error) {
                        console.error(`‚ùå Error applying ${algorithm} algorithm:`, error);
                    } finally {
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }
                    }
                }
            });
            
            // Save schedule
            document.getElementById('saveSchedule')?.addEventListener('click', async () => {
                console.log('Saving schedule...');
                // Implement save functionality here
            });
        }
        
        async function applySchedulingAlgorithm(algorithm) {
            if (!window.scheduler || !window.scheduler.project) {
                console.error('Scheduler not initialized');
                return;
            }
            
            const project = window.scheduler.project;
            const events = project.eventStore.records;
            
            switch (algorithm) {
                case 'asap':
                    // Schedule all tasks as soon as possible
                    events.forEach(event => {
                        event.constraintType = 'startnoearlierthan';
                        event.constraintDate = new Date('2025-09-03');
                    });
                    break;
                    
                case 'alap':
                    // Schedule all tasks as late as possible
                    events.forEach(event => {
                        event.constraintType = 'finishnolaterthan';
                        event.constraintDate = new Date('2025-10-03');
                    });
                    break;
                    
                case 'critical':
                    // Identify and highlight critical path
                    console.log('Identifying critical path...');
                    // Critical path logic would go here
                    break;
                    
                case 'resource':
                    // Level resources to minimize overallocation
                    console.log('Leveling resources...');
                    // Resource leveling logic would go here
                    break;
            }
            
            // Refresh the scheduler
            await project.propagate();
            window.scheduler.refresh();
        }
        
        function updateStatus() {
            if (!window.scheduler || !window.scheduler.project) return;
            
            const events = window.scheduler.project.eventStore.count;
            const resources = window.scheduler.project.resourceStore.count;
            
            const statusMessage = document.getElementById('statusMessage');
            if (statusMessage) {
                statusMessage.textContent = `${events} operations scheduled`;
            }
            
            const lastUpdated = document.getElementById('lastUpdated');
            if (lastUpdated) {
                const now = new Date();
                lastUpdated.textContent = `Last updated: ${now.toLocaleTimeString()}`;
            }
            
            // Calculate resource utilization
            let totalHours = 0;
            window.scheduler.project.eventStore.forEach(event => {
                totalHours += event.duration || 0;
            });
            
            const utilization = document.getElementById('resourceUtilization');
            if (utilization) {
                const avgUtilization = resources > 0 ? Math.min(100, Math.round((totalHours / (resources * 40)) * 100)) : 0;
                utilization.textContent = `Resource utilization: ${avgUtilization}% (${totalHours.toFixed(1)}h total)`;
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeScheduler);
        } else {
            // DOM is already ready
            initializeScheduler();
        }
    </script>
</body>
</html>