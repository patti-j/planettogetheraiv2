<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Force refresh timestamp: 2025-10-01 21:40 v2 -->
    <title>Production Schedule - PlanetTogether</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <!-- Bryntum Scheduler Pro CSS -->
    <link rel="stylesheet" href="/schedulerpro.classic-light.css?v=633" id="scheduler-theme">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: auto;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 14px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .header h1 {
            color: #000000;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.9);
            padding: 0.75rem 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding-right: 0.75rem;
            border-right: 1px solid #e0e0e0;
            flex-shrink: 0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar label {
            font-size: 0.8125rem;
            color: #666;
            font-weight: 500;
            white-space: nowrap;
        }

        .toolbar select,
        .toolbar button {
            padding: 0.375rem 0.625rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar select:hover,
        .toolbar button:hover {
            background: #f5f5f5;
            border-color: #999;
        }

        .toolbar button {
            background: white;
            color: #333 !important;
            border: 1px solid #e0e0e0;
            font-weight: 400;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            transition: all 0.2s;
        }

        .toolbar button:hover {
            background: #e8f5e9;
            transform: translateY(-1px);
            border-color: #4CAF50;
            color: #2e7d32 !important;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.2);
        }
        
        .toolbar button.icon-only {
            padding: 0.375rem 0.5rem;
            min-width: 32px;
        }
        
        .toolbar button svg {
            width: 16px;
            height: 16px;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .toolbar {
                padding: 0.5rem 1rem;
                gap: 0.5rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .toolbar-group {
                padding-right: 0.75rem;
                flex-shrink: 0;
            }
            
            .toolbar label {
                display: none; /* Hide labels on mobile to save space */
            }
            
            .toolbar button span:not(.icon-text) {
                display: none; /* Hide button text on mobile, keep icons */
            }
            
            .toolbar button {
                padding: 0.5rem;
                min-width: 40px;
                min-height: 40px;
            }
            
            .toolbar select {
                max-width: 120px;
            }
            
            /* Make scheduler touch-friendly */
            .b-sch-event {
                min-height: 30px !important;
            }
            
            .b-grid-cell {
                padding: 4px !important;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1rem;
            }
            
            .toolbar {
                padding: 0.5rem;
            }
            
            /* Stack toolbar items vertically on very small screens */
            .toolbar-group {
                border-right: none;
                width: 100%;
                justify-content: space-between;
            }
        }

        .scheduler-container {
            flex: 1;
            margin: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #scheduler {
            flex: 1;
            min-height: 0;
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.95);
            padding: 0.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            color: #666;
            border-top: 1px solid #e0e0e0;
            flex-shrink: 0;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ff4444;
            color: white;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem;
            text-align: center;
        }
        
        /* Dark theme overrides */
        .dark-theme {
            background: #1a1a1a;
        }
        
        .dark-theme .header {
            background: rgba(30, 30, 30, 0.95);
            color: white;
        }
        
        .dark-theme .header h1 {
            color: #60a5fa;
        }
        
        .dark-theme .toolbar {
            background: rgba(40, 40, 40, 0.9);
            border-bottom-color: #444;
        }
        
        .dark-theme .toolbar label {
            color: #ccc;
        }
        
        .dark-theme .toolbar button {
            background: #2a2a2a;
            color: #e0e0e0 !important;
            border-color: #444;
        }
        
        .dark-theme .toolbar button:hover {
            background: #1b5e20;
            color: #a5d6a7 !important;
            border-color: #4CAF50;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
        }
        
        .dark-theme .toolbar select {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-theme .toolbar select:hover {
            background: #333;
            border-color: #666;
        }
        
        .dark-theme .status-bar {
            background: rgba(30, 30, 30, 0.95);
            color: #ccc;
            border-top-color: #444;
        }
        
        .dark-theme .scheduler-container {
            background: #2a2a2a;
        }
        
        /* Dark theme for scheduler using filter */
        .dark-theme #scheduler {
            filter: invert(0.9) hue-rotate(180deg);
        }
        
        /* Re-invert images and icons in dark mode */
        .dark-theme #scheduler img,
        .dark-theme #scheduler .b-icon {
            filter: invert(1) hue-rotate(-180deg);
        }
        
        /* Dependency lines styling - SOLID and DARK */
        .b-sch-dependency {
            stroke: #2d3748 !important; /* Very dark gray */
            stroke-width: 2.5 !important;
            opacity: 1 !important;
            stroke-dasharray: none !important; /* SOLID lines */
        }
        
        .b-sch-dependency-arrow {
            fill: #2d3748 !important;
            stroke: #2d3748 !important;
        }
        
        .b-sch-dependency:hover {
            stroke: #1a202c !important; /* Almost black on hover */
            stroke-width: 3 !important;
            opacity: 1 !important;
        }
        
        .b-sch-dependency-arrow:hover {
            fill: #1a202c !important;
            stroke: #1a202c !important;
        }
        
        /* Visual-only dependencies - SOLID dark lines */
        .b-sch-dependency.b-inactive,
        .b-sch-dependency.visual-dependency {
            stroke: #2d3748 !important; /* Dark gray */
            stroke-width: 2.5 !important;
            opacity: 0.9 !important;
            stroke-dasharray: none !important; /* SOLID - no dashes */
        }
        
        .b-sch-dependency.b-inactive .b-sch-dependency-arrow,
        .b-sch-dependency.visual-dependency .b-sch-dependency-arrow {
            fill: #2d3748 !important;
            stroke: #2d3748 !important;
            opacity: 0.9 !important;
        }
        
        /* Critical path dependency styling */
        .b-sch-dependency.b-critical {
            stroke: #ff4444 !important;
            stroke-width: 3 !important;
        }
        
        .b-sch-dependency.b-critical .b-sch-dependency-arrow {
            fill: #ff4444 !important;
            stroke: #ff4444 !important;
        }
        
        /* Header actions styling */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        /* Navigation Menu - Match main app */
        .nav-menu {
            position: fixed;
            top: 0;
            left: -320px;
            width: 320px;
            height: 100vh;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            transition: left 0.3s ease;
            z-index: 2000;
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.15);
        }
        
        .nav-menu.open {
            left: 0;
        }
        
        .nav-menu-header {
            background: #0f172a;
            color: #f8fafc;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }
        
        .nav-menu-header h3 {
            margin: 0;
        }
        
        .close-menu, .close-max-ai {
            background: transparent;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
        }
        
        .nav-menu-items {
            padding: 1rem;
        }
        
        .nav-item {
            display: block;
            padding: 0.75rem 1rem;
            color: #333;
            text-decoration: none;
            border-radius: 4px;
            transition: background 0.2s;
            margin-bottom: 0.5rem;
        }
        
        .nav-item:hover {
            background: #f5f5f5;
        }
        
        .nav-item.active {
            background: #f0f0f0;
            color: #333;
            font-weight: 500;
        }
        
        /* Max AI Panel - Match main app */
        .max-ai-panel {
            position: fixed;
            top: 0;
            right: 0; /* Visible by default to showcase scheduler features */
            width: 400px;
            height: 100vh;
            background: #ffffff;
            border-left: 1px solid #e2e8f0;
            transition: right 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
        }
        
        .max-ai-panel.closed {
            right: -400px;
        }
        
        .max-ai-header {
            background: #0f172a;
            color: #f8fafc;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }
        
        .max-ai-header h3 {
            margin: 0;
        }
        
        .max-ai-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .max-ai-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .max-ai-message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .max-ai-message.assistant {
            background: #f0f0f0;
            font-size: 0.9rem;
        }
        
        .max-ai-message.user {
            background: rgba(59, 130, 246, 0.1);
            margin-left: 2rem;
        }
        
        .max-ai-message ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }
        
        .max-ai-message strong {
            font-weight: 600;
            color: #333;
        }
        
        .max-ai-input {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #e0e0e0;
            gap: 0.5rem;
        }
        
        .max-ai-input input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.875rem;
        }
        
        .max-ai-input button {
            padding: 0.5rem 1rem;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .max-ai-input button:hover {
            background: #555;
        }
        
        /* Dark theme for nav menu and Max AI */
        .dark-theme .nav-menu,
        .dark-theme .max-ai-panel {
            background: #0f172a;
            color: #f8fafc;
            border-color: #334155;
        }
        
        .dark-theme .nav-menu-header,
        .dark-theme .max-ai-header {
            background: #1e293b;
            border-bottom-color: #475569;
        }
        
        .dark-theme .constraint-modal-content {
            background: #2a2a2a;
            color: white;
        }
        
        .dark-theme .constraint-modal-header {
            background: #333;
            border-bottom-color: #444;
        }
        
        .dark-theme .constraint-modal-header h2 {
            color: white;
        }
        
        .dark-theme .constraint-modal-close {
            color: #ccc;
        }
        
        .dark-theme .constraint-modal-close:hover {
            color: white;
        }
        
        .dark-theme .constraint-section h3 {
            color: white;
            border-bottom-color: #444;
        }
        
        .dark-theme .constraint-group h4 {
            color: #ccc;
        }
        
        .dark-theme .constraint-item:hover {
            background: #333;
        }
        
        .dark-theme .constraint-label {
            color: #e0e0e0;
        }
        
        .dark-theme .constraint-modal-footer {
            background: #333;
            border-top-color: #444;
        }
        
        .dark-theme .constraint-modal-footer button {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-theme .constraint-modal-footer button:hover {
            background: #1b5e20;
            color: #a5d6a7;
            border-color: #4CAF50;
        }
        
        .dark-theme .constraint-modal-footer button.apply {
            background: #2e7d32;
            color: white;
            border-color: #2e7d32;
        }
        
        .dark-theme .constraint-modal-footer button.apply:hover {
            background: #4CAF50;
        }
        
        .dark-theme .nav-item {
            color: #ccc;
        }
        
        .dark-theme .nav-item:hover {
            background: #333;
        }
        
        .dark-theme .nav-item.active {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .dark-theme .max-ai-message.assistant {
            background: #333;
            color: #ccc;
        }
        
        .dark-theme .max-ai-message.user {
            background: rgba(59, 130, 246, 0.2);
            color: #ccc;
        }
        
        .dark-theme .max-ai-input {
            border-top-color: #444;
        }
        
        .dark-theme .max-ai-input input {
            background: #333;
            color: white;
            border-color: #444;
        }
        
        /* Quick Actions Styles */
        .max-ai-quick-actions {
            padding: 0.75rem;
            background: linear-gradient(to right, #eff6ff, #e0e7ff);
            border-bottom: 1px solid #e0e0e0;
        }
        
        .dark-theme .max-ai-quick-actions {
            background: linear-gradient(to right, #1a2332, #202842);
            border-bottom: 1px solid #444;
        }
        
        .quick-actions-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .dark-theme .quick-actions-title {
            color: #cbd5e0;
        }
        
        .quick-actions-section {
            margin-bottom: 0.75rem;
        }
        
        .quick-actions-label {
            font-size: 0.75rem;
            color: #718096;
            margin-bottom: 0.5rem;
        }
        
        .dark-theme .quick-actions-label {
            color: #a0aec0;
        }
        
        .quick-actions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .quick-action-btn {
            padding: 0.5rem;
            font-size: 0.75rem;
            background: white;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        
        .dark-theme .quick-action-btn {
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #e0e0e0;
        }
        
        .quick-action-btn:hover {
            background: #edf2f7;
            border-color: #666;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dark-theme .quick-action-btn:hover {
            background: #374151;
            border-color: #666;
        }
        
        /* Animation styles */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* Constraint Settings Styles */
        .constraint-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }
        
        .constraint-modal.active {
            display: flex;
        }
        
        .constraint-modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .constraint-modal-header {
            padding: 1rem 1.5rem;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .constraint-modal-header h2 {
            margin: 0;
            font-size: 1.25rem;
            color: #333;
        }
        
        .constraint-modal-close {
            background: transparent;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .constraint-modal-close:hover {
            color: #333;
        }
        
        .constraint-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .constraint-section {
            margin-bottom: 2rem;
        }
        
        .constraint-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            color: #333;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .constraint-group {
            margin-bottom: 1rem;
        }
        
        .constraint-group h4 {
            margin: 0 0 0.5rem 0;
            font-size: 0.95rem;
            color: #555;
            font-weight: 600;
        }
        
        .constraint-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .constraint-item:hover {
            background: #f9f9f9;
        }
        
        .constraint-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
            margin-right: 1rem;
        }
        
        .constraint-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .constraint-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 22px;
        }
        
        .constraint-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        .constraint-toggle input:checked + .constraint-toggle-slider {
            background-color: #4CAF50;
        }
        
        .constraint-toggle input:checked + .constraint-toggle-slider:before {
            transform: translateX(18px);
        }
        
        .constraint-label {
            flex: 1;
            font-size: 0.875rem;
            color: #333;
            cursor: pointer;
        }
        
        .constraint-modal-footer {
            padding: 1rem 1.5rem;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .constraint-modal-footer button {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
        }
        
        .constraint-modal-footer button:hover {
            background: #f5f5f5;
        }
        
        .constraint-modal-footer button.apply {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .constraint-modal-footer button.apply:hover {
            background: #45a049;
        }
        
        .quick-action-btn.full-width {
            grid-column: span 2;
        }
        
        .view-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .view-control-btn {
            flex: 1;
            padding: 0.4rem;
            font-size: 0.7rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .dark-theme .view-control-btn {
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #e0e0e0;
        }
        
        .view-control-btn:hover {
            background: #f7fafc;
            border-color: #a0aec0;
        }
        
        .dark-theme .view-control-btn:hover {
            background: #374151;
        }
        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .scheduler-notification {
            transition: all 0.3s ease-out;
        }
        
        /* Dependency line styling */
        /* Make dependency lines darker and solid in light mode */
        .b-sch-dependency,
        .b-sch-dependency-line {
            stroke: #2d3748 !important; /* Very dark gray for excellent visibility */
            stroke-width: 2.5 !important;
            opacity: 1 !important;
            stroke-dasharray: none !important; /* Solid lines */
        }
        
        /* Visual-only dependency styling - solid lines, slightly darker */
        .visual-dependency,
        .visual-dependency .b-sch-dependency-line {
            stroke: #1a202c !important; /* Almost black for maximum visibility */
            stroke-width: 2.5 !important;
            stroke-dasharray: none !important; /* SOLID lines - no dashes */
            opacity: 0.9 !important;
        }
        
        /* Inactive dependency styling - ensure they don't interfere */
        .b-inactive.b-sch-dependency,
        .b-sch-dependency.b-inactive {
            pointer-events: none !important;
            stroke: #2d3748 !important; /* Dark solid lines */
            stroke-dasharray: none !important; /* SOLID lines */
            opacity: 0.85 !important;
        }
        
        /* Dark theme dependency lines */
        .dark-theme .b-sch-dependency,
        .dark-theme .b-sch-dependency-line {
            stroke: #cbd5e0 !important; /* Light gray for dark theme */
            opacity: 1 !important;
            stroke-dasharray: none !important; /* Solid lines */
        }
        
        .dark-theme .visual-dependency,
        .dark-theme .visual-dependency .b-sch-dependency-line {
            stroke: #e2e8f0 !important; /* Very light for dark theme */
            stroke-dasharray: none !important; /* SOLID lines */
            opacity: 0.95 !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Production Schedule</h1>
        <div class="header-actions">
            <span id="lastUpdate">Last updated: --</span>
        </div>
    </div>
    

    <div class="toolbar">
        <div class="toolbar-group">
            <label for="viewPreset">View:</label>
            <select id="viewPreset">
                <option value="hourAndDay">Hour & Day</option>
                <option value="dayAndWeek" selected>Day & Week</option>
                <option value="weekAndMonth">Week & Month</option>
                <option value="monthAndYear">Month & Year</option>
            </select>
        </div>

        <div class="toolbar-group">
            <label for="planningAreaFilter">Planning Area:</label>
            <select id="planningAreaFilter" data-testid="select-planning-area">
                <option value="all">All Areas</option>
            </select>
            <button id="applyPlanningAreaFilter" class="scheduler-btn" data-testid="button-apply-planning-area" style="margin-left: 0.5rem;">
                Apply Filter
            </button>
        </div>

        <div class="toolbar-group" style="display: flex; gap: 0.25rem;">
            <button id="zoomIn" class="icon-only" title="Zoom In">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <button id="zoomOut" class="icon-only" title="Zoom Out">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <button id="zoomToFit" class="icon-only" title="Fit to View">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                </svg>
            </button>
        </div>

        <div class="toolbar-group">
            <label for="schedulingAlgorithm">Algorithm:</label>
            <select id="schedulingAlgorithm">
                <option value="asap">ASAP (Forward)</option>
                <option value="alap">ALAP (Backward)</option>
            </select>
            <button id="applyScheduling">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
                <span>Apply</span>
            </button>
        </div>

        <div class="toolbar-group">
            <button id="saveSchedule">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                    <polyline points="7 3 7 8 15 8"></polyline>
                </svg>
                <span>Save</span>
            </button>
            <button id="loadScheduleBtn" onclick="loadSchedule()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                <span>Load</span>
            </button>
            <button id="refreshSchedule" class="icon-only" title="Refresh">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
            </button>
        </div>
    </div>

    <div class="scheduler-container">
        <div id="scheduler"></div>
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <div class="status-bar">
        <span id="operationCount">0 operations scheduled</span>
        <span id="resourceUtilization">Resource utilization: --</span>
    </div>

    <!-- Load Bryntum Scheduler Pro UMD -->
    <script id="bryntum-script" src="/schedulerpro.umd.js?v=633"></script>
    
    <script>
        console.log('üî• SCHEDULER SCRIPT STARTING...');
        
        // Store authentication token globally
        let globalAuthToken = null;
        
        // Listen for authentication token from parent window
        window.addEventListener('message', function(event) {
            if (event.data?.type === 'SET_AUTH_TOKEN' && event.data?.token) {
                console.log('üîê Received auth token from parent window');
                globalAuthToken = event.data.token;
                // Also store in localStorage for persistence
                localStorage.setItem('auth_token', event.data.token);
            }
        });
        
        // Helper function to get authentication token
        function getAuthToken() {
            // First check global token (from postMessage), then localStorage, then parent window
            return globalAuthToken || 
                   localStorage.getItem('auth_token') || 
                   window.parent?.localStorage?.getItem('auth_token');
        }
        
        // Global error handler to catch any errors
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('‚ùå Global error:', msg, 'at', url + ':' + lineNo);
            console.error('Error object:', error);
            
            // Show error in UI
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.innerHTML = `
                    <div style="color: red; font-size: 16px; padding: 20px; background: white; border-radius: 8px;">
                        <h3>Scheduler Error</h3>
                        <p>${msg}</p>
                        <p>Please refresh the page or contact support.</p>
                    </div>
                `;
            }
            return true;
        };
        
        // Wait for Bryntum library to be available
        function waitForBryntum(callback) {
            let timeoutHandle = null;
            let intervalCleared = false;
            
            const checkInterval = setInterval(() => {
                // Check multiple possible locations for SchedulerPro (from UMD bundle)
                if (typeof bryntum !== 'undefined' && bryntum.schedulerpro && bryntum.schedulerpro.SchedulerPro) {
                    if (!intervalCleared) {
                        clearInterval(checkInterval);
                        intervalCleared = true;
                        if (timeoutHandle) {
                            clearTimeout(timeoutHandle);
                        }
                        console.log('‚úÖ Bryntum SchedulerPro loaded at bryntum.schedulerpro.SchedulerPro');
                        // Make SchedulerPro globally available for easier access
                        window.SchedulerPro = bryntum.schedulerpro.SchedulerPro;
                        callback();
                    }
                } else if (typeof SchedulerPro !== 'undefined') {
                    // Check if SchedulerPro is directly on window
                    if (!intervalCleared) {
                        clearInterval(checkInterval);
                        intervalCleared = true;
                        if (timeoutHandle) {
                            clearTimeout(timeoutHandle);
                        }
                        console.log('‚úÖ Bryntum SchedulerPro loaded directly on window');
                        window.SchedulerPro = SchedulerPro;
                        callback();
                    }
                } else if (typeof window.SchedulerPro !== 'undefined') {
                    // Already available
                    if (!intervalCleared) {
                        clearInterval(checkInterval);
                        intervalCleared = true;
                        if (timeoutHandle) {
                            clearTimeout(timeoutHandle);
                        }
                        console.log('‚úÖ Bryntum SchedulerPro already available on window');
                        callback();
                    }
                } else {
                    console.log('‚è≥ Waiting for Bryntum SchedulerPro to load...');
                    // Debug: Log what's available
                    if (typeof bryntum !== 'undefined') {
                        console.log('  bryntum object found, contents:', Object.keys(bryntum || {}));
                        
                        // Check all possible locations where SchedulerPro might be
                        if (bryntum.schedulerpro) {
                            console.log('  bryntum.schedulerpro found, contents:', Object.keys(bryntum.schedulerpro || {}));
                            
                            // Check if SchedulerPro is a class in schedulerpro namespace
                            for (const key of Object.keys(bryntum.schedulerpro)) {
                                const value = bryntum.schedulerpro[key];
                                if (typeof value === 'function' && key.includes('Scheduler')) {
                                    console.log(`    Found potential SchedulerPro class: bryntum.schedulerpro.${key}`);
                                    
                                    // Try to use it as SchedulerPro
                                    if (!intervalCleared) {
                                        clearInterval(checkInterval);
                                        intervalCleared = true;
                                        if (timeoutHandle) {
                                            clearTimeout(timeoutHandle);
                                        }
                                        console.log(`‚úÖ Using bryntum.schedulerpro.${key} as SchedulerPro`);
                                        window.SchedulerPro = value;
                                        callback();
                                        return;
                                    }
                                }
                            }
                        }
                        
                        // Also check root bryntum for any Scheduler classes
                        for (const key of Object.keys(bryntum)) {
                            if (key.toLowerCase().includes('scheduler')) {
                                console.log(`  Found scheduler-related namespace: bryntum.${key}`);
                                const namespace = bryntum[key];
                                if (namespace && typeof namespace === 'object') {
                                    console.log(`    Contents of bryntum.${key}:`, Object.keys(namespace).slice(0, 10));
                                }
                            }
                        }
                    }
                }
            }, 100);
            
            // Timeout after 10 seconds - but only show error if we still don't have Bryntum
            timeoutHandle = setTimeout(() => {
                if (!intervalCleared) {
                    clearInterval(checkInterval);
                    intervalCleared = true;
                    
                    // Double-check if Bryntum is really not loaded before showing error
                    if (typeof window.SchedulerPro === 'undefined' && 
                        (typeof bryntum === 'undefined' || !bryntum.schedulerpro?.SchedulerPro)) {
                        console.error('‚ùå Bryntum SchedulerPro failed to load after 10 seconds');
                        const loadingOverlay = document.getElementById('loadingOverlay');
                        // Only show error if loading overlay is visible and empty
                        if (loadingOverlay && loadingOverlay.style.display !== 'none' && !loadingOverlay.querySelector('.loading-spinner')) {
                            loadingOverlay.innerHTML = `
                                <div style="color: red; font-size: 16px; padding: 20px; background: white; border-radius: 8px;">
                                    <h3>Loading Error</h3>
                                    <p>Bryntum Scheduler Pro failed to load. Please refresh the page.</p>
                                </div>
                            `;
                        }
                    } else {
                        console.log('‚úÖ Bryntum already loaded, timeout cleared');
                    }
                }
            }, 10000);
        }
        
        // --- Planning area filter: robust wiring + safe filtering ---
        // Bind once, unconditionally
        document.addEventListener('click', (e) => {
            if (e.target?.id === 'applyPlanningAreaFilter') {
                e.preventDefault();
                handleApplyPlanningAreaFilter().catch(console.error);
            }
        });
        
        // Back-compat for inline onclick="applyPlanningAreaFilter()"
        window.applyPlanningAreaFilter = () => handleApplyPlanningAreaFilter();

        // Filters: resources by planning_area, then events by the visible resources via assignmentStore
        async function handleApplyPlanningAreaFilter() {
            const ddl = document.getElementById('planningAreaFilter');
            const area = ddl?.value || 'all';
            const sch = window.scheduler;
            const { resourceStore, eventStore, assignmentStore } = sch;

            sch.suspendRefresh();
            resourceStore.clearFilters();
            eventStore.clearFilters();

            if (area !== 'all') {
                resourceStore.filter(r => (r.planning_area ?? r.data?.planning_area) === area);
                const visibleResourceIds = new Set(resourceStore.records.map(r => String(r.id)));
                eventStore.filter(ev => {
                    const a = assignmentStore.find(x => x.eventId === ev.id);
                    return a ? visibleResourceIds.has(String(a.resourceId)) : false;
                });
            }

            sch.resumeRefresh();
            sch.refresh(); 
            sch.refreshRows();
            setTimeout(() => sch.zoomToFit({ leftMargin: 50, rightMargin: 50 }), 100);
        }
        
        // Function to render PT dependencies as visual-only SVG lines
        function renderPTDependencyLines(scheduler, dependencies) {
            try {
                console.log(`üé® Rendering ${dependencies.length} PT dependency lines...`);
                
                // Wait for scheduler to be fully rendered
                setTimeout(() => {
                    // Get scheduler element
                    const schedulerEl = scheduler.element;
                    
                    // Remove any existing dependency container
                    const existingSvg = document.querySelector('.pt-dependency-overlay');
                    if (existingSvg) {
                        existingSvg.remove();
                    }
                    
                    // Create SVG container as overlay OUTSIDE Bryntum's DOM
                    const svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svgContainer.setAttribute('class', 'pt-dependency-overlay');
                    svgContainer.style.position = 'absolute';
                    svgContainer.style.top = '0';
                    svgContainer.style.left = '0';
                    svgContainer.style.width = '100%';
                    svgContainer.style.height = '100%';
                    svgContainer.style.pointerEvents = 'none';
                    svgContainer.style.zIndex = '100';
                    
                    // Find the scheduler's main container and add as sibling
                    const schedulerWrapper = schedulerEl.closest('.scheduler-container') || schedulerEl.parentElement;
                    schedulerWrapper.style.position = 'relative';
                    schedulerWrapper.appendChild(svgContainer);
                    
                    // Draw each dependency as a line
                    let linesDrawn = 0;
                    dependencies.forEach(dep => {
                        const fromEvent = scheduler.eventStore.getById(dep.from);
                        const toEvent = scheduler.eventStore.getById(dep.to);
                        
                        if (fromEvent && toEvent) {
                            // Get event elements
                            const fromEl = scheduler.getElementFromEventRecord(fromEvent);
                            const toEl = scheduler.getElementFromEventRecord(toEvent);
                            
                            if (fromEl && toEl) {
                                // Get positions
                                const fromRect = fromEl.getBoundingClientRect();
                                const toRect = toEl.getBoundingClientRect();
                                const containerRect = svgContainer.getBoundingClientRect();
                                
                                // Calculate line coordinates (from right edge of source to left edge of target)
                                const x1 = fromRect.right - containerRect.left;
                                const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
                                const x2 = toRect.left - containerRect.left;
                                const y2 = toRect.top + toRect.height / 2 - containerRect.top;
                                
                                // Create SVG path for dependency line with arrow
                                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                
                                // Create curved line path
                                const midX = (x1 + x2) / 2;
                                const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                                
                                path.setAttribute('d', d);
                                path.setAttribute('stroke', '#2d3748'); // Dark gray
                                path.setAttribute('stroke-width', '2.5');
                                path.setAttribute('fill', 'none');
                                path.setAttribute('marker-end', 'url(#arrowhead)');
                                path.setAttribute('class', 'pt-dependency-line');
                                
                                svgContainer.appendChild(path);
                                linesDrawn++;
                            }
                        }
                    });
                    
                    // Add arrowhead marker definition if not exists
                    if (!svgContainer.querySelector('#arrowhead')) {
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                        marker.setAttribute('id', 'arrowhead');
                        marker.setAttribute('markerWidth', '10');
                        marker.setAttribute('markerHeight', '10');
                        marker.setAttribute('refX', '9');
                        marker.setAttribute('refY', '3');
                        marker.setAttribute('orient', 'auto');
                        
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 0, 10 3, 0 6');
                        polygon.setAttribute('fill', '#2d3748');
                        
                        marker.appendChild(polygon);
                        defs.appendChild(marker);
                        svgContainer.appendChild(defs);
                    }
                    
                    console.log(`‚úÖ PT dependency lines rendered successfully: ${linesDrawn} lines drawn`);
                }, 500); // Wait 500ms for scheduler to render
                
            } catch (error) {
                console.error('‚ùå Error rendering PT dependency lines:', error);
            }
        }
        
        // Make function globally accessible
        window.renderPTDependencyLines = renderPTDependencyLines;
        
        // Wait for DOM to load
        // Guard to prevent multiple initialization attempts
        let schedulerInitialized = false;
        
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ DOMContentLoaded event fired - Starting scheduler initialization...');
            
            // Prevent multiple initialization
            if (schedulerInitialized) {
                console.log('Scheduler already initialized, skipping...');
                return;
            }
            schedulerInitialized = true;
            
            // Wait for Bryntum library to load before proceeding
            waitForBryntum(async () => {
                try {
                    console.log('üìä Bryntum loaded successfully, starting scheduler initialization...');
                    console.log('‚úÖ Bryntum SchedulerPro loaded successfully', window.SchedulerPro);
                    
                    // Notify parent window that scheduler is ready
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'SCHEDULER_READY' }, '*');
                    console.log('üì§ Sent SCHEDULER_READY message to parent');
                }
                
                // Set today's date to September 3, 2025
                const today = new Date(2025, 8, 3); // September 3, 2025
                today.setHours(8, 0, 0, 0); // Start at 8 AM
                
                // Helper to create a date relative to September 3, 2025
                function createDate(hoursFromNow) {
                    const date = new Date(2025, 8, 3); // September 3, 2025
                    date.setHours(8 + hoursFromNow, 0, 0, 0); // Start at 8 AM
                    return date;
                }
                
                // Planning area filter state
                let selectedPlanningArea = 'all';
                let lastScheduledArea = '';
                let allPlanningAreas = [];
                
                // Load all planning areas for the dropdown (once on startup)
                async function loadPlanningAreas() {
                    try {
                        // Get auth token using helper function
                        const authToken = getAuthToken();
                        const authHeaders = authToken ? { 'Authorization': `Bearer ${authToken}` } : {};
                        
                        const response = await fetch('/api/resources', { headers: authHeaders });
                        if (response.ok) {
                            const allResources = await response.json();
                            const areas = new Set();
                            allResources.forEach(resource => {
                                if (resource.planning_area) {
                                    areas.add(resource.planning_area);
                                }
                            });
                            allPlanningAreas = Array.from(areas).sort();
                            
                            // Populate dropdown
                            const dropdown = document.getElementById('planningAreaFilter');
                            allPlanningAreas.forEach(area => {
                                const option = document.createElement('option');
                                option.value = area;
                                option.textContent = area;
                                option.setAttribute('data-testid', `option-planning-area-${area}`);
                                dropdown.appendChild(option);
                            });
                            
                            console.log('‚úÖ Planning areas loaded:', allPlanningAreas);
                        }
                    } catch (error) {
                        console.error('Error loading planning areas:', error);
                    }
                }
                
                // Load planning areas first
                await loadPlanningAreas();
                
                // NOTE: Click listener for applyPlanningAreaFilter button is already
                // attached via document.addEventListener at line 1145-1150
                // No need for duplicate listener here
                console.log('‚úÖ Planning area filter button handler already attached via document click delegation');
                
                // Fetch real PT operations and resources from the backend
                let resources = [];
                let ptOperations = [];
                let resourceCapabilities = {};
                let fetchedDependencies = []; // Store dependencies at a higher scope
                
                try {
                    // Get auth token using helper function
                    const authToken = getAuthToken();
                    const authHeaders = authToken ? { 'Authorization': `Bearer ${authToken}` } : {};
                    
                    // Fetch resources, PT operations, jobs, and dependencies from the backend APIs
                    // NOTE: Dependencies are for visual display only - ALAP uses sequence numbers for scheduling
                    const timestamp = Date.now(); // Cache-busting timestamp
                    const [resourcesResponse, operationsResponse, dependenciesResponse, capabilitiesResponse, jobsResponse] = await Promise.all([
                        fetch('/api/resources?_=' + timestamp, { headers: authHeaders }),
                        fetch('/api/pt-operations?_=' + timestamp, { headers: authHeaders }), 
                        fetch('/api/pt-dependencies?_=' + timestamp, { headers: authHeaders }), // Keep for visual dependency lines
                        fetch('/api/resources-with-capabilities?_=' + timestamp, { headers: authHeaders }),
                        fetch('/api/jobs?_=' + timestamp, { headers: authHeaders }) // CRITICAL: Fetch jobs directly to get real priorities
                    ]);
                    
                    if (resourcesResponse.ok) {
                        resources = await resourcesResponse.json();
                        console.log('‚úÖ Resources fetched successfully:', resources.length);
                        console.log('First 3 resources:', resources.slice(0, 3));
                        
                        // CRITICAL: Sort resources to ensure proper grouping 
                        // (fermentation tanks together, bright tanks together, packaging together)
                        // Define order for resource types
                        const getOrder = (name) => {
                            const lowerName = name.toLowerCase();
                            // 1. MILLING (top)
                            if (lowerName.includes('mill')) return 1;
                            // 2. MASHING
                            if (lowerName.includes('mash')) return 2;
                            // 3. LAUTERING
                            if (lowerName.includes('lauter')) return 3;
                            // 4. BOILING/KETTLE
                            if (lowerName.includes('boil') || lowerName.includes('kettle')) return 4;
                            // 5. WHIRLPOOL
                            if (lowerName.includes('whirlpool')) return 5;
                            // 6. COOLING
                            if (lowerName.includes('cool')) return 6;
                            // 7. ALL FERMENTATION TANKS (grouped together)
                            if (lowerName.includes('ferment')) return 7;
                            // 8. ALL BRIGHT/CONDITIONING TANKS (grouped together)
                            if (lowerName.includes('bright') || lowerName.includes('condition')) return 8;
                            // 9. PASTEURIZATION
                            if (lowerName.includes('pasteur')) return 9;
                            // 10. ALL PACKAGING/FILLING (bottling and canning grouped together)
                            if (lowerName.includes('bottle') || lowerName.includes('can') || lowerName.includes('filler') || lowerName.includes('packag')) return 10;
                            // 11. Any other resources
                            return 11;
                        };
                        
                        // Sort resources and add explicit sortOrder field
                        resources.sort((a, b) => {
                            const aName = (a.name || '').toLowerCase();
                            const bName = (b.name || '').toLowerCase();
                            
                            const aOrder = getOrder(aName);
                            const bOrder = getOrder(bName);
                            
                            // First sort by type order
                            if (aOrder !== bOrder) {
                                return aOrder - bOrder;
                            }
                            
                            // Within same type, sort alphabetically by name
                            return aName.localeCompare(bName);
                        });
                        
                        // Add explicit sortOrder field to each resource to prevent Bryntum from re-sorting
                        resources = resources.map((resource, index) => ({
                            ...resource,
                            sortOrder: index + 1,  // Add explicit sort order
                            // Override the numeric ID with a string to prevent numeric sorting
                            originalId: resource.id,
                            id: `resource_${index + 1}_${resource.id}`,
                            // CRITICAL: Explicitly preserve planning_area field for filtering
                            planning_area: resource.planning_area || resource.planning_area_name || ''
                        }));
                        
                        console.log('‚úÖ Resources sorted by operational sequence:');
                        resources.forEach((r, idx) => {
                            console.log(`  ${idx + 1}. ${r.name} (sortOrder: ${r.sortOrder}, id: ${r.id}, planning_area: ${r.planning_area || 'NONE'})`);
                        });
                    } else {
                        console.error('‚ùå Failed to fetch resources:', resourcesResponse.status);
                        // No fallback - let resources stay empty rather than showing wrong equipment
                        resources = [];
                    }
                    
                    // REMOVED: Unscheduled resource line
                    // resources.unshift({
                    //     id: 'unscheduled',
                    //     name: 'üîÑ Unscheduled Operations',
                    //     category: 'Unscheduled',
                    //     eventColor: '#808080' // Gray color for unscheduled items
                    // });
                    
                    if (operationsResponse.ok) {
                        ptOperations = await operationsResponse.json();
                        console.log('‚úÖ PT Operations fetched successfully:', ptOperations.length);
                        if (ptOperations.length > 0) {
                            console.log('‚úÖ First PT operation sample:', ptOperations[0]);
                        }
                        
                        // üî¥ CRITICAL DEBUG: Check job priorities from API
                        console.log('üî¥ API JOB PRIORITY DEBUG - First 5 operations:', 
                            ptOperations.slice(0, 5).map(op => ({
                                name: op.name,
                                jobName: op.jobName,
                                jobPriority: op.jobPriority,
                                jobPriorityType: typeof op.jobPriority,
                                priority: op.priority,
                                allFields: Object.keys(op)
                            }))
                        );
                        
                        // Check specifically for IPA operations
                        const ipaOps = ptOperations.filter(op => op.jobName?.includes('IPA'));
                        if (ipaOps.length > 0) {
                            console.log('üî¥ IPA operations found:', 
                                ipaOps.map(op => ({
                                    name: op.name,
                                    jobName: op.jobName,
                                    jobPriority: op.jobPriority
                                }))
                            );
                        }
                    } else {
                        console.error('‚ùå Failed to fetch PT operations:', operationsResponse.status);
                    }
                    
                    // Process dependencies (for visual display only - ALAP uses sequence numbers)
                    if (dependenciesResponse && dependenciesResponse.ok) {
                        const deps = await dependenciesResponse.json();
                        // CRITICAL FIX: API returns 'from' and 'to' directly, not 'fromEvent' and 'toEvent'
                        fetchedDependencies = deps.map(dep => ({
                            id: String(dep.id),  // Ensure ID is a string
                            from: dep.from,      // Correct field name from API
                            to: dep.to,          // Correct field name from API
                            type: dep.type || 2, // Default to Finish-to-Start
                            lag: dep.lag || 0,
                            lagUnit: dep.lagUnit || 'hour',
                            fromEvent: dep.from, // Also include for compatibility
                            toEvent: dep.to,     // Also include for compatibility
                            // Mark as inactive so they show visually but don't constrain
                            inactive: true,
                            cls: 'visual-dependency' // CSS class for visual styling
                        }));
                        console.log('‚úÖ Dependencies fetched from database (for visual display):', fetchedDependencies.length);
                        if (fetchedDependencies.length > 0) {
                            console.log('Sample dependency:', fetchedDependencies[0]);
                            // Validate the dependency has required fields
                            const validDeps = fetchedDependencies.filter(d => d.from && d.to);
                            console.log(`‚úÖ ${validDeps.length}/${fetchedDependencies.length} dependencies have valid from/to fields`);
                        }
                    } else {
                        console.warn('Failed to fetch dependencies, using empty array');
                    }
                    
                    // Process jobs to get real priorities
                    let jobPriorityMap = new Map();
                    if (jobsResponse && jobsResponse.ok) {
                        const jobs = await jobsResponse.json();
                        console.log('‚úÖ Jobs fetched successfully:', jobs.length);
                        
                        // Build simple job priority map from real jobs data
                        jobs.forEach(job => {
                            const priority = job.priority || 999;
                            // Map by various possible job ID fields
                            if (job.id) jobPriorityMap.set(String(job.id), priority);
                            if (job.external_id) jobPriorityMap.set(String(job.external_id), priority);
                            if (job.batch_id) jobPriorityMap.set(String(job.batch_id), priority);
                            if (job.name) jobPriorityMap.set(job.name, priority);
                            
                            console.log(`üìä Job ${job.name || job.id}: Priority ${priority}`);
                        });
                        
                        console.log('‚úÖ Job priority map built with', jobPriorityMap.size, 'entries');
                        console.log('Job priorities:', Array.from(jobPriorityMap.entries()));
                    } else {
                        console.warn('Failed to fetch jobs, will use fallback priorities');
                    }
                    
                    // Store job priority map globally for ASAP algorithm
                    window.jobPriorityMap = jobPriorityMap;
                    
                    // Process resource capabilities
                    if (capabilitiesResponse && capabilitiesResponse.ok) {
                        const capabilitiesData = await capabilitiesResponse.json();
                        console.log('‚úÖ Resource capabilities fetched successfully');
                        console.log('Capabilities data:', capabilitiesData);
                        capabilitiesData.forEach(resource => {
                            resourceCapabilities[resource.id] = resource.capabilities || [];
                            console.log(`Resource ${resource.name} (ID: ${resource.id}) has capabilities:`, resource.capabilities);
                        });
                        // Log specific resources for debugging
                        console.log('üç∫ Bright Tank 1 capabilities:', resourceCapabilities[8]);
                        console.log('üç∫ Bright Tank 2 capabilities:', resourceCapabilities[9]);
                        console.log('üç∫ Fermenter Tank 1 capabilities:', resourceCapabilities[5]);
                        console.log('üç∫ Fermenter Tank 2 capabilities:', resourceCapabilities[6]);
                        console.log('üç∫ Fermenter Tank 3 capabilities:', resourceCapabilities[7]);
                    }
                } catch (error) {
                    console.error('‚ùå Error fetching data:', error);
                    // No fallback - let resources stay empty rather than showing wrong equipment
                    resources = [];
                }

                // Map resources to create resource lookup by both ID and name
                const resourceMap = new Map();
                const resourceByName = new Map();
                const originalIdMap = new Map(); // Map original numeric IDs to new string IDs
                resources.forEach(resource => {
                    resourceMap.set(resource.id, resource);
                    resourceMap.set(resource.name, resource);
                    // Also create a name-based lookup for better matching
                    resourceByName.set(resource.name?.toLowerCase(), resource);
                    // Map original numeric ID to new string ID
                    if (resource.originalId) {
                        originalIdMap.set(resource.originalId, resource.id);
                    }
                });
                
                
                // Define capability mappings for brewing operations
                // Based on PT Resource Capabilities: 1=MILLING, 2=MASHING, 3=LAUTERING, 
                // 4=BOILING, 5=FERMENTATION, 6=CONDITIONING, 8=PACKAGING, 9=PASTEURIZATION
                function getRequiredCapability(operationName) {
                    if (!operationName) return null;
                    const name = operationName.toLowerCase();
                    
                    // Check most specific patterns first to avoid mismatches
                    if (name.includes('packag')) return 8;
                    if (name.includes('mill')) return 1;
                    if (name.includes('mash')) return 2;
                    if (name.includes('lauter')) return 3;
                    if (name.includes('boil')) return 4;
                    if (name.includes('ferment')) return 5;
                    if (name.includes('condition')) return 6;
                    if (name.includes('pasteur')) return 9;
                    
                    return null; // No specific capability required
                }
                
                // Transform PT operations into Bryntum events format
                // CRITICAL: Load operations but DON'T use overlapping scheduled times
                let events = ptOperations.map((operation, index) => {
                    // Log job names and priorities for debugging  
                    if (index < 5) {
                        console.log(`üî¥ PRIORITY DEBUG - Operation ${index}: ${operation.name}`);
                        console.log(`  üìä API jobPriority field: ${operation.jobPriority} (type: ${typeof operation.jobPriority})`);
                        console.log(`  üìä API priority field: ${operation.priority} (type: ${typeof operation.priority})`);
                        console.log(`  üìä Full operation:`, operation);
                    }
                    
                    // First try to find a matching resource based on capability
                    let resourceId = findResourceId(operation, resourceMap, resourceByName, resources, originalIdMap);
                    
                    // Check if operation is truly unscheduled (no valid resource assignment)
                    const isUnscheduled = !resourceId || resourceId === 'unscheduled' || !resources.find(r => r.id === resourceId && r.id !== 'unscheduled');
                    
                    let startDate;
                    
                    // Use the actual scheduled times from database - API sends them as startDate/endDate
                    if (operation.startDate) {
                        startDate = new Date(operation.startDate);
                        console.log(`üìÖ Using DB scheduled time for ${operation.name}: ${startDate.toISOString()}`);
                    } else {
                        // Fallback: Use base date if no scheduled time exists
                        const baseDate = new Date(2025, 8, 3, 7, 0, 0); // Sept 3, 7 AM
                        startDate = new Date(baseDate.getTime() + index * 30 * 60 * 1000);
                        console.log(`‚ö†Ô∏è No scheduled time for ${operation.name}, using fallback: ${startDate.toISOString()}`);
                    }
                    
                    // If no valid resource found, assign to unscheduled resource
                    if (isUnscheduled) {
                        resourceId = 'unscheduled';
                    }
                    
                    // Calculate duration - API sends duration in minutes from cycle_hrs
                    let duration = 2; // Default 2 hours
                    
                    // First try to use duration field from API (already in minutes from cycle_hrs)
                    if (operation.duration) {
                        duration = operation.duration / 60; // Convert minutes to hours
                        console.log(`üìä Using API duration for ${operation.name}: ${duration.toFixed(1)} hours`);
                    }
                    // Then try calculated from scheduled times (API sends endDate/startDate)
                    else if (operation.endDate && operation.startDate) {
                        const endDate = new Date(operation.endDate);
                        const startMs = new Date(operation.startDate).getTime();
                        duration = (endDate.getTime() - startMs) / (1000 * 60 * 60); // Convert to hours
                        console.log(`üìä Calculated duration from times for ${operation.name}: ${duration.toFixed(1)} hours`);
                    }
                    
                    // NO CAPPING - Use actual durations for realistic scheduling
                    // Fermentation can be 48+ hours, conditioning 24+ hours, etc.
                    console.log(`‚úÖ Operation ${operation.name} final duration: ${duration.toFixed(1)} hours`);
                    
                    return {
                        id: operation.id,
                        name: operation.name || `${operation.jobName || 'Job'}: ${operation.name || 'Operation'}`,
                        startDate: startDate,
                        duration: duration,
                        durationUnit: 'hour',
                        resourceId: resourceId,
                        percentDone: operation.percent_done || 0,
                        eventColor: isUnscheduled ? '#808080' : (operation.eventColor || getOperationColor(operation.name)),
                        // ASAP scheduling constraints (not for unscheduled operations)
                        constraintType: isUnscheduled ? null : 'startnoearlierthan', // No constraints for unscheduled
                        constraintDate: isUnscheduled ? null : startDate,
                        manuallyScheduled: false, // Allow automatic scheduling
                        draggable: true, // Allow dragging to schedule
                        // Additional PT operation data
                        jobId: operation.job_id || operation.jobId, // Use numeric job_id for priority lookup
                        jobExternalId: operation.job_external_id || operation.jobExternalId || operation.batch_id, // Store batch ID separately
                        jobName: operation.job_name || operation.jobName,
                        jobPriority: Number(operation.job_priority || operation.jobPriority), // Map from API field job_priority
                        jobDueDate: operation.job_due_date || operation.dueDate, // CRITICAL: Add job Need-By date for ALAP scheduling
                        operationName: operation.name,
                        resourceName: operation.resourceName,
                        isUnscheduled: isUnscheduled,
                        sequence_number: operation.sequence_number || operation.sequenceNumber || 0, // Map from API response
                        ptData: operation // Keep original PT data for algorithms
                    };
                }); // Include all operations, even unscheduled ones
                
                // DEBUG: Check what events have after mapping
                console.log('üî¥ PRIORITY DEBUG - First 3 events after mapping:', events.slice(0, 3).map(e => ({
                    name: e.name,
                    jobName: e.jobName,
                    jobPriority: e.jobPriority,
                    jobPriorityType: typeof e.jobPriority
                })));
                
                // LOG IMMEDIATELY to verify code is running
                console.log('üöÄ SCHEDULER LOADED - Total events:', events.length);
                console.log('First 3 events:', events.slice(0, 3));
                console.log('Event dates range:', events.length > 0 ? {
                    first: events[0]?.startDate,
                    last: events[events.length - 1]?.startDate
                } : 'no events');
                
                // Helper function to find the correct resource ID
                function findResourceId(operation, resourceMap, resourceByName, resources, originalIdMap) {
                    // First try to match by the operation's resource_id which is the original numeric ID
                    if (operation.resourceId && originalIdMap.has(operation.resourceId)) {
                        return originalIdMap.get(operation.resourceId);
                    }
                    if (operation.resource_id && originalIdMap.has(operation.resource_id)) {
                        return originalIdMap.get(operation.resource_id);
                    }
                    
                    // Try various ways to match the resource
                    if (operation.resourceId && resourceMap.has(operation.resourceId)) {
                        return operation.resourceId;
                    }
                    if (operation.resource_id && resourceMap.has(operation.resource_id)) {
                        return operation.resource_id;
                    }
                    // Try to match by exact name
                    if (operation.resourceName) {
                        if (resourceMap.has(operation.resourceName)) {
                            return resourceMap.get(operation.resourceName).id;
                        }
                        // Try case-insensitive match
                        const lowerName = operation.resourceName.toLowerCase();
                        if (resourceByName.has(lowerName)) {
                            return resourceByName.get(lowerName).id;
                        }
                        // If resource name exists but not found in map, create a new resource entry
                        if (operation.resourceName !== 'Resource null' && operation.resourceName !== 'Unassigned') {
                            // Create a dynamic resource ID based on the name
                            const dynamicId = `resource_${operation.resourceName.replace(/\s+/g, '_').toLowerCase()}`;
                            // Add it to resources if not already there
                            if (!resourceMap.has(dynamicId)) {
                                const newResource = {
                                    id: dynamicId,
                                    name: operation.resourceName,
                                    category: 'Manufacturing'
                                };
                                resources.push(newResource);
                                resourceMap.set(dynamicId, newResource);
                                resourceMap.set(operation.resourceName, newResource);
                                resourceByName.set(operation.resourceName.toLowerCase(), newResource);
                            }
                            return dynamicId;
                        }
                    }
                    // Don't fallback to a random resource if not found - return null for unscheduled
                    return null;
                }
                
                // Helper function to assign colors based on operation type (brewing-specific)
                // CRITICAL: Order checks from most specific to least specific to avoid mismatches
                function getOperationColor(operationName) {
                    if (!operationName) return '#2563eb'; // Blue
                    const name = operationName.toLowerCase();
                    
                    // Brewing-specific operations with distinct colors
                    // Check packaging FIRST before lager to avoid "Packaging - Lager" matching lager
                    if (name.includes('packag')) return '#ea580c'; // Orange
                    if (name.includes('milling') || name.includes('mill')) return '#2563eb'; // Blue
                    if (name.includes('mash')) return '#7c3aed'; // Purple  
                    if (name.includes('lauter')) return '#0891b2'; // Cyan
                    if (name.includes('boil')) return '#dc2626'; // Red
                    if (name.includes('ferment')) return '#059669'; // Green
                    if (name.includes('lager') && !name.includes('packag')) return '#059669'; // Green (but not packaging)
                    if (name.includes('condition')) return '#0d9488'; // Teal
                    if (name.includes('pasteur')) return '#7c2d12'; // Brown
                    
                    // Generic manufacturing operations
                    if (name.includes('machining')) return '#2563eb'; // Blue
                    if (name.includes('assembly')) return '#059669'; // Green
                    if (name.includes('quality') || name.includes('testing')) return '#7c3aed'; // Purple
                    if (name.includes('filtration')) return '#0d9488'; // Teal
                    if (name.includes('carbonation')) return '#eab308'; // Yellow
                    
                    return '#2563eb'; // Default blue
                }
                
                console.log(`üìä Transformed ${events.length} PT operations into Bryntum events`);
                
                // If we have no PT operations, don't create fake demo data
                if (events.length === 0) {
                    console.log('üìä No PT operations found - scheduler will be empty until operations are added');
                    // Keep events array empty - better to show an empty scheduler than wrong data
                }

                // ===== PT DEPENDENCIES VISUAL DISPLAY =====
                // Load PT dependencies from database as VISUAL-ONLY lines
                // These show workflow but DO NOT constrain scheduling
                // Conflict suppression handlers prevent any dependency conflict dialogs
                // Scheduling is based ONLY on: Job Priority (1=highest) and Operation Sequence Numbers
                
                let dependencies = [];
                
                console.log('===== DEPENDENCY CONFIGURATION =====');
                console.log('Dependencies: ENABLED for visual display (non-constraining)');
                console.log('Scheduling based on: Job Priority (1=highest) and Operation Sequence Numbers only');
                console.log('PT dependencies show workflow connections but do NOT affect scheduling');
                
                // Load PT dependencies from database for visual display
                if (fetchedDependencies && fetchedDependencies.length > 0) {
                    console.log(`üìã Loading ${fetchedDependencies.length} PT dependencies for visual display...`);
                    
                    // Map dependencies with inactive flag to prevent constraint enforcement
                    dependencies = fetchedDependencies.map(dep => ({
                        id: String(dep.id),
                        from: dep.source_operation_id || dep.from,  // Map database field to Bryntum field
                        to: dep.target_operation_id || dep.to,      // Map database field to Bryntum field
                        type: dep.type || 2, // 2 = Finish-to-Start
                        lag: dep.lag || 0,
                        lagUnit: dep.lagUnit || 'hour',
                        // Mark as inactive to prevent automatic constraint enforcement
                        inactive: true,
                        cls: 'visual-dependency'
                    }));
                    
                    console.log(`‚úÖ ${dependencies.length} PT dependencies ready for visual display`);
                } else {
                    console.log('‚ÑπÔ∏è No PT dependencies found in database');
                }

                // Detect mobile device
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                const isTablet = window.innerWidth > 768 && window.innerWidth <= 1024;
                
                // Choose appropriate view preset based on device
                let viewPreset = 'dayAndWeek';
                let resourceColumnWidth = 200;
                
                if (isMobile) {
                    viewPreset = 'weekAndDay';  // Wider view for mobile
                    resourceColumnWidth = 120;
                } else if (isTablet) {
                    viewPreset = 'weekAndDay';
                    resourceColumnWidth = 150;
                }
                
                // Configure columns based on device
                const schedulerColumns = [
                    { text: 'Resource', field: 'name', width: resourceColumnWidth, locked: isMobile }
                ];
                
                // Create scheduler instance with ASAP scheduling
                // Make scheduler globally accessible for Max AI
                // Use SchedulerPro from the ES module (now available on window)
                // Add conflict resolution handler before creating scheduler
                // This will automatically resolve dependency conflicts
                const handleSchedulingConflict = (conflict) => {
                    console.log('üîß Auto-resolving scheduling conflict');
                    
                    // Always choose to ignore dependency conflicts
                    if (conflict && conflict.resolutions) {
                        // Look for resolution that removes or deactivates the dependency
                        for (const resolution of conflict.resolutions) {
                            if (resolution.description && 
                                (resolution.description.toLowerCase().includes('deactivate dependency') ||
                                 resolution.description.toLowerCase().includes('remove dependency'))) {
                                console.log('  ‚Üí Auto-selected: Ignoring dependency constraint');
                                resolution.resolve();
                                return;
                            }
                        }
                        
                        // If no dependency resolution, remove constraints
                        for (const resolution of conflict.resolutions) {
                            if (resolution.description && 
                                resolution.description.toLowerCase().includes('remove') &&
                                resolution.description.toLowerCase().includes('constraint')) {
                                console.log('  ‚Üí Auto-selected: Removing date constraint');
                                resolution.resolve();
                                return;
                            }
                        }
                        
                        // Last resort: cancel
                        for (const resolution of conflict.resolutions) {
                            if (resolution.description && 
                                resolution.description.toLowerCase().includes('cancel')) {
                                console.log('  ‚Üí Cancelling operation');
                                resolution.resolve();
                                return;
                            }
                        }
                    }
                };

                // Create a visual-only dependency store - OPTIONAL feature
                // Dependencies are visual-only and do not constrain scheduling
                let visualDependencyStore = null;
                
                try {
                    // Check if DependencyStore is available in bryntum namespace
                    let DependencyStore = null;
                    
                    // Check various possible locations for DependencyStore
                    if (window.bryntum?.schedulerpro?.DependencyStore) {
                        DependencyStore = window.bryntum.schedulerpro.DependencyStore;
                        console.log('‚úÖ Found DependencyStore at window.bryntum.schedulerpro.DependencyStore');
                    } else if (window.bryntum?.gantt?.DependencyStore) {
                        DependencyStore = window.bryntum.gantt.DependencyStore;
                        console.log('‚úÖ Found DependencyStore at window.bryntum.gantt.DependencyStore');
                    } else if (typeof SchedulerPro !== 'undefined' && SchedulerPro.DependencyStore) {
                        DependencyStore = SchedulerPro.DependencyStore;
                        console.log('‚úÖ Found DependencyStore at SchedulerPro.DependencyStore');
                    } else if (window.bryntum?.scheduler?.DependencyStore) {
                        DependencyStore = window.bryntum.scheduler.DependencyStore;
                        console.log('‚úÖ Found DependencyStore at window.bryntum.scheduler.DependencyStore');
                    } else {
                        // Try to create a simple store if DependencyStore not found
                        console.log('‚ö†Ô∏è DependencyStore class not found in standard locations');
                        console.log('  Attempting to use basic Store class for visual dependencies...');
                        
                        // Use basic Store which is available in all Bryntum packages
                        if (window.bryntum?.data?.Store || window.bryntum?.store?.Store) {
                            DependencyStore = window.bryntum.data?.Store || window.bryntum.store?.Store;
                            console.log('‚úÖ Using basic Store class for visual dependencies');
                        } else {
                            console.log('‚ö†Ô∏è No Store class found - visual dependencies will be disabled');
                            console.log('  Available on bryntum:', window.bryntum ? Object.keys(window.bryntum) : 'bryntum not found');
                        }
                    }
                    
                    // Create store only if we found a Store class
                    if (DependencyStore) {
                        visualDependencyStore = new DependencyStore({
                            // Define fields with active always defaulting to false
                            fields: [
                                { name: 'from', type: 'string' },
                                { name: 'to', type: 'string' },
                                { name: 'type', type: 'int', defaultValue: 2 },  // Changed to 'int' per Bryntum requirement
                                { name: 'lag', type: 'int', defaultValue: 0 },    // Changed to 'int' per Bryntum requirement
                                { name: 'lagUnit', type: 'string', defaultValue: 'day' },
                                { name: 'cls', type: 'string', defaultValue: 'b-inactive' },
                                // Force active to false - visual only
                                { name: 'active', type: 'boolean', defaultValue: false }
                            ],
                            data: [] // Start with empty, will load after scheduler is initialized
                        });
                    } else {
                        // Create a simple array-based store as fallback
                        console.log('‚ö†Ô∏è Creating simple array-based dependency store as fallback');
                        visualDependencyStore = {
                            data: [],
                            records: [],
                            count: 0,
                            add: function(items) {
                                const itemsArray = Array.isArray(items) ? items : [items];
                                this.data.push(...itemsArray);
                                this.records = this.data;
                                this.count = this.data.length;
                                return itemsArray;
                            },
                            removeAll: function() {
                                this.data = [];
                                this.records = [];
                                this.count = 0;
                            },
                            toJSON: function() {
                                return this.data;
                            },
                            getById: function(id) {
                                return this.data.find(d => d.id === id);
                            }
                        };
                    }
                
                    if (visualDependencyStore) {
                        // Override add/update methods to force dependencies to be inactive
                        const originalAdd = visualDependencyStore.add;
                        visualDependencyStore.add = function(records, silent) {
                            // Ensure all records are inactive
                            const processedRecords = Array.isArray(records) ? records : [records];
                            processedRecords.forEach(r => {
                                if (r) {
                                    r.active = false;
                                    r.cls = 'b-inactive';
                                }
                            });
                            return originalAdd.call(this, records, silent);
                        };
                        
                        // Make visual dependency store globally accessible
                        window.visualDependencyStore = visualDependencyStore;
                        console.log('‚úÖ Visual dependency store created successfully');
                    } else {
                        console.warn('‚ö†Ô∏è Visual dependency store not created - DependencyStore not available');
                        window.visualDependencyStore = null;
                    }
                } catch (error) {
                    console.error('‚ùå Error creating visual dependency store:', error);
                    console.warn('‚ö†Ô∏è Continuing without visual dependencies');
                    window.visualDependencyStore = null;
                }
                
                // CRITICAL FIX: Simply skip the ProjectModel completely and use basic scheduler
                // We'll load data directly into the scheduler after creation
                
                window.scheduler = new SchedulerPro({
                    appendTo: 'scheduler',
                    
                    columns: schedulerColumns,

                    viewPreset: viewPreset,
                    rowHeight: isMobile ? 50 : 60,
                    barMargin: isMobile ? 5 : 8,
                    
                    // CRITICAL: Event listeners to suppress ALL dependency conflicts
                    listeners: {
                        // Suppress ALL conflict resolution dialogs for dependencies
                        beforeSchedulingConflictResolution: ({ schedulingIssue }) => {
                            console.log('üîç Conflict detected:', schedulingIssue?.type, schedulingIssue);
                            
                            // Suppress ALL dependency-related conflicts
                            if (schedulingIssue && 
                                (schedulingIssue.type === 'dependencyconflict' || 
                                 schedulingIssue.type === 'dependency' ||
                                 schedulingIssue.description?.toLowerCase().includes('dependency'))) {
                                console.log('‚ö†Ô∏è Dependency conflict SUPPRESSED (visual-only deps)');
                                return false; // Prevent the dialog
                            }
                            
                            // Allow other conflict types (resource overlaps, constraint violations, etc.)
                            return true;
                        },
                        
                        // Hook into project load - dependencies handled separately
                        projectChange: ({ project }) => {
                            // Engine's dependency store is null (visual-only design)
                            // Visual dependencies are managed in window.visualDependencyStore
                            console.log('üîß Project loaded - using visual-only dependency system');
                        },
                        
                        // Allow inactive (visual-only) dependencies, block active (constraining) dependencies
                        beforeDependencyAdd: ({ dependency }) => {
                            // Always mark dependencies as inactive for visual display only
                            if (dependency && !dependency.inactive) {
                                dependency.inactive = true;
                                dependency.active = false;
                                console.log('üìã Dependency marked as inactive (visual-only):', dependency.id);
                            }
                            
                            // Allow the dependency to be added now that it's inactive
                            return true;
                        },
                        
                        beforeDependencyUpdate: ({ dependency }) => {
                            // Ensure dependency remains inactive during updates
                            if (dependency && !dependency.inactive) {
                                dependency.inactive = true;
                                dependency.active = false;
                                console.log('üìã Dependency update - enforced inactive flag:', dependency.id);
                            }
                            
                            // Allow the update now that inactive flag is set
                            return true;
                        },
                        
                        // Hook before any scheduling propagation
                        beforeProjectPropagate: ({ project }) => {
                            // Engine's dependency store is null - visual dependencies don't affect propagation
                            console.log('üìä Propagating schedule (visual dependencies don\'t constrain)');
                        }
                    },
                    
                    
                    // Enable horizontal scrolling on mobile
                    scrollable: isMobile ? { overflowX: 'auto', overflowY: 'auto' } : true,
                    
                    // Zoom level for better mobile view
                    zoomLevel: isMobile ? 0 : 5,
                    zoomOnMouseWheel: !isMobile,
                    
                    // Enable pinch zoom on mobile
                    pinchZoom: isMobile,
                    
                    // CRITICAL: Prevent overlapping events on same resource
                    allowOverlap: false,
                    
                    // Event layout - 'none' forces proper constraint handling, no visual stacking
                    eventLayout: 'none',  // 'none' enforces hard constraints, no overlaps allowed
                    
                    // Enable constraint violation indicators
                    enableEventAnimations: false,  // Disable animations for better performance with constraints
                    
                    // Disable state persistence to avoid localStorage errors
                    stateId: null,
                    
                    // Disable sync storage to prevent errors
                    syncDataOnLoad: false,

                    // Simplified project configuration without custom class
                    project: {
                        autoLoad: false,
                        autoSync: false,
                        silenceInitialCommit: true,
                        
                        // Store configurations with custom fields
                        eventStore: {
                            data: [],
                            autoLoad: false,
                            // Define custom fields to preserve from API
                            fields: [
                                'jobId',
                                'jobExternalId',
                                'jobName',
                                { name: 'jobPriority', type: 'number', defaultValue: 999 },
                                'jobDueDate',
                                'operationName',
                                'resourceName',
                                'isUnscheduled',
                                { name: 'sequence_number', type: 'number', defaultValue: 0 },
                                'ptData'
                            ]
                        },
                        resourceStore: {
                            data: [],
                            autoLoad: false
                        },
                        assignmentStore: {
                            data: [],
                            autoLoad: false
                        },
                        // Enable dependency store for visual-only dependencies
                        dependencyStore: {
                            data: [],
                            autoLoad: false
                        },
                        
                        // Disable ALL automatic scheduling
                        autoCalculateStartDate: false,
                        autoCalculateEndDate: false,
                        autoCalculate: false,
                        recalculateAfterLoad: false,
                        autoSchedule: false,
                        delayCalculation: true,
                        
                        // Constraint configuration
                        constraintsMode: 'none',
                        manuallyScheduled: false
                    },

                    features: {
                        // Dependencies feature ENABLED - using PT dependencies for visualization
                        // Dependencies are loaded directly into scheduler's dependency store as inactive
                        dependencies: {
                            disabled: false
                            // No need to specify store - will use project.dependencyStore automatically
                        },
                        
                        // Enable drag and drop with tooltip and sequence constraints
                        eventDrag: {
                            showTooltip: true,
                            constrainDragToResource: false, // Allow dragging between resources
                            // Validate that drag preserves operation sequence AND resource capabilities
                            validatorFn({ draggedRecords, targetRecord, startDate, endDate }) {
                                // Check each dragged operation
                                for (const draggedRecord of draggedRecords) {
                                    const operationName = draggedRecord.name || draggedRecord.operationName || '';
                                    const requiredCapability = getRequiredCapability(operationName);
                                    
                                    // === SEQUENCE CONSTRAINT CHECK ===
                                    // Operations must maintain their sequence order (1-9)
                                    const draggedJobId = draggedRecord.jobId || draggedRecord.job_id || getJobKey(draggedRecord);
                                    const draggedSequence = getSequence(draggedRecord);
                                    
                                    if (draggedJobId && draggedSequence) {
                                        const events = [...scheduler.eventStore.records];
                                        
                                        // Find all operations for the same job
                                        const jobOperations = events.filter(e => {
                                            const jobId = e.jobId || e.job_id || getJobKey(e);
                                            return jobId === draggedJobId && e.id !== draggedRecord.id;
                                        });
                                        
                                        // Check if this move would violate sequence constraints
                                        for (const op of jobOperations) {
                                            const opSequence = getSequence(op);
                                            
                                            // Previous operations must end before this one starts
                                            if (opSequence < draggedSequence && op.endDate) {
                                                if (new Date(startDate) < new Date(op.endDate)) {
                                                    console.warn(`‚ùå Cannot move operation ${draggedSequence} before operation ${opSequence} ends`);
                                                    return {
                                                        valid: false,
                                                        message: `Operation ${draggedSequence} must start after operation ${opSequence} completes`
                                                    };
                                                }
                                            }
                                            
                                            // This operation must end before later operations start
                                            if (opSequence > draggedSequence && op.startDate) {
                                                if (new Date(endDate) > new Date(op.startDate)) {
                                                    console.warn(`‚ùå Cannot move operation ${draggedSequence} to overlap with operation ${opSequence}`);
                                                    return {
                                                        valid: false,
                                                        message: `Operation ${draggedSequence} must complete before operation ${opSequence} starts`
                                                    };
                                                }
                                            }
                                        }
                                    }
                                    // === END SEQUENCE CONSTRAINT CHECK ===
                                    
                                    // 1. Check capability requirements - USE SIMPLE NAME MATCHING SINCE API IS BROKEN
                                    if (targetRecord) {
                                        const operationNameLower = operationName.toLowerCase();
                                        const targetResourceNameLower = targetRecord.name.toLowerCase();
                                        
                                        console.log(`üîç Validating drag: Operation "${operationName}" to resource "${targetRecord.name}"`);
                                        
                                        // Simple capability matching based on resource and operation names
                                        const isValidMatch = 
                                            // Milling operations can only go on Grain Mill
                                            (operationNameLower.includes('mill') && targetResourceNameLower.includes('grain mill')) ||
                                            // Mashing operations can only go on Mash Tun
                                            (operationNameLower.includes('mash') && !operationNameLower.includes('unmash') && 
                                             targetResourceNameLower.includes('mash tun')) ||
                                            // Lautering operations can only go on Lauter Tun
                                            (operationNameLower.includes('lauter') && targetResourceNameLower.includes('lauter tun')) ||
                                            // Boiling operations can only go on Brew Kettle
                                            (operationNameLower.includes('boil') && targetResourceNameLower.includes('brew kettle')) ||
                                            // Fermentation operations can only go on Fermenter Tanks
                                            (operationNameLower.includes('ferment') && targetResourceNameLower.includes('fermenter tank')) ||
                                            // Conditioning operations can only go on Bright Tanks
                                            (operationNameLower.includes('condition') && targetResourceNameLower.includes('bright tank')) ||
                                            // Packaging operations can only go on Bottling/Canning Lines
                                            (operationNameLower.includes('packag') && (targetResourceNameLower.includes('bottling') || 
                                                                                        targetResourceNameLower.includes('canning'))) ||
                                            // Decoction Mash is a special mashing operation
                                            (operationNameLower.includes('decoction') && targetResourceNameLower.includes('mash tun'));
                                        
                                        if (!isValidMatch) {
                                            console.warn(`‚ùå Invalid resource match: ${operationName} cannot be performed on ${targetRecord.name}`);
                                            
                                            // Provide helpful error messages
                                            let expectedResource = 'appropriate resource';
                                            if (operationNameLower.includes('mill')) expectedResource = 'Grain Mill';
                                            else if (operationNameLower.includes('mash')) expectedResource = 'Mash Tun';
                                            else if (operationNameLower.includes('lauter')) expectedResource = 'Lauter Tun';
                                            else if (operationNameLower.includes('boil')) expectedResource = 'Brew Kettle';
                                            else if (operationNameLower.includes('ferment')) expectedResource = 'Fermenter Tank';
                                            else if (operationNameLower.includes('condition')) expectedResource = 'Bright Tank';
                                            else if (operationNameLower.includes('packag')) expectedResource = 'Bottling/Canning Line';
                                            
                                            return {
                                                valid: false,
                                                message: `${operationName} must be performed on ${expectedResource}, not ${targetRecord.name}`
                                            };
                                        }
                                    }
                                    
                                    // 2. CRITICAL: Use resource's isDateRangeAvailable to check overlaps (Best Practice)
                                    if (targetRecord && startDate && endDate) {
                                        // DEBUG: Log all events on target resource
                                        console.log(`üîç Checking overlap for ${operationName} on ${targetRecord.name}`);
                                        console.log(`  Proposed time: ${startDate.toLocaleString()} to ${endDate.toLocaleString()}`);
                                        console.log(`  Events on ${targetRecord.name}:`, targetRecord.events?.map(e => ({
                                            id: e.id,
                                            name: e.name,
                                            start: e.startDate?.toLocaleString(),
                                            end: e.endDate?.toLocaleString()
                                        })));
                                        
                                        // Find actual conflicting events manually (more reliable than isDateRangeAvailable)
                                        const resourceEvents = targetRecord.events?.filter(event => {
                                            // Skip the dragged event itself and any phantom events
                                            if (event.id === draggedRecord.id || 
                                                event.id === draggedRecord.eventId || 
                                                !event.startDate || 
                                                !event.endDate) {
                                                return false;
                                            }
                                            
                                            // Check for actual time overlap
                                            const overlap = event.startDate < endDate && event.endDate > startDate;
                                            if (overlap) {
                                                console.log(`  ‚ö†Ô∏è Found overlapping event: ${event.name} (${event.id})`);
                                            }
                                            return overlap;
                                        }) || [];
                                        
                                        // Only show error if there's a REAL conflicting event
                                        if (resourceEvents.length > 0) {
                                            const conflictingEvent = resourceEvents[0];
                                            console.warn(`‚ö†Ô∏è Cannot drop ${operationName}: Time slot occupied on ${targetRecord.name} by ${conflictingEvent.name}`);
                                            
                                            const conflictStart = conflictingEvent.startDate.toLocaleString('en-US', { 
                                                month: 'short', 
                                                day: 'numeric', 
                                                hour: 'numeric', 
                                                minute: '2-digit' 
                                            });
                                            const conflictEnd = conflictingEvent.endDate.toLocaleString('en-US', { 
                                                month: 'short', 
                                                day: 'numeric', 
                                                hour: 'numeric', 
                                                minute: '2-digit' 
                                            });
                                            return {
                                                valid: false,
                                                message: `Resource busy: ${conflictingEvent.name} runs from ${conflictStart} to ${conflictEnd}`
                                            };
                                        }
                                        
                                        // No real conflicts found - allow the drop
                                        console.log(`  ‚úÖ No conflicts found, allowing drop`);
                                    }
                                }
                                return true; // Valid drop
                            }
                        },
                        
                        // Enable resize with overlap validation
                        eventResize: {
                            showTooltip: true,
                            // CRITICAL: Use resource's isDateRangeAvailable to prevent overlaps (Best Practice)
                            validatorFn({ eventRecord, startDate, endDate }) {
                                const resource = eventRecord.resource;
                                if (!resource || !startDate || !endDate) return true;
                                
                                // Use resource-level overlap detection per Bryntum best practices
                                const isAvailable = resource.isDateRangeAvailable(
                                    startDate,
                                    endDate,
                                    eventRecord  // Exclude the resized event itself
                                );
                                
                                if (!isAvailable) {
                                    console.warn(`‚ö†Ô∏è Cannot resize ${eventRecord.name}: Time slot occupied`);
                                    
                                    // Find the conflicting event for better error message
                                    const resourceEvents = resource.events.filter(event => 
                                        event.id !== eventRecord.id &&
                                        event.startDate < endDate && 
                                        event.endDate > startDate
                                    );
                                    
                                    const conflictingEvent = resourceEvents[0];
                                    if (conflictingEvent) {
                                        const conflictStart = conflictingEvent.startDate.toLocaleString('en-US', { 
                                            month: 'short', 
                                            day: 'numeric', 
                                            hour: 'numeric', 
                                            minute: '2-digit' 
                                        });
                                        const conflictEnd = conflictingEvent.endDate.toLocaleString('en-US', { 
                                            month: 'short', 
                                            day: 'numeric', 
                                            hour: 'numeric', 
                                            minute: '2-digit' 
                                        });
                                        return {
                                            valid: false,
                                            message: `Cannot resize: ${conflictingEvent.name} runs from ${conflictStart} to ${conflictEnd}`
                                        };
                                    }
                                    return {
                                        valid: false,
                                        message: `Time slot is already occupied on this resource`
                                    };
                                }
                                return { valid: true }; // Valid resize
                            }
                        },
                        
                        // Event tooltips on hover
                        eventTooltip: {
                            template: ({ eventRecord }) => {
                                // Extract job name/batch from the event data
                                const jobInfo = eventRecord.jobName || eventRecord.data?.jobName || '';
                                const jobDisplay = jobInfo ? `<strong style="color: #0066cc;">Job: ${jobInfo}</strong><br>` : '';
                                
                                // Check if operation is actually scheduled (has resource and valid dates)
                                const hasResource = eventRecord.assignments && eventRecord.assignments.length > 0;
                                const hasValidDates = eventRecord.startDate && eventRecord.endDate;
                                const isCurrentlyUnscheduled = !hasResource || !hasValidDates;
                                
                                return `
                                    <div style="padding: 10px; min-width: 200px;">
                                        ${jobDisplay}
                                        <strong>${eventRecord.name}</strong><br>
                                        <div style="margin-top: 5px; font-size: 0.9em;">
                                            Start: ${eventRecord.startDate.toLocaleString()}<br>
                                            End: ${eventRecord.endDate.toLocaleString()}<br>
                                            Duration: ${eventRecord.duration} ${eventRecord.durationUnit}<br>
                                            Progress: ${eventRecord.percentDone}%
                                        </div>
                                        ${isCurrentlyUnscheduled ? '<br><span style="color: orange; font-weight: bold;">‚ö†Ô∏è Unscheduled - Drag to a resource to schedule</span>' : ''}
                                    </div>
                                `;
                            }
                        },
                        
                        // Show current time line
                        timeRanges: {
                            showCurrentTimeLine: true
                        },
                        
                        // Progress line feature - shows percentage complete
                        percentBar: true,
                        
                        // Non-working time visualization
                        nonWorkingTime: true,
                        
                        // Critical paths feature
                        criticalPaths: false,
                        
                        // Event menu on right-click
                        eventMenu: true,
                        
                        // Schedule menu on right-click
                        scheduleMenu: true
                    },

                    eventRenderer({ eventRecord, renderData }) {
                        renderData.eventColor = eventRecord.eventColor;
                        return {
                            html: `
                                <div style="padding: 4px;">
                                    <div style="font-weight: 500; font-size: 12px;">${eventRecord.name}</div>
                                    <div style="font-size: 11px; opacity: 0.8;">
                                        ${eventRecord.percentDone}% complete
                                    </div>
                                </div>
                            `
                        };
                    },

                    startDate: (() => {
                        // Start from today (September 3, 2025)
                        const start = new Date(2025, 8, 3); // Month is 0-indexed, so 8 = September
                        start.setHours(0, 0, 0, 0);
                        return start;
                    })(),
                    endDate: (() => {
                        // Show 4 weeks from today to ensure all operations are visible
                        const end = new Date(2025, 9, 3); // October 3, 2025
                        end.setHours(23, 59, 59, 999);
                        return end;
                    })(),
                    // Enable infinite scrolling for better navigation
                    infiniteScroll: true,
                    zoomLevel: 10
                });

                // Setup toolbar handlers
                const scheduler = window.scheduler;
                
                // Add event listeners to handle dragging from unscheduled resource
                scheduler.on('eventdrop', ({ eventRecords, targetResourceRecord, context }) => {
                    eventRecords.forEach(eventRecord => {
                        // Check if the event was dragged from unscheduled to a real resource
                        if (eventRecord.isUnscheduled && targetResourceRecord.id !== 'unscheduled') {
                            // Mark as scheduled now
                            eventRecord.isUnscheduled = false;
                            // Update color to match the operation type
                            eventRecord.eventColor = getOperationColor(eventRecord.name);
                            // Apply ASAP constraint now that it's scheduled
                            eventRecord.constraintType = 'startnoearlierthan';
                            eventRecord.constraintDate = eventRecord.startDate;
                            console.log(`‚úÖ Operation "${eventRecord.name}" scheduled to resource: ${targetResourceRecord.name}`);
                            window.updateStatus(); // Update metrics
                        } else if (!eventRecord.isUnscheduled && targetResourceRecord.id === 'unscheduled') {
                            // Mark as unscheduled if dragged back to unscheduled
                            eventRecord.isUnscheduled = true;
                            eventRecord.eventColor = '#808080';
                            eventRecord.constraintType = null;
                            eventRecord.constraintDate = null;
                            console.log(`‚ö†Ô∏è Operation "${eventRecord.name}" moved to unscheduled`);
                            window.updateStatus(); // Update metrics
                        }
                    });
                });
                
                // Add event listeners to automatically handle scheduling conflicts
                scheduler.project.on({
                    schedulingconflict: (event) => {
                        console.log('üìã Scheduling conflict detected:', event.conflict);
                        
                        // Automatically resolve the conflict
                        const conflict = event.conflict;
                        if (conflict && conflict.resolutions && conflict.resolutions.length > 0) {
                            // Find resolution to deactivate or remove dependency
                            for (const resolution of conflict.resolutions) {
                                const desc = (resolution.description || '').toLowerCase();
                                if (desc.includes('deactivate dependency') || 
                                    desc.includes('remove dependency')) {
                                    console.log('  ‚Üí Auto-resolving: Ignoring dependency');
                                    resolution.resolve();
                                    return false; // Prevent default dialog
                                }
                            }
                            
                            // Otherwise remove constraints
                            for (const resolution of conflict.resolutions) {
                                const desc = (resolution.description || '').toLowerCase();
                                if (desc.includes('remove') && desc.includes('constraint')) {
                                    console.log('  ‚Üí Auto-resolving: Removing constraint');
                                    resolution.resolve();
                                    return false; // Prevent default dialog
                                }
                            }
                            
                            // Default: cancel
                            const cancelResolution = conflict.resolutions.find(r => 
                                (r.description || '').toLowerCase().includes('cancel'));
                            if (cancelResolution) {
                                console.log('  ‚Üí Auto-resolving: Cancelling');
                                cancelResolution.resolve();
                                return false; // Prevent default dialog
                            }
                        }
                    },
                    
                    beforeschedulingconflictdialog: (event) => {
                        // Prevent the dialog from showing
                        console.log('  ‚Üí Suppressing conflict dialog');
                        return false;
                    }
                });
                
                // Handle dependency validation if visual store exists
                // Note: Engine's dependency store is intentionally null (visual-only design)
                if (window.visualDependencyStore) {
                    // Visual dependencies don't need validation since they don't constrain
                    console.log('  ‚Üí Using visual-only dependency store (no constraints)');
                }
                
                // Enhanced status update function using real PT data
                // Make it globally accessible for loadSchedule and other functions
                window.updateStatus = function() {
                    const operationCount = scheduler.eventStore.count || 0;
                    document.getElementById('operationCount').textContent = `${operationCount} operations scheduled`;
                    
                    // Calculate detailed resource utilization using PT operations data
                    const events = scheduler.eventStore.records || [];
                    const resources = scheduler.resourceStore.records || [];
                    
                    let totalOperationHours = 0;
                    const resourceUtilization = {};
                    
                    // Find the actual schedule timespan
                    let earliestStart = null;
                    let latestEnd = null;
                    
                    // Calculate utilization per resource and find schedule bounds
                    resources.forEach(resource => {
                        // Skip the unscheduled resource line from calculations
                        if (resource.id === 'unscheduled') return;
                        
                        const resourceEvents = events.filter(e => e.resourceId === resource.id);
                        let resourceHours = 0;
                        
                        resourceEvents.forEach(event => {
                            resourceHours += event.duration || 0;
                            
                            // Track schedule bounds
                            if (event.startDate) {
                                const startTime = new Date(event.startDate).getTime();
                                const endTime = new Date(event.endDate || event.startDate).getTime();
                                
                                if (!earliestStart || startTime < earliestStart) {
                                    earliestStart = startTime;
                                }
                                if (!latestEnd || endTime > latestEnd) {
                                    latestEnd = endTime;
                                }
                            }
                        });
                        
                        resourceUtilization[resource.id] = {
                            name: resource.name,
                            hours: resourceHours,
                            operationCount: resourceEvents.length
                        };
                        totalOperationHours += resourceHours;
                    });
                    
                    // Calculate actual working days and hours in the schedule
                    let scheduleSpanHours = 0;
                    if (earliestStart && latestEnd) {
                        const spanMs = latestEnd - earliestStart;
                        const spanDays = Math.ceil(spanMs / (1000 * 60 * 60 * 24));
                        // Assume 8 working hours per day
                        scheduleSpanHours = spanDays * 8;
                    } else {
                        // Fallback to single day if no schedule
                        scheduleSpanHours = 8;
                    }
                    
                    // Calculate utilization based on actual schedule span
                    // Exclude unscheduled resource from count
                    const activeResources = resources.filter(r => r.id !== 'unscheduled').length;
                    const totalResourceCapacity = activeResources * scheduleSpanHours;
                    const utilization = totalResourceCapacity > 0 ? Math.round((totalOperationHours / totalResourceCapacity) * 100) : 0;
                    
                    document.getElementById('resourceUtilization').textContent = `Resource utilization: ${utilization}% (${totalOperationHours.toFixed(1)}h total)`;
                    document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                    
                    // Store utilization data for Max AI analysis
                    window.currentUtilization = resourceUtilization;
                    window.currentStats = {
                        operations: operationCount,
                        utilization: utilization,
                        totalHours: totalOperationHours,
                        resources: resources.length
                    };
                }

                // Removed standalone navigation - now integrated with main app
                // const maxAIBtn = document.getElementById('maxAIBtn');
                // const maxAI = document.getElementById('maxAI');
                // const closeMaxAI = document.getElementById('closeMaxAI');
                // const maxInput = document.getElementById('maxInput');
                // const maxSend = document.getElementById('maxSend');
                // const maxMessages = document.getElementById('maxMessages');
                
                // maxAIBtn.addEventListener('click', () => {
                //     maxAI.classList.toggle('closed');
                //     const btnText = maxAI.classList.contains('closed') ? 'ü§ñ Max AI' : 'ü§ñ Hide AI';
                //     maxAIBtn.textContent = btnText;
                // });
                
                // closeMaxAI.addEventListener('click', () => {
                //     maxAI.classList.add('closed');
                //     maxAIBtn.textContent = 'ü§ñ Max AI';
                // });
                
                // Function to reload schedule data from database
                async function refreshScheduleData() {
                    console.log('üîÑ Refreshing schedule data from database...');
                    
                    try {
                        // Get auth headers
                        const authHeaders = getAuthHeaders();
                        const timestamp = new Date().getTime();
                        
                        // Fetch updated data
                        const [operationsResponse, depsResponse, resourcesResponse, jobsResponse] = await Promise.all([
                            fetch('/api/pt-operations?_=' + timestamp, { headers: authHeaders }), 
                            fetch('/api/pt-dependencies?_=' + timestamp, { headers: authHeaders }),
                            fetch('/api/resources-with-capabilities?_=' + timestamp, { headers: authHeaders }),
                            fetch('/api/jobs?_=' + timestamp, { headers: authHeaders })
                        ]);
                        
                        if (operationsResponse.ok && jobsResponse.ok) {
                            const operations = await operationsResponse.json();
                            const jobs = await jobsResponse.json();
                            
                            // Clear current event store
                            scheduler.eventStore.removeAll();
                            
                            // Process and load new operations
                            const events = operations.map(op => {
                                const job = jobs.find(j => j.id === op.job_id);
                                const resourceMapping = resourceMappings[op.resource_id] || 
                                    (op.resource_id && op.resource_id !== '0' ? op.resource_id : 'unscheduled');
                                
                                return {
                                    id: op.id,
                                    name: op.name || `Operation ${op.sequence_number}`,
                                    startDate: op.scheduled_start ? new Date(op.scheduled_start) : new Date(),
                                    endDate: op.scheduled_end ? new Date(op.scheduled_end) : 
                                        new Date(new Date().getTime() + (parseFloat(op.cycle_hrs || 1) * 3600000)),
                                    resourceId: resourceMapping,
                                    jobId: op.job_id,
                                    jobName: job?.name || 'Unknown Job',
                                    priority: job?.priority || 999,
                                    jobPriority: job?.priority || 999,
                                    eventColor: priorityColors[job?.priority] || priorityColors['default'],
                                    durationUnit: 'hour',
                                    duration: parseFloat(op.cycle_hrs || 1),
                                    percentDone: 0,
                                    resizable: true,
                                    draggable: true,
                                    manuallyScheduled: false
                                };
                            });
                            
                            // Load new events into scheduler
                            scheduler.eventStore.add(events);
                            
                            // Force scheduler to refresh its view
                            scheduler.refresh();
                            
                            // Update status display
                            window.updateStatus();
                            
                            // Update gantt chart if it exists
                            if (window.gantt) {
                                await loadGanttData();
                            }
                            
                            console.log('‚úÖ Schedule refreshed with', events.length, 'operations');
                            showNotification('Schedule data refreshed', 'success');
                            
                            // Update version history
                            loadVersionHistory();
                            
                            // Also refresh saved schedules dropdown if it exists
                            if (typeof loadSavedSchedulesDropdown === 'function') {
                                loadSavedSchedulesDropdown();
                            }
                        } else {
                            console.error('Failed to refresh schedule data');
                            showNotification('Failed to refresh schedule', 'error');
                        }
                    } catch (error) {
                        console.error('Error refreshing schedule:', error);
                        showNotification('Error refreshing schedule', 'error');
                    }
                }
                
                // Listen for messages from parent window (main app's Max AI panel)
                window.addEventListener('message', (event) => {
                    console.log('[Scheduler] Received message:', event.data);
                    
                    // Handle algorithm run requests from parent
                    if (event.data && event.data.type === 'RUN_ALGORITHM') {
                        console.log('[Scheduler] Running algorithm:', event.data.algorithm);
                        runSchedulerAlgorithm(event.data.algorithm);
                    }
                    // Handle refresh requests after agent updates database
                    else if (event.data && (event.data.type === 'REFRESH_SCHEDULE' || 
                                           event.data.type === 'REFRESH_VIEW')) {
                        console.log('[Scheduler] Refreshing schedule data...');
                        refreshScheduleData();
                    }
                });
                
                // Improved debug function per Bryntum best practices
                function assertNoOverlaps(scheduler) {
                    const overlaps = [];
                    const TOLERANCE_MS = 1000; // 1 second tolerance for perfect handoffs
                    
                    for (const r of scheduler.resourceStore.records) {
                        const evs = r.events.slice().sort((a, b) => a.startDate - b.startDate);
                        for (let i = 1; i < evs.length; i++) {
                            const overlapMs = evs[i - 1].endDate - evs[i].startDate;
                            // Only flag as overlap if operations overlap by more than the tolerance
                            // This handles perfect handoffs where one ends exactly when another starts
                            if (overlapMs > TOLERANCE_MS) {
                                overlaps.push({ 
                                    resource: r.name, 
                                    a: evs[i - 1].name, 
                                    b: evs[i].name,
                                    overlapMs: overlapMs
                                });
                                console.log(`  ‚ö†Ô∏è Real overlap detected on ${r.name}: "${evs[i - 1].name}" ends at ${evs[i - 1].endDate.toLocaleString()} but "${evs[i].name}" starts at ${evs[i].startDate.toLocaleString()} (${overlapMs}ms overlap)`);
                            } else if (overlapMs > 0 && overlapMs <= TOLERANCE_MS) {
                                console.log(`  ‚úÖ Perfect handoff on ${r.name}: "${evs[i - 1].name}" to "${evs[i].name}" (${overlapMs}ms within tolerance)`);
                            }
                        }
                    }
                    if (overlaps.length) {
                        console.warn('‚ùå Real overlaps found:', overlaps);
                        return false;
                    } else {
                        console.log('‚úÖ No overlaps per resource (perfect handoffs allowed)');
                        return true;
                    }
                }
                
                // Repair function to enforce no overlaps across all resources
                async function enforceNoOverlapAcrossAllResources() {
                    console.log('  üîß Starting overlap repair...');
                    let totalMoved = 0;
                    let iterations = 0;
                    const maxIterations = 10; // Prevent infinite loops
                    
                    // Keep repairing until no overlaps remain or max iterations reached
                    while (iterations < maxIterations) {
                        iterations++;
                        let movedInThisPass = 0;
                        
                        const resList = scheduler.resourceStore.records.filter(r => r.id !== 'unscheduled');
                        
                        // Process each resource
                        for (const resource of resList) {
                            const events = resource.events.slice().sort((a, b) => a.startDate - b.startDate);
                            
                            // Check each event for overlaps with subsequent events
                            for (let i = 0; i < events.length; i++) {
                                const currentEvent = events[i];
                                
                                // Check if this event overlaps with any later events on the same resource
                                let needsMove = false;
                                for (let j = i + 1; j < events.length; j++) {
                                    const nextEvent = events[j];
                                    if (currentEvent.endDate > nextEvent.startDate) {
                                        needsMove = true;
                                        break;
                                    }
                                }
                                
                                // Also check if any earlier event overlaps with this one
                                for (let j = 0; j < i; j++) {
                                    const prevEvent = events[j];
                                    if (prevEvent.endDate > currentEvent.startDate) {
                                        needsMove = true;
                                        break;
                                    }
                                }
                                
                                if (needsMove) {
                                    const dur = currentEvent.durationMS ?? currentEvent.duration * 3600000;
                                    
                                    // Find the earliest free slot that doesn't create new overlaps
                                    const { start, end } = findNextFreeSlotOnResource(resource, currentEvent.startDate, dur, currentEvent);
                                    
                                    // Double-check the slot is truly free by verifying against all events
                                    let slotIsFree = true;
                                    for (const otherEvent of events) {
                                        if (otherEvent === currentEvent) continue;
                                        
                                        // Check if the proposed slot would overlap with this event
                                        if ((start < otherEvent.endDate && end > otherEvent.startDate) ||
                                            (start >= otherEvent.startDate && start < otherEvent.endDate) ||
                                            (end > otherEvent.startDate && end <= otherEvent.endDate)) {
                                            slotIsFree = false;
                                            break;
                                        }
                                    }
                                    
                                    if (slotIsFree && start.getTime() !== currentEvent.startDate.getTime()) {
                                        console.log(`    üìÖ Moving "${currentEvent.name}" on ${resource.name} from ${currentEvent.startDate.toLocaleString()} to ${start.toLocaleString()}`);
                                        currentEvent.set({ startDate: start, endDate: end, manuallyScheduled: false });
                                        movedInThisPass++;
                                        totalMoved++;
                                    } else if (!slotIsFree) {
                                        // If the slot finder didn't find a truly free slot, manually find one
                                        console.log(`    ‚ö†Ô∏è Slot finder failed for "${currentEvent.name}" on ${resource.name}, searching manually...`);
                                        
                                        // Find the latest end time of all events on this resource
                                        let latestEnd = new Date();
                                        for (const evt of events) {
                                            if (evt !== currentEvent && evt.endDate > latestEnd) {
                                                latestEnd = new Date(evt.endDate);
                                            }
                                        }
                                        
                                        // Schedule after the latest event
                                        const newStart = new Date(latestEnd);
                                        const newEnd = new Date(newStart.getTime() + dur);
                                        
                                        console.log(`    üìÖ Moving "${currentEvent.name}" to end of schedule: ${newStart.toLocaleString()}`);
                                        currentEvent.set({ startDate: newStart, endDate: newEnd, manuallyScheduled: false });
                                        movedInThisPass++;
                                        totalMoved++;
                                    }
                                }
                            }
                        }
                        
                        // DON'T commit changes inside the loop to prevent triggering events
                        if (movedInThisPass > 0) {
                            // Just log the progress, don't commit yet
                            console.log(`  üîÑ Pass ${iterations}: Moved ${movedInThisPass} operations`);
                        } else {
                            // No more overlaps found, we're done
                            console.log(`  ‚úÖ All overlaps resolved after ${iterations} pass${iterations > 1 ? 'es' : ''}`);
                            break;
                        }
                    }
                    
                    if (iterations >= maxIterations) {
                        console.error(`  ‚ö†Ô∏è Reached maximum iterations (${maxIterations}) - some overlaps may remain`);
                    }
                    
                    // Commit all changes ONCE at the end to avoid triggering events during the loop
                    if (totalMoved > 0) {
                        await scheduler.project.commitAsync();
                        await scheduler.project.propagate();
                    }
                    
                    console.log(`  üìä Total operations moved: ${totalMoved}`);
                }
                
                // Helper function to check for constraint violations (resource overlaps) - legacy support
                async function checkConstraintViolations() {
                    const violations = [];
                    const resources = scheduler.resourceStore.records;
                    
                    for (const resource of resources) {
                        const events = resource.events.slice().sort((a, b) => a.startDate - b.startDate);
                        
                        // Check for overlaps
                        for (let i = 0; i < events.length - 1; i++) {
                            const current = events[i];
                            const next = events[i + 1];
                            
                            if (current.endDate > next.startDate) {
                                violations.push({
                                    resource: resource.name,
                                    event1: current.name,
                                    event2: next.name,
                                    overlap: current.endDate - next.startDate
                                });
                            }
                        }
                    }
                    
                    return violations;
                }
                
                // Canonical slot finder - uses assignments for single source of truth
                function findNextFreeSlotOnResource(resource, earliestStart, durationMs, excludeEvent) {
                    let start = new Date(earliestStart);
                    
                    // Respect working time if a calendar exists
                    const cal = resource.calendar || resource.project?.calendar;
                    if (cal?.isNonWorkingTime?.(start)) start = cal.skipNonWorkingTime(start, true);
                    
                    // Collect all events assigned to this resource (assignmentStore is the single source of truth)
                    const { assignmentStore, eventStore } = scheduler;
                    const events = [];
                    assignmentStore.forEach(a => {
                        if (a.resourceId === resource.id) {
                            const e = eventStore.getById(a.eventId);
                            if (e && e !== excludeEvent && e.id !== excludeEvent?.id && e.startDate && e.endDate) {
                                events.push(e);
                            }
                        }
                    });
                    events.sort((a, b) => a.startDate - b.startDate);
                    
                    // Keep trying to find a truly free slot
                    let attempts = 0;
                    const maxAttempts = events.length + 2; // Prevent infinite loops
                    
                    while (attempts < maxAttempts) {
                        attempts++;
                        let needsMove = false;
                        const end = new Date(start.getTime() + durationMs);
                        
                        // Check against all events for any kind of overlap
                        for (const e of events) {
                            // Check if the proposed slot overlaps with this event
                            if (start < e.endDate && end > e.startDate) {
                                // Found an overlap, move to after this event
                                start = new Date(e.endDate.getTime());
                                needsMove = true;
                                break;
                            }
                        }
                        
                        if (!needsMove) {
                            // No overlaps found, we have a valid slot
                            break;
                        }
                    }
                    
                    // If we still can't find a slot, place at the very end
                    if (attempts >= maxAttempts) {
                        let latestEnd = new Date(earliestStart);
                        for (const e of events) {
                            if (e.endDate > latestEnd) {
                                latestEnd = new Date(e.endDate.getTime());
                            }
                        }
                        start = latestEnd;
                    }
                    
                    if (cal?.isNonWorkingTime?.(start)) start = cal.skipNonWorkingTime(start, true);
                    const end = new Date(start.getTime() + durationMs);
                    return { start, end };
                }
                
                // Helper function to resolve overlaps by shifting operations
                async function resolveOverlaps() {
                    console.log('üîß Attempting to resolve resource overlaps using best practice packer...');
                    const resources = scheduler.resourceStore.records;
                    
                    for (const resource of resources) {
                        const events = resource.events.slice().sort((a, b) => a.startDate - b.startDate);
                        
                        // Fix overlaps using the packer approach
                        for (let i = 0; i < events.length; i++) {
                            const event = events[i];
                            const durationMs = event.duration * 60 * 60 * 1000;
                            
                            // Find the next free slot for this event
                            const slot = findNextFreeSlotOnResource(resource, event.startDate, durationMs, event);
                            
                            if (slot.start.getTime() !== event.startDate.getTime()) {
                                const shift = slot.start - event.startDate;
                                event.startDate = slot.start;
                                event.endDate = slot.end;
                                console.log(`üìÖ Shifted ${event.name} by ${shift / (1000 * 60)} minutes to avoid overlap on ${resource.name}`);
                            }
                        }
                    }
                    
                    await scheduler.project.commitAsync();
                    console.log('‚úÖ Overlap resolution complete');
                    
                    // Verify with the assertion function
                    assertNoOverlaps(scheduler);
                }
                
                // Function to run scheduler algorithms from quick actions
                async function runSchedulerAlgorithm(algorithm) {
                    const algorithmDropdown = document.getElementById('schedulingAlgorithm');
                    
                    // Map algorithm names to dropdown values
                    const algorithmMap = {
                        'ASAP': 'asap',
                        'ALAP': 'alap',
                        'CRITICAL_PATH': 'criticalPath',
                        'LEVEL_RESOURCES': 'levelResources',
                        'DRUM_TOC': 'drum'
                    };
                    
                    // Use the shared applySelectedAlgorithm function directly
                    if (algorithmMap[algorithm]) {
                        algorithmDropdown.value = algorithmMap[algorithm];
                        
                        // Call the shared function directly instead of clicking the button
                        console.log(`ü§ñ Agent triggering ${algorithm} algorithm...`);
                        const success = await window.applySelectedAlgorithm(algorithmMap[algorithm]);
                        
                        if (success) {
                            console.log(`‚úÖ ${algorithm} algorithm applied successfully by agent!`);
                        } else {
                            console.error(`‚ùå Failed to apply ${algorithm} algorithm`);
                        }
                    }
                }
                
                // Make functions available globally for onclick handlers
                window.runSchedulerAlgorithm = runSchedulerAlgorithm;
                
                // Max AI chat functionality removed - handled by main app's AI panel
                function sendMaxMessage() {
                    // This function is now handled by the main app's Max AI panel
                    console.log('Max AI chat is handled by the main app panel');
                    return;
                    
                    // Removed code that references deleted elements
                    // const message = maxInput.value.trim();
                    // if (!message) return;
                    // const userMsg = document.createElement('div');
                    // userMsg.className = 'max-ai-message user';
                    // userMsg.textContent = message;
                    // maxMessages.appendChild(userMsg);
                    
                    // Clear input
                    maxInput.value = '';
                    
                    // Process AI response and execute algorithms
                    setTimeout(async () => {
                        const aiMsg = document.createElement('div');
                        aiMsg.className = 'max-ai-message assistant';
                        
                        // Parse message for algorithm commands
                        const lowerMessage = message.toLowerCase();
                        let response = '';
                        let executedAlgorithm = null;
                        
                        // Check for algorithm execution commands
                        if (lowerMessage.includes('run') || lowerMessage.includes('execute') || lowerMessage.includes('apply') || lowerMessage.includes('optimize')) {
                            if (lowerMessage.includes('asap') || lowerMessage.includes('forward')) {
                                executedAlgorithm = 'asap';
                                response = 'üöÄ Executing ASAP (Forward) scheduling algorithm...';
                            } else if (lowerMessage.includes('alap') || lowerMessage.includes('backward')) {
                                executedAlgorithm = 'alap';
                                response = '‚è∞ Executing ALAP (Backward) scheduling algorithm...';
                            } else if (lowerMessage.includes('critical path')) {
                                executedAlgorithm = 'criticalPath';
                                response = 'üéØ Executing Critical Path optimization...';
                            } else if (lowerMessage.includes('level') || lowerMessage.includes('balance resource')) {
                                executedAlgorithm = 'levelResources';
                                response = '‚öñÔ∏è Executing Resource Leveling algorithm...';
                            } else if (lowerMessage.includes('drum') || lowerMessage.includes('toc') || lowerMessage.includes('constraint')) {
                                executedAlgorithm = 'drum';
                                response = 'ü•Å Executing Drum (Theory of Constraints) optimization...';
                            } else {
                                response = 'To optimize the schedule, please specify an algorithm. You can say:\n‚Ä¢ "Run ASAP scheduling"\n‚Ä¢ "Apply ALAP algorithm"\n‚Ä¢ "Execute critical path optimization"\n‚Ä¢ "Level resources"\n‚Ä¢ "Apply drum scheduling"';
                            }
                        } 
                        // Check for analysis or information requests
                        else if (lowerMessage.includes('what') || lowerMessage.includes('explain') || lowerMessage.includes('tell me about')) {
                            if (lowerMessage.includes('asap')) {
                                response = 'ASAP (As Soon As Possible) pushes all operations to the earliest possible time slots. Best for urgent orders or maximizing early throughput. Say "Run ASAP" to apply it.';
                            } else if (lowerMessage.includes('alap')) {
                                response = 'ALAP (As Late As Possible) delays operations to the latest time that still meets due dates. Minimizes inventory holding costs. Say "Run ALAP" to apply it.';
                            } else if (lowerMessage.includes('critical path')) {
                                response = 'Critical Path identifies the longest sequence of dependent tasks and optimizes them first. Minimizes project completion time. Say "Execute critical path" to apply it.';
                            } else if (lowerMessage.includes('level') || lowerMessage.includes('resource')) {
                                response = 'Resource Leveling distributes work evenly across all resources. Prevents overloading and improves efficiency. Say "Level resources" to apply it.';
                            } else if (lowerMessage.includes('drum') || lowerMessage.includes('toc')) {
                                response = 'Drum scheduling (TOC) identifies your bottleneck resource and optimizes around it. Maximizes throughput. Say "Apply drum scheduling" to apply it.';
                            } else if (lowerMessage.includes('current') || lowerMessage.includes('active')) {
                                const currentAlgo = document.getElementById('schedulingAlgorithm').value;
                                const algoNames = {
                                    'asap': 'ASAP (Forward)',
                                    'alap': 'ALAP (Backward)',
                                    'criticalPath': 'Critical Path',
                                    'levelResources': 'Resource Leveling',
                                    'drum': 'Drum (TOC)'
                                };
                                response = `The current active algorithm is: ${algoNames[currentAlgo]}. You can ask me to run any other algorithm to change it.`;
                            } else {
                                response = 'I can help you optimize the schedule. Try asking:\n‚Ä¢ "Run ASAP scheduling"\n‚Ä¢ "What is the current algorithm?"\n‚Ä¢ "Explain critical path"\n‚Ä¢ "Level the resources"';
                            }
                        }
                        // Check for help commands
                        else if (lowerMessage.includes('help') || lowerMessage.includes('commands')) {
                            response = 'üìä **Schedule Optimization Commands:**\n\n**Execute Algorithms:**\n‚Ä¢ Run ASAP\n‚Ä¢ Apply ALAP\n‚Ä¢ Execute critical path\n‚Ä¢ Level resources\n‚Ä¢ Apply drum scheduling\n\n**Get Information:**\n‚Ä¢ What is ASAP?\n‚Ä¢ Explain critical path\n‚Ä¢ Current algorithm?\n\n**Analysis:**\n‚Ä¢ Analyze schedule\n‚Ä¢ Show utilization';
                        }
                        // Check for analysis commands
                        else if (lowerMessage.includes('analyze') || lowerMessage.includes('utilization') || lowerMessage.includes('insights') || lowerMessage.includes('bottleneck')) {
                            // Perform detailed schedule analysis
                            const scheduler = window.scheduler;
                            const events = scheduler.eventStore.records || [];
                            const resources = scheduler.resourceStore.records || [];
                            
                            // Calculate resource utilization details
                            const resourceUsage = {};
                            resources.forEach(resource => {
                                const resourceEvents = events.filter(e => e.resourceId === resource.id);
                                let totalDuration = 0;
                                resourceEvents.forEach(event => {
                                    const duration = (event.endDate - event.startDate) / (1000 * 60 * 60); // hours
                                    totalDuration += duration;
                                });
                                resourceUsage[resource.name] = {
                                    operations: resourceEvents.length,
                                    hoursUsed: totalDuration.toFixed(1),
                                    utilization: resourceEvents.length > 0 ? 100 : 0
                                };
                            });
                            
                            // Find bottlenecks (resources with highest utilization)
                            let bottleneck = null;
                            let maxOps = 0;
                            Object.entries(resourceUsage).forEach(([name, data]) => {
                                if (data.operations > maxOps) {
                                    maxOps = data.operations;
                                    bottleneck = name;
                                }
                            });
                            
                            // Calculate timeline span
                            let earliestStart = null;
                            let latestEnd = null;
                            events.forEach(event => {
                                if (!earliestStart || event.startDate < earliestStart) {
                                    earliestStart = event.startDate;
                                }
                                if (!latestEnd || event.endDate > latestEnd) {
                                    latestEnd = event.endDate;
                                }
                            });
                            
                            const makespan = earliestStart && latestEnd ? 
                                ((latestEnd - earliestStart) / (1000 * 60 * 60)).toFixed(1) : 0;
                            
                            // Build comprehensive analysis
                            response = 'üìä **Production Schedule Analysis**\n\n';
                            response += `üìà **Overall Metrics:**\n`;
                            response += `‚Ä¢ Total Operations: ${events.length}\n`;
                            response += `‚Ä¢ Active Resources: ${Object.values(resourceUsage).filter(r => r.operations > 0).length}/${resources.length}\n`;
                            response += `‚Ä¢ Total Makespan: ${makespan} hours\n`;
                            response += `‚Ä¢ Current Algorithm: ${document.getElementById('schedulingAlgorithm').options[document.getElementById('schedulingAlgorithm').selectedIndex].text}\n\n`;
                            
                            response += `üè≠ **Resource Utilization:**\n`;
                            Object.entries(resourceUsage).forEach(([name, data]) => {
                                if (data.operations > 0) {
                                    response += `‚Ä¢ ${name}: ${data.operations} operations, ${data.hoursUsed} hours\n`;
                                }
                            });
                            
                            if (bottleneck) {
                                response += `\n‚ö†Ô∏è **Bottleneck Identified:**\n`;
                                response += `‚Ä¢ ${bottleneck} has the highest load with ${maxOps} operations\n`;
                            }
                            
                            // Optimization recommendations
                            response += `\nüí° **Optimization Recommendations:**\n`;
                            
                            const currentAlgo = document.getElementById('schedulingAlgorithm').value;
                            if (currentAlgo === 'asap') {
                                response += `‚Ä¢ Current: ASAP - Good for urgent orders\n`;
                                response += `‚Ä¢ Consider: ALAP to reduce inventory costs\n`;
                                response += `‚Ä¢ Consider: Level Resources to balance workload\n`;
                            } else if (currentAlgo === 'alap') {
                                response += `‚Ä¢ Current: ALAP - Minimizing inventory\n`;
                                response += `‚Ä¢ Consider: ASAP for faster delivery\n`;
                                response += `‚Ä¢ Consider: Critical Path to reduce makespan\n`;
                            } else if (currentAlgo === 'criticalPath') {
                                response += `‚Ä¢ Current: Critical Path - Optimized for completion time\n`;
                                response += `‚Ä¢ Consider: Level Resources if some resources are overloaded\n`;
                                response += `‚Ä¢ Consider: Drum/TOC if bottleneck is limiting throughput\n`;
                            } else if (currentAlgo === 'levelResources') {
                                response += `‚Ä¢ Current: Resource Leveling - Balanced workload\n`;
                                response += `‚Ä¢ Consider: Critical Path to reduce total time\n`;
                                response += `‚Ä¢ Consider: Drum/TOC to optimize bottlenecks\n`;
                            } else {
                                response += `‚Ä¢ Current: Drum/TOC - Optimized for bottlenecks\n`;
                                response += `‚Ä¢ Consider: ASAP for urgent completion\n`;
                                response += `‚Ä¢ Consider: Level Resources for even distribution\n`;
                            }
                            
                            response += `\nWould you like me to apply a different algorithm to optimize the schedule?`;
                        }
                        else {
                            response = `I understand you're asking about "${message}". I can help you optimize the schedule using different algorithms. Say "help" to see available commands.`;
                        }
                        
                        // Execute the algorithm if one was selected
                        if (executedAlgorithm) {
                            aiMsg.textContent = response;
                            maxMessages.appendChild(aiMsg);
                            maxMessages.scrollTop = maxMessages.scrollHeight;
                            
                            // Change the dropdown and execute
                            document.getElementById('schedulingAlgorithm').value = executedAlgorithm;
                            
                            // Execute the algorithm after a brief delay
                            setTimeout(() => {
                                // Click the apply button to trigger the algorithm
                                document.getElementById('applyScheduling').click();
                                
                                // Add success message after algorithm completes
                                setTimeout(() => {
                                    const successMsg = document.createElement('div');
                                    successMsg.className = 'max-ai-message assistant';
                                    const algoNames = {
                                        'asap': 'ASAP (Forward)',
                                        'alap': 'ALAP (Backward)',
                                        'criticalPath': 'Critical Path',
                                        'levelResources': 'Resource Leveling',
                                        'drum': 'Drum (TOC)'
                                    };
                                    
                                    // Get updated stats
                                    const utilization = document.getElementById('resourceUtilization').textContent;
                                    const totalOps = document.getElementById('operationCount').textContent;
                                    
                                    successMsg.textContent = `‚úÖ Successfully applied ${algoNames[executedAlgorithm]} algorithm!\n\nResults:\n‚Ä¢ ${totalOps}\n‚Ä¢ ${utilization}\n\nThe schedule has been optimized. Would you like to try a different algorithm?`;
                                    maxMessages.appendChild(successMsg);
                                    maxMessages.scrollTop = maxMessages.scrollHeight;
                                }, 1500); // Wait for algorithm to complete
                            }, 500);
                        } else {
                            aiMsg.textContent = response;
                            maxMessages.appendChild(aiMsg);
                            maxMessages.scrollTop = maxMessages.scrollHeight;
                        }
                    }, 300);
                    
                    maxMessages.scrollTop = maxMessages.scrollHeight;
                }
                
                // Max AI event listeners removed - using main app's AI panel
                // maxSend.addEventListener('click', sendMaxMessage);
                // maxInput.addEventListener('keypress', (e) => {
                //     if (e.key === 'Enter') sendMaxMessage();
                // });
                
                // Theme toggle removed - using consistent light theme with blue-purple gradient
                
                // View preset selector
                document.getElementById('viewPreset').addEventListener('change', (e) => {
                    scheduler.viewPreset = e.target.value;
                });
                
                // Zoom controls
                document.getElementById('zoomIn').addEventListener('click', () => {
                    scheduler.zoomLevel = Math.min(scheduler.zoomLevel + 2, 20);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    scheduler.zoomLevel = Math.max(scheduler.zoomLevel - 2, 0);
                });
                
                document.getElementById('zoomToFit').addEventListener('click', () => {
                    // Zoom to fit all events according to Bryntum official documentation
                    // https://bryntum.com/products/schedulerpro/docs/api/Scheduler/view/mixin/TimelineZoomable#function-zoomToFit
                    scheduler.zoomToFit({
                        leftMargin: 50,   // Margin in pixels between first event start and first visible date
                        rightMargin: 50   // Margin in pixels between last event end and last visible date
                    });
                    console.log('Zoom to fit applied with 50px margins');
                });
                
                // Shared function to apply selected algorithm - can be called by both button and agent
                async function applySelectedAlgorithm(algorithmName) {
                    const algorithm = algorithmName || document.getElementById('schedulingAlgorithm').value;
                    document.getElementById('loadingOverlay').style.display = 'flex';
                    
                    try {
                        const project = scheduler.project;
                        let message = '';
                        let color = 'green';
                        
                        console.log(`üöÄ Applying ${algorithm} algorithm...`);
                        
                        switch(algorithm) {
                            case 'asap':
                                // ASAP - As Soon As Possible (Forward Scheduling)
                                await asapScheduling();
                                message = 'ASAP scheduling applied - operations scheduled as early as possible!';
                                break;
                                
                            case 'alap':
                                // ALAP - As Late As Possible (Backward Scheduling)
                                await alapScheduling();
                                message = 'ALAP scheduling applied - operations scheduled as late as possible!';
                                color = 'blue';
                                break;
                                
                            case 'criticalPath':
                                // Critical Path Method
                                await criticalPathScheduling();
                                message = 'Critical Path identified and optimized!';
                                color = 'orange';
                                break;
                                
                            case 'levelResources':
                                // Resource Leveling
                                await levelResourcesScheduling();
                                message = 'Resources leveled - workload balanced across resources!';
                                color = 'purple';
                                break;
                                
                            case 'drum':
                                // Drum (Theory of Constraints)
                                await drumScheduling();
                                message = 'Drum scheduling applied - optimized around bottleneck!';
                                color = 'brown';
                                break;
                                
                            default:
                                console.warn('Unknown algorithm:', algorithm);
                                return false;
                        }
                        
                        console.log('‚úÖ Algorithm execution complete, committing changes...');
                        
                        // Commit the project changes
                        await scheduler.project.commitAsync();
                        
                        console.log('‚úÖ Changes committed, refreshing view...');
                        
                        // Refresh scheduler view
                        scheduler.refresh();
                        
                        // Apply zoom to fit after algorithm is applied
                        scheduler.zoomToFit({
                            leftMargin: 50,   // Margin in pixels between first event start and first visible date
                            rightMargin: 50   // Margin in pixels between last event end and last visible date
                        });
                        console.log('Zoom to fit applied after ' + algorithm + ' scheduling');
                        
                        // Save the optimized schedule to database
                        console.log('üìù Saving optimized schedule to database...');
                        const saveResult = await window.saveSchedule();
                        if (!saveResult) {
                            console.error('Failed to save schedule to database');
                        }
                        
                        // Create version history entry for the optimization
                        try {
                            console.log('üìù Creating version history entry...');
                            const authToken = getAuthToken();
                            const versionData = {
                                scheduleName: 'Main Schedule',
                                changeType: 'optimization',
                                changeDescription: `${message}`,
                                comment: `Algorithm: ${algorithm.toUpperCase()}`,
                                userId: 5 // Hardcoded for now, should ideally get from auth context
                            };
                            
                            const versionResponse = await fetch('/api/schedules/1/versions', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': authToken ? `Bearer ${authToken}` : ''
                                },
                                body: JSON.stringify(versionData)
                            });
                            
                            if (versionResponse.ok) {
                                console.log('‚úÖ Version history entry created successfully');
                            } else {
                                console.error('Failed to create version history entry:', await versionResponse.text());
                            }
                        } catch (error) {
                            console.error('Failed to create version history entry:', error);
                        }
                        
                        // Show success message with appropriate color
                        showAlgorithmSuccess(message, color);
                        
                        // Notify parent that algorithm completed
                        if (window.parent !== window) {
                            window.parent.postMessage({
                                type: 'ALGORITHM_COMPLETE',
                                data: { algorithm, message }
                            }, '*');
                        }
                        
                        return true;
                    } catch (error) {
                        console.error('Algorithm error:', error);
                        return false;
                    } finally {
                        document.getElementById('loadingOverlay').style.display = 'none';
                    }
                }
                
                // Make the function globally available
                window.applySelectedAlgorithm = applySelectedAlgorithm;
                
                // Apply Scheduling Algorithm button - just calls the shared function
                document.getElementById('applyScheduling').addEventListener('click', async () => {
                    await applySelectedAlgorithm();
                });
                
                // Save schedule to database - make it globally available
                window.saveSchedule = async function() {
                    try {
                        const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                        const operations = events.map(event => ({
                            id: event.id,
                            start: event.startDate.toISOString(),
                            end: event.endDate.toISOString()
                        }));
                        
                        console.log(`üíæ Saving schedule to database (${operations.length} operations)...`);
                        
                        // Get auth token using helper function
                        const authToken = getAuthToken();
                        
                        const response = await fetch('/api/pt-operations/schedule', {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': authToken ? `Bearer ${authToken}` : ''
                            },
                            body: JSON.stringify({ operations })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Save failed: ${response.statusText}`);
                        }
                        
                        const result = await response.json();
                        console.log(`‚úÖ Schedule saved: ${result.updated}/${result.total} operations updated`);
                        
                        // Notify parent window that schedule was updated
                        if (window.parent !== window) {
                            window.parent.postMessage({
                                type: 'SCHEDULE_UPDATED',
                                data: { savedOperations: result.updated, totalOperations: result.total }
                            }, '*');
                        }
                        
                        return true;
                    } catch (error) {
                        console.error('‚ùå Failed to save schedule:', error);
                        return false;
                    }
                }
                
                // Alias for backwards compatibility
                const saveSchedule = window.saveSchedule;

                // Shared helper functions for job extraction and sorting
                function getJobKey(ev) {
                    // Use numeric jobId for priority mapping since that's what the priority map uses
                    // The priority map is keyed by job.id from the ptjobs table
                    return ev.jobId ?? ev.job_id ??
                           ev.ptData?.jobId ?? ev.ptData?.job_id ??
                           ev.data?.jobId ?? ev.data?.job_id ?? null;
                }

                function getJobPriority(ev) {
                    // Priority 1 = highest, Priority 5 = lowest
                    const priority = ev.jobPriority ?? ev.job_priority ?? 
                                   ev.ptData?.jobPriority ?? ev.ptData?.job_priority ??
                                   ev.data?.jobPriority ?? ev.data?.job_priority ?? 999;
                    return parseInt(priority);
                }
                
                function getJobNumber(jobKey) {
                    if (!jobKey) return Number.MAX_SAFE_INTEGER;
                    const m = String(jobKey).match(/\d+/g);
                    return m ? parseInt(m.join(''), 10) : Number.MAX_SAFE_INTEGER;
                }

                function getSequence(ev) {
                    return ev.sequence_number ?? ev.sequenceNumber ??
                           ev.ptData?.sequence_number ?? ev.ptData?.sequenceNumber ?? 0;
                }

                // Process rank tiebreaker for when sequences are missing or tied
                function processRank(name = '') {
                    const n = name.toLowerCase();
                    if (n.includes('mill')) return 10;
                    if (n.includes('mash') || n.includes('decoction')) return 20;
                    if (n.includes('lauter')) return 30;
                    if (n.includes('boil') || n.includes('kettle')) return 40;
                    if (n.includes('ferment')) return 50;
                    if (n.includes('bright') || n.includes('condition')) return 60;
                    if (n.includes('packag') || n.includes('bottl') || n.includes('cann')) return 70;
                    return 999;
                }

                // Enhanced sequence sorting key that includes process rank as tiebreaker
                function sequenceSortKey(ev) {
                    const seq = Number(getSequence(ev) || 0);
                    return seq * 100 + processRank(ev.name || ev.operationName || '');
                }

                // Runtime test functions - can be run in DevTools console
                // Make these globally accessible for testing
                window.getJobKey = getJobKey;
                window.getJobPriority = getJobPriority;
                window.getSequence = getSequence;
                window.processRank = processRank;
                window.sequenceSortKey = sequenceSortKey;
                
                // Validation function to check for Boil-before-Fermentation violations
                window.checkBoilBeforeFerment = function () {
                    const bad = [];
                    const byJob = new Map();
                    
                    // Group events by job
                    scheduler.eventStore.records.forEach(e => {
                        const k = getJobKey(e);
                        if (!k || !e.startDate || !e.endDate) return;
                        (byJob.get(k) || byJob.set(k, []).get(k)).push(e);
                    });
                    
                    // Check each job for boil/fermentation ordering violations
                    byJob.forEach((ops, job) => {
                        // Find the last boil operation (highest end date)
                        const boil = ops.filter(o => /boil|kettle/i.test(o.name))
                            .sort((a, b) => a.startDate - b.startDate).pop();
                        
                        // Find the first fermentation operation (lowest start date)
                        const ferm = ops.filter(o => /ferment/i.test(o.name))
                            .sort((a, b) => a.startDate - b.startDate)[0];
                        
                        // Check if boil ends after fermentation starts (violation)
                        if (boil && ferm && boil.endDate > ferm.startDate) {
                            bad.push({ 
                                job: job, 
                                boil: boil.name, 
                                boilEnd: boil.endDate, 
                                ferm: ferm.name, 
                                fermStart: ferm.startDate,
                                overlap: new Date(boil.endDate - ferm.startDate).getTime() / (1000 * 60 * 60) // hours
                            });
                        }
                    });
                    
                    // Report results
                    if (bad.length > 0) {
                        console.error('‚ùå Boil-before-Fermentation violations found:');
                        console.table(bad);
                    } else {
                        console.log('‚úÖ No Boil-before-Fermentation violations found');
                    }
                    
                    return bad.length === 0;
                };
                
                // Test A: Verify no engine dependencies (only visual dependencies)
                window.testNoDependencies = function() {
                    // Use visual dependency store since engine store is intentionally null
                    const engineDeps = 0; // Always 0 - we don't use engine dependencies
                    const visualDeps = window.visualDependencyStore?.count || 0;
                    console.assert(engineDeps === 0, 'Project dependencyStore should be empty');
                    console.log('‚úÖ Test A - Dependencies Check:');
                    console.log('  Engine dependencies:', engineDeps, '(should be 0)');
                    console.log('  Visual dependencies:', visualDeps, '(visual lines only)');
                    return engineDeps === 0;
                };

                // Test B: Verify job finish order by priority
                window.testJobFinishOrder = function() {
                    const groups = new Map();
                    scheduler.eventStore.records.forEach(e => {
                        const k = getJobKey(e); 
                        if (!k) return;
                        const arr = groups.get(k) || groups.set(k, []).get(k);
                        arr.push(e);
                    });
                    const finishByJob = [...groups.entries()].map(([k, ops]) => ({
                        job: k,
                        priority: getJobPriority(ops[0]),
                        finish: new Date(Math.max(...ops.map(o => o.endDate?.getTime() || 0)))
                    })).sort((a, b) => a.finish - b.finish);
                    
                    console.log('‚úÖ Test B - Job Finish Order (should be by priority 1‚Üí5):');
                    console.table(finishByJob);
                    
                    // Verify priority order
                    let valid = true;
                    for (let i = 0; i < finishByJob.length - 1; i++) {
                        if (finishByJob[i].priority > finishByJob[i + 1].priority) {
                            console.warn(`‚ö†Ô∏è Job with priority ${finishByJob[i].priority} finishes after priority ${finishByJob[i + 1].priority}`);
                            valid = false;
                        }
                    }
                    return valid;
                };

                // Test C: Check for overlaps
                window.testNoOverlaps = function() {
                    let overlaps = 0;
                    const byRes = new Map();
                    scheduler.assignmentStore.forEach(a => {
                        const r = a.resourceId, e = scheduler.eventStore.getById(a.eventId);
                        if (!e) return;
                        (byRes.get(r) || byRes.set(r, []).get(r)).push(e);
                    });
                    byRes.forEach((list, resourceId) => {
                        list.sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < list.length - 1; i++) {
                            if (list[i].endDate > list[i + 1].startDate) {
                                overlaps++;
                                const resource = scheduler.resourceStore.getById(resourceId);
                                console.error(`‚ùå Overlap on ${resource?.name}: "${list[i].name}" ends at ${list[i].endDate.toLocaleString()} but "${list[i + 1].name}" starts at ${list[i + 1].startDate.toLocaleString()}`);
                            }
                        }
                    });
                    console.log('‚úÖ Test C - Overlap Check:');
                    console.log('  Overlaps found:', overlaps);
                    console.assert(overlaps === 0, 'No overlaps expected');
                    return overlaps === 0;
                };

                // Run all tests
                window.runAllTests = function() {
                    console.log('üß™ Running all scheduler tests...\n');
                    const testA = window.testNoDependencies();
                    const testB = window.testJobFinishOrder();
                    const testC = window.testNoOverlaps();
                    
                    console.log('\nüìä Test Results:');
                    console.log('  Test A (No Engine Dependencies):', testA ? '‚úÖ PASS' : '‚ùå FAIL');
                    console.log('  Test B (Job Priority Order):', testB ? '‚úÖ PASS' : '‚ùå FAIL');
                    console.log('  Test C (No Overlaps):', testC ? '‚úÖ PASS' : '‚ùå FAIL');
                    
                    const allPass = testA && testB && testC;
                    console.log('\n' + (allPass ? 'üéâ All tests passed!' : '‚ö†Ô∏è Some tests failed'));
                    return allPass;
                };

                // Left compaction helper for forward scheduling (ASAP)
                async function compactLeftPerResource() {
                    const { resourceStore, eventStore } = scheduler;
                    console.log('üì¶ Starting left compaction to remove gaps...');
                    let totalMoved = 0;
                    
                    for (const res of resourceStore.records) {
                        // Skip the unscheduled resource
                        if (res.id === 'unscheduled') continue;
                        
                        const evs = eventStore.records
                            .filter(e => String(e.resourceId) === String(res.id))
                            .filter(e => e.startDate && e.endDate)
                            .sort((a, b) => a.startDate - b.startDate);
                        
                        if (evs.length <= 1) continue; // Nothing to compact
                        
                        console.log(`  Compacting ${evs.length} operations on ${res.name}...`);
                        
                        // Process each event starting from the second one
                        for (let i = 1; i < evs.length; i++) {
                            const cur = evs[i];
                            const prev = evs[i - 1];
                            const dur = cur.endDate - cur.startDate;
                            
                            // Check if there's a gap between previous end and current start
                            if (cur.startDate > prev.endDate) {
                                // We can move this operation earlier to close the gap
                                const newStart = new Date(prev.endDate);
                                const newEnd = new Date(newStart.getTime() + dur);
                                
                                // IMPORTANT: Check that moving won't create overlaps with later operations
                                let canMove = true;
                                
                                // The move is safe because we're processing in order and only moving left
                                // to the end of the previous operation, which can't create overlaps
                                
                                if (canMove) {
                                    console.log(`    Moving "${cur.name}" from ${cur.startDate.toLocaleString()} to ${newStart.toLocaleString()}`);
                                    cur.set({ 
                                        startDate: newStart, 
                                        endDate: newEnd,
                                        manuallyScheduled: false
                                    });
                                    totalMoved++;
                                    
                                    // Update the event in our sorted array so subsequent operations see the new time
                                    evs[i] = cur;
                                }
                            }
                        }
                    }
                    
                    if (totalMoved > 0) {
                        console.log(`  ‚úÖ Compaction complete: moved ${totalMoved} operations to close gaps`);
                        await scheduler.project.commitAsync();
                        await scheduler.project.propagate();
                    } else {
                        console.log('  ‚úÖ No gaps found - schedule already compact');
                    }
                }

                // Scheduling Algorithm Implementations
                // Make asapScheduling globally accessible - now calls server-side algorithm
                let isAsapRunning = false; // Add flag to prevent re-entrance
                window.asapScheduling = async function asapScheduling() {
                    // Prevent re-entrance if already running
                    if (isAsapRunning) {
                        console.warn('‚ö†Ô∏è ASAP scheduling already in progress, skipping...');
                        return;
                    }
                    
                    isAsapRunning = true;
                    
                    try {
                        // ============================================================================
                        // ASAP (As Soon As Possible) - Server-Side Algorithm
                        // ============================================================================
                        // Calls the tested server-side ASAP algorithm that respects:
                        // 1. Job priority (1=highest, 5=lowest) 
                        // 2. Operation sequence within each job (1-9 must complete in order)
                        
                        console.log('üöÄ Calling server-side ASAP scheduling algorithm...');
                        
                        const scheduler = window.scheduler;
                        const { eventStore, resourceStore } = scheduler;
                        
                        // Collect current schedule data for the algorithm
                        const events = [...eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                        const resources = [...resourceStore.records];
                        
                        // Prepare schedule data in the format expected by the server algorithm
                        const scheduleData = {
                            operations: events.map(event => ({
                                id: event.id,
                                job_id: event.jobId || event.job_id || getJobKey(event),
                                sequence: getSequence(event) || 1,
                                resource: event.resourceId,
                                duration: event.duration || 1,
                                name: event.name,
                                startTime: event.startDate?.toISOString(),
                                endTime: event.endDate?.toISOString()
                            })),
                            resources: resources.map(res => ({
                                id: res.id,
                                name: res.name,
                                availability: true
                            })),
                            constraints: [],
                            algorithmName: 'asap'
                        };
                        
                        // Call the server-side algorithm
                        const authToken = getAuthToken();
                        const response = await fetch('/api/optimization/run', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': authToken ? `Bearer ${authToken}` : ''
                            },
                            body: JSON.stringify({
                                algorithmName: 'asap',
                                ...scheduleData
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Server algorithm failed: ${response.statusText}`);
                        }
                        
                        const result = await response.json();
                        console.log('‚úÖ Server-side ASAP algorithm completed', result);
                        
                        // Apply the optimized schedule to the UI using our improved function
                        if (result.optimizedSchedule && result.optimizedSchedule.operations) {
                            await applyOptimizationResults(result.optimizedSchedule);
                            console.log('‚úÖ ASAP scheduling applied successfully!');
                        } else {
                            throw new Error('Invalid optimization result from server');
                        }
                        
                        
                    } catch (error) {
                        console.error('‚ùå ASAP scheduling failed:', error);
                        throw error;
                    } finally {
                        // Always reset the flag, even if there was an error
                        isAsapRunning = false;
                    }
                }
                
                // OLD CLIENT-SIDE IMPLEMENTATION REMOVED - Now using server-side algorithm
                // The following code from lines 3926-4395 has been replaced with server call above
                /* REMOVED: 500+ lines of client-side ASAP scheduling logic */
                
                // Skip to line 4401 where the next function begins
                    console.log(`üìÖ Base scheduling date (today): ${today.toLocaleDateString()}`);
                    
                    // Map to store job-specific start dates (from manufacturing_release_date if available)
                        }
                    }
                    } finally {
                        // Always reset the flag, even if there was an error
                        isAsapRunning = false;
                    }
                }
                
                // Backward packer helper - finds the latest free slot on resource working backwards
                // CRITICAL: latestEnd is the absolute latest the operation can END (due to sequence constraints)
                function findLatestFreeSlotOnResource(resource, latestEnd, durationMs, excludeEvent) {
                    const { eventStore, assignmentStore } = scheduler;

                    // 1) Collect busy intervals for this resource
                    const busy = new Map(); // eventId -> { start, end }

                    // from assignments (multi-assign model)
                    if (assignmentStore?.count) {
                        assignmentStore.forEach(asg => {
                            if (String(asg.resourceId) === String(resource.id)) {
                                const ev = eventStore.getById(asg.eventId);
                                if (ev && ev !== excludeEvent && ev.startDate && ev.endDate) {
                                    busy.set(ev.id, { start: new Date(ev.startDate), end: new Date(ev.endDate) });
                                }
                            }
                        });
                    }

                    // from event.resourceId (single-assign model)
                    eventStore.records.forEach(ev => {
                        if (ev !== excludeEvent &&
                            String(ev.resourceId) === String(resource.id) &&
                            ev.startDate && ev.endDate) {
                            busy.set(ev.id, { start: new Date(ev.startDate), end: new Date(ev.endDate) });
                        }
                    });

                    // 2) Normalize & sort by start
                    const intervals = Array.from(busy.values())
                        .filter(i => i.start < i.end && i.start < latestEnd)
                        .sort((a, b) => a.start - b.start);

                    // 3) Merge overlaps
                    const merged = [];
                    for (const cur of intervals) {
                        if (merged.length === 0) {
                            merged.push({ ...cur });
                        } else {
                            const last = merged[merged.length - 1];
                            if (cur.start <= last.end) {
                                if (cur.end > last.end) last.end = cur.end; // extend
                            } else {
                                merged.push({ ...cur });
                            }
                        }
                    }

                    // 4) Walk from the right to find the latest gap that fits
                    // CRITICAL: We start from latestEnd which is the absolute latest this operation can end
                    // due to sequence constraints (must finish before successor starts)
                    const cal = resource.calendar || resource.project?.calendar;
                    let right = new Date(latestEnd);

                    // Snap right boundary to working time (backwards)
                    if (cal?.isNonWorkingTime?.(right)) right = cal.skipNonWorkingTime(right, false);

                    // Helper to return a working-time adjusted slot
                    // IMPORTANT: The returned slot MUST respect the latestEnd constraint
                    function finish(start, end) {
                        // CRITICAL SEQUENCE FIX: Never allow end to exceed latestEnd
                        if (end.getTime() > latestEnd.getTime()) {
                            end = new Date(latestEnd);
                        }
                        
                        // Snap again if needed
                        if (cal?.isNonWorkingTime?.(end)) end = cal.skipNonWorkingTime(end, false);
                        let s = new Date(end.getTime() - durationMs);

                        // If start is in non-working, snap backwards to previous working instant
                        if (cal?.isNonWorkingTime?.(s)) s = cal.skipNonWorkingTime(s, false);

                        return { start: s, end };
                    }

                    // Sentinel: if no intervals, the slot ends at 'right'
                    if (!merged.length) return finish(new Date(right.getTime() - durationMs), right);

                    // Consider only intervals that start < right
                    for (let i = merged.length - 1; i >= 0; i--) {
                        const iv = merged[i];

                        // If this interval ends after 'right', move 'right' to iv.start and continue (it overlaps the boundary)
                        if (iv.end > right) {
                            right = new Date(Math.min(right.getTime(), iv.start.getTime()));
                            continue;
                        }

                        // Latest candidate gap is (iv.end, right)
                        if (right - iv.end >= durationMs) {
                            const end = new Date(right);
                            const start = new Date(end.getTime() - durationMs);
                            // Fits here ‚Äî return right-justified inside the gap
                            return finish(start, end);
                        }

                        // Not enough room; move 'right' to the start of this interval and continue left
                        right = new Date(iv.start);
                    }

                    // Gap from -‚àû ‚Ä¶ right
                    return finish(new Date(right.getTime() - durationMs), right);
                }
                
                // ---- ALAP scheduled by Job Need-By date ----
                // ============================================================================
                // ALAP (As Late As Possible) - Backward Scheduling Algorithm
                // ============================================================================
                // This algorithm schedules operations backward from their need-by dates:
                // 1. Jobs are sorted by priority REVERSED (5 before 1) so lowest priority 
                //    schedules first and gets placed latest, leaving room for high priority
                // 2. Operations within each job are scheduled in REVERSE sequence order
                // 3. Last operation ends at the job's need-by date
                // 4. Earlier operations work backward in time (finish-to-start)
                //
                // IMPORTANT: Dependency lines are VISUAL ONLY for the Gantt chart.
                // The scheduling logic IGNORES dependencies and uses only priority + sequence.
                // ============================================================================
                window.alapScheduling = async function alapScheduling() {
                    console.log('üöÄ Calling server-side ALAP scheduling algorithm...');
                    
                    const scheduler = window.scheduler;
                    const { eventStore, resourceStore } = scheduler;
                    
                    try {
                        // Collect current schedule data for the algorithm
                        const events = [...eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                        const resources = [...resourceStore.records];
                        
                        // Prepare schedule data in the format expected by the server algorithm
                        const scheduleData = {
                            operations: events.map(event => ({
                                id: event.id,
                                job_id: event.jobId || event.job_id || getJobKey(event),
                                sequence: getSequence(event) || 1,
                                resource: event.resourceId,
                                duration: event.duration || 1,
                                name: event.name,
                                startTime: event.startDate?.toISOString(),
                                endTime: event.endDate?.toISOString()
                            })),
                            resources: resources.map(res => ({
                                id: res.id,
                                name: res.name,
                                availability: true
                            })),
                            constraints: [],
                            algorithmName: 'alap'
                        };
                        
                        // Call the server-side algorithm
                        const authToken = getAuthToken();
                        const response = await fetch('/api/optimization/run', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': authToken ? `Bearer ${authToken}` : ''
                            },
                            body: JSON.stringify({
                                algorithmName: 'alap',
                                ...scheduleData
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Server algorithm failed: ${response.statusText}`);
                        }
                        
                        const result = await response.json();
                        console.log('‚úÖ Server-side ALAP algorithm completed', result);
                        
                        // Apply the optimized schedule to the UI using our improved function
                        if (result.optimizedSchedule && result.optimizedSchedule.operations) {
                            await applyOptimizationResults(result.optimizedSchedule);
                            console.log('‚úÖ ALAP scheduling applied successfully!');
                        } else {
                            throw new Error('Invalid optimization result from server');
                        }
                    } catch (error) {
                        console.error('‚ùå ALAP scheduling failed:', error);
                        throw error;
                    }
                }
                
                // OLD CLIENT-SIDE ALAP IMPLEMENTATION REMOVED - Now using server-side algorithm
                /* The old implementation had 400+ lines of backward scheduling logic
                   Now replaced with a call to the tested server-side ALAP algorithm */
                    
                    // üîß CRITICAL: Disable ALL auto-scheduling features to prevent interference
                    const originalAutoSync = project.autoSync;
                    // Restore to visual dependency store, not project store
                    if (originalDeps.length > 0 && window.visualDependencyStore) {
                        const depStore = window.visualDependencyStore;
                        depStore.removeAll();
                        depStore.add(
                            originalDeps.map(({ id, from, to, type = 2, lag = 0, lagUnit = 'hour' }) => ({
                                id: String(id), 
                                fromEvent: from,  // Bryntum uses fromEvent/toEvent
                                toEvent: to,      // not from/to
                                type: type,
                                lag: lag,
                                lagUnit: lagUnit,
                                inactive: true,
                                cls: 'visual-dependency'
                            }))
                        );
                        console.log(`üé® Restored ${depStore.count} visual-only dependency lines to visual store`);
                    } else if (originalDeps.length === 0) {
                        console.log('‚ö†Ô∏è No original dependencies to restore');
                    }
                    
                    console.log('‚ñ∂Ô∏è Restored conflict validation settings');
                    
                    console.log('‚úÖ ALAP complete (backward cascade from Need-By dates). Compacting schedule‚Ä¶');
                    
                    // Add right-compaction pass to close gaps
                    async function compactRightPerResource() {
                        const { resourceStore, eventStore } = scheduler;

                        for (const res of resourceStore.records) {
                            // Get all events on this resource, sorted by start ASC
                            const evs = eventStore.records
                                .filter(e => String(e.resourceId) === String(res.id))
                                .filter(e => e.startDate && e.endDate)
                                .sort((a, b) => a.startDate - b.startDate);

                            // Slide each event as far right as possible up to the next event start
                            for (let i = evs.length - 2; i >= 0; i--) {
                                const cur = evs[i];
                                const next = evs[i + 1];
                                const dur = cur.endDate - cur.startDate;
                                
                                // --- FIX: Compute the job-sequence successor bound ---
                                const curJob = getJobKey(cur);
                                const curSeq = getSequence(cur);

                                // Find earliest successor in the same job with a higher sequence
                                const successor = eventStore.records
                                    .filter(e =>
                                        getJobKey(e) === curJob &&
                                        getSequence(e) > curSeq &&
                                        e.startDate && e.endDate)
                                    .sort((a, b) => getSequence(a) - getSequence(b))[0];

                                // The rightmost end we allow is the min of:
                                //  - next event on this resource
                                //  - the successor's start in the same job (if any)
                                const boundFromResource = next.startDate;
                                const boundFromJob = successor ? successor.startDate : null;
                                const latestEnd = boundFromJob
                                    ? new Date(Math.min(boundFromResource.getTime(), boundFromJob.getTime()))
                                    : boundFromResource;
                                
                                // Debug logging for sequence constraint enforcement
                                if (boundFromJob && boundFromJob.getTime() < boundFromResource.getTime()) {
                                    console.log(`  üîí Constraining "${cur.name}" end by job successor "${successor.name}" at ${boundFromJob.toLocaleString()}`);
                                }
                                // --- End of FIX ---
                                
                                const slot = findLatestFreeSlotOnResource(res, latestEnd, dur, cur);
                                cur.set({ startDate: slot.start, endDate: slot.end, manuallyScheduled: false });
                            }
                        }

                        await scheduler.project.commitAsync();
                        await scheduler.project.propagate();
                    }

                    await compactRightPerResource();
                    
                    // Verify overlaps but don't save automatically
                    if (typeof assertNoOverlaps === 'function' && assertNoOverlaps(scheduler)) {
                        console.log('  ‚úÖ No overlaps detected - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.error('‚ùå Overlap verification failed after ALAP.');
                        
                        // Check again after repair
                        if (assertNoOverlaps(scheduler)) {
                            console.log('  ‚úÖ Overlaps successfully repaired - schedule ready to save');
                            // REMOVED automatic save - user must click Save button
                        } else {
                            console.error('  ‚ùå Failed to repair all overlaps');
                        }
                    }
                }
                
                async function criticalPathScheduling() {
                    // Identify and optimize critical path - Schedule by resource to prevent overlaps
                    console.log('üöÄ Starting Critical Path scheduling...');
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    const baseDate = new Date(2025, 8, 3);
                    baseDate.setHours(7, 0, 0, 0);
                    
                    // Group by resource and schedule sequentially
                    const resourceEvents = {};
                    events.forEach(event => {
                        if (!resourceEvents[event.resourceId]) {
                            resourceEvents[event.resourceId] = [];
                        }
                        resourceEvents[event.resourceId].push(event);
                    });
                    
                    Object.keys(resourceEvents).forEach(resourceId => {
                        const resEvents = resourceEvents[resourceId];
                        let nextAvailableTime = new Date(baseDate);
                        
                        resEvents.forEach(event => {
                            event.startDate = new Date(nextAvailableTime);
                            const durationMs = event.duration * 60 * 60 * 1000;
                            event.endDate = new Date(event.startDate.getTime() + durationMs);
                            nextAvailableTime = new Date(event.endDate.getTime() + 30 * 60 * 1000);
                        });
                    });
                    
                    await scheduler.project.commitAsync();
                    await scheduler.project.propagate();
                    console.log('‚úÖ Critical Path scheduling completed');
                    
                    // VERIFY no overlaps
                    let overlapsFound = 0;
                    Object.keys(resourceEvents).forEach(resourceId => {
                        const resEvents = resourceEvents[resourceId].sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < resEvents.length - 1; i++) {
                            if (resEvents[i].endDate > resEvents[i + 1].startDate) {
                                overlapsFound++;
                            }
                        }
                    });
                    if (overlapsFound === 0) {
                        console.log('‚úÖ Critical Path Verification passed - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.log(`‚ùå Critical Path FAILED: ${overlapsFound} overlaps`);
                    }
                }
                
                async function levelResourcesScheduling() {
                    // Balance workload across resources to reduce utilization peaks
                    console.log('üöÄ Starting Level Resources scheduling...');
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    const resources = [...scheduler.resourceStore.records].filter(r => r.id !== 'unscheduled');
                    
                    if (events.length === 0 || resources.length === 0) return;
                    
                    // Calculate current resource loads and identify overloaded resources
                    const resourceEvents = {};
                    resources.forEach(r => {
                        resourceEvents[r.id] = [];
                    });
                    
                    events.forEach(event => {
                        if (resourceEvents[event.resourceId]) {
                            resourceEvents[event.resourceId].push(event);
                        }
                    });
                    
                    // Set base scheduling date - Sept 3, 2025
                    const baseDate = new Date(2025, 8, 3);
                    baseDate.setHours(7, 0, 0, 0); // 7 AM start
                    
                    // Calculate scheduling span - 14 days (2 weeks)
                    const endDate = new Date(2025, 8, 17);
                    endDate.setHours(17, 0, 0, 0); // 5 PM end
                    
                    const workingHoursPerDay = 10; // 7 AM to 5 PM
                    const totalDays = 14;
                    const totalAvailableHours = totalDays * workingHoursPerDay * resources.length;
                    
                    // Level the resources by spreading operations evenly
                    const resourceNextAvailable = {};
                    resources.forEach(r => {
                        resourceNextAvailable[r.id] = new Date(baseDate);
                    });
                    
                    // Sort events by priority/duration to optimize scheduling
                    events.sort((a, b) => {
                        // Prioritize longer operations first for better packing
                        return (b.duration || 0) - (a.duration || 0);
                    });
                    
                    // Redistribute operations to level resource utilization
                    events.forEach(event => {
                        // Find the resource that becomes available earliest
                        let earliestResource = event.resourceId;
                        let earliestTime = resourceNextAvailable[event.resourceId] || new Date(baseDate);
                        
                        // For leveling, we can look for other compatible resources with earlier availability
                        // For now, keep original resource assignments but spread timing
                        
                        // Schedule the operation
                        const startTime = new Date(resourceNextAvailable[event.resourceId] || baseDate);
                        
                        // Add gaps between operations to reduce utilization percentage
                        // This simulates maintenance, changeover, or buffer time
                        const bufferMinutes = 60; // 1 hour buffer between operations
                        
                        event.startDate = startTime;
                        const durationMs = (event.duration || 2) * 60 * 60 * 1000;
                        event.endDate = new Date(startTime.getTime() + durationMs);
                        
                        // Update next available time for this resource (with buffer)
                        resourceNextAvailable[event.resourceId] = new Date(event.endDate.getTime() + bufferMinutes * 60 * 1000);
                        
                        // If we've exceeded working hours for the day, move to next day
                        const nextAvail = resourceNextAvailable[event.resourceId];
                        if (nextAvail.getHours() >= 17) {
                            // Move to next day at 7 AM
                            nextAvail.setDate(nextAvail.getDate() + 1);
                            nextAvail.setHours(7, 0, 0, 0);
                            resourceNextAvailable[event.resourceId] = nextAvail;
                        }
                    });
                    
                    // Commit the changes
                    await scheduler.project.commitAsync();
                    await scheduler.project.propagate();
                    console.log('‚úÖ Level Resources scheduling completed');
                    
                    // VERIFY no overlaps
                    let overlapsFound = 0;
                    Object.keys(resourceEvents).forEach(resourceId => {
                        const resEvents = resourceEvents[resourceId].sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < resEvents.length - 1; i++) {
                            if (resEvents[i].endDate > resEvents[i + 1].startDate) {
                                overlapsFound++;
                            }
                        }
                    });
                    if (overlapsFound === 0) {
                        console.log('‚úÖ Level Resources Verification passed - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.log(`‚ùå Level Resources FAILED: ${overlapsFound} overlaps`);
                    }
                    
                    // Force a refresh to recalculate utilization
                    setTimeout(() => {
                        window.updateStatus();
                    }, 100);
                }
                
                // ============================================================================
                // DRUM (Theory of Constraints) - Bottleneck-Based Scheduling Algorithm
                // ============================================================================
                // This algorithm implements the Drum-Buffer-Rope (DBR) methodology:
                // 1. Identifies the bottleneck resource (drum) - highest total load
                // 2. Schedules the drum optimally (longest operations first)
                // 3. Schedules feeding resources to keep drum supplied (rope)
                // 4. Adds buffers to protect the drum from disruptions
                //
                // IMPORTANT: Dependency lines are VISUAL ONLY for the Gantt chart.
                // The scheduling logic IGNORES dependencies and focuses on bottleneck optimization.
                // ============================================================================
                async function drumScheduling() {
                    console.log('üöÄ Starting Drum (TOC) scheduling - Theory of Constraints');
                    console.log('üìå NOTE: Dependencies are visual-only. Scheduling optimizes bottleneck resource.');
                    
                    // No need to clear dependencies - they're only in the feature store for visual display
                    console.log('üé® Dependencies are visual-only, no clearing needed for Drum scheduling');
                    
                    const events = [...scheduler.eventStore.records].filter(e => e.resourceId !== 'unscheduled');
                    
                    // ========================================================================
                    // Step 1: Identify the Bottleneck Resource (The Drum)
                    // The resource with the highest total workload becomes the constraint
                    // ========================================================================
                    const resourceLoad = {};
                    events.forEach(event => {
                        if (!resourceLoad[event.resourceId]) {
                            resourceLoad[event.resourceId] = 0;
                        }
                        resourceLoad[event.resourceId] += event.duration;
                    });
                    
                    let drumResourceId = null;
                    let maxLoad = 0;
                    Object.entries(resourceLoad).forEach(([resourceId, load]) => {
                        if (load > maxLoad) {
                            maxLoad = load;
                            drumResourceId = resourceId;
                        }
                    });
                    
                    if (!drumResourceId) {
                        console.log('‚ö†Ô∏è No bottleneck resource found');
                        return;
                    }
                    
                    const drumResource = scheduler.resourceStore.getById(drumResourceId);
                    console.log(`  ü•Å Bottleneck (drum) identified: ${drumResource?.name || drumResourceId}`);
                    console.log(`     Total load: ${maxLoad.toFixed(1)} hours`);
                    
                    // Use today as the base scheduling date (similar to ASAP)
                    const baseDate = new Date();
                    baseDate.setHours(7, 0, 0, 0); // Start at 7 AM today
                    
                    // ========================================================================
                    // Step 2: Schedule the Drum (Bottleneck) Resource
                    // Operations on the drum are scheduled longest-first to minimize makespan
                    // ========================================================================
                    const drumEvents = events.filter(e => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === e.id);
                        return assignment && assignment.resourceId === drumResourceId;
                    });
                    let drumTime = new Date(baseDate);
                    
                    // Sort drum operations by duration (longest first for optimal throughput)
                    drumEvents.sort((a, b) => b.duration - a.duration);
                    console.log(`  üìã Scheduling ${drumEvents.length} operations on drum resource`);
                    
                    drumEvents.forEach(event => {
                        event.startDate = new Date(drumTime);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        // Add protective buffer between drum operations (Theory of Constraints principle)
                        drumTime = new Date(event.endDate.getTime() + 15 * 60 * 1000); // 15 min buffer
                        console.log(`    ‚è±Ô∏è ${event.name}: ${event.duration.toFixed(1)}h`);
                    });
                    
                    // ========================================================================
                    // Step 3: Schedule the Rope (Feeding Resources)
                    // Non-bottleneck resources are scheduled to feed the drum on time
                    // ========================================================================
                    const feedingEvents = events.filter(e => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === e.id);
                        return assignment && assignment.resourceId !== drumResourceId;
                    });
                    const resourceSchedules = {}; // Track next available time for each resource
                    
                    console.log(`  üîó Scheduling ${feedingEvents.length} feeding operations`);
                    
                    feedingEvents.forEach(event => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === event.id);
                        const resourceId = assignment ? assignment.resourceId : null;
                        if (!resourceId) return;
                        
                        // Initialize resource timeline if not exists
                        if (!resourceSchedules[resourceId]) {
                            const feedTime = new Date(baseDate);
                            feedTime.setHours(7, 0, 0, 0); // Start at same time as drum
                            resourceSchedules[resourceId] = feedTime;
                        }
                        
                        // Schedule operation sequentially on its resource
                        event.startDate = new Date(resourceSchedules[resourceId]);
                        const durationMs = event.duration * 60 * 60 * 1000;
                        event.endDate = new Date(event.startDate.getTime() + durationMs);
                        // Add buffer to protect feeding operations (rope principle)
                        resourceSchedules[resourceId] = new Date(event.endDate.getTime() + 30 * 60 * 1000); // 30 min buffer
                    });
                    
                    await scheduler.project.commitAsync();
                    await scheduler.project.propagate();
                    
                    // Restore visual-only dependencies to feature store (not project store)
                    console.log('üîç Restoring visual dependencies...');
                    const originalDeps = window.originalDependencies || [];
                    console.log(`üîç Found ${originalDeps.length} original dependencies to restore`);
                    
                    // Restore to visual dependency store, not project store
                    if (originalDeps.length > 0 && window.visualDependencyStore) {
                        const depStore = window.visualDependencyStore;
                        depStore.removeAll();
                        depStore.add(
                            originalDeps.map(({ id, from, to, type = 2, lag = 0, lagUnit = 'hour' }) => ({
                                id: String(id), 
                                fromEvent: from,  // Bryntum uses fromEvent/toEvent
                                toEvent: to,      // not from/to
                                type: type,
                                lag: lag,
                                lagUnit: lagUnit,
                                inactive: true,
                                cls: 'visual-dependency'
                            }))
                        );
                        console.log(`üé® Restored ${depStore.count} visual-only dependency lines to visual store`);
                    } else if (originalDeps.length === 0) {
                        console.log('‚ö†Ô∏è No original dependencies to restore');
                    }
                    
                    console.log('‚úÖ Drum (TOC) scheduling completed');
                    
                    // VERIFY no overlaps - use assignments to track resources
                    let overlapsFound = 0;
                    const allResourceEvents = {};
                    events.forEach(event => {
                        const assignment = scheduler.assignmentStore.find(a => a.eventId === event.id);
                        const resourceId = assignment ? assignment.resourceId : null;
                        if (!resourceId) return;
                        
                        if (!allResourceEvents[resourceId]) {
                            allResourceEvents[resourceId] = [];
                        }
                        allResourceEvents[resourceId].push(event);
                    });
                    
                    Object.keys(allResourceEvents).forEach(resourceId => {
                        const resEvents = allResourceEvents[resourceId].sort((a, b) => a.startDate - b.startDate);
                        for (let i = 0; i < resEvents.length - 1; i++) {
                            if (resEvents[i].endDate > resEvents[i + 1].startDate) {
                                overlapsFound++;
                            }
                        }
                    });
                    if (overlapsFound === 0) {
                        console.log('‚úÖ Drum Verification passed - schedule ready to save');
                        // REMOVED automatic save - user must click Save button
                    } else {
                        console.log(`‚ùå Drum FAILED: ${overlapsFound} overlaps`);
                    }
                }
                
                // Initialize status updates
                window.updateStatus();
                
                // CRITICAL: Helper function to wait for scheduler to be ready
                // This eliminates the need for arbitrary timeouts
                window.waitForSchedulerReady = function(timeout = 30000) {
                    return new Promise((resolve, reject) => {
                        // Check if already ready
                        if (window.schedulerReady && window.scheduler?.eventStore?.count > 0) {
                            console.log('‚úÖ Scheduler already ready with', window.scheduler.eventStore.count, 'operations');
                            resolve({
                                ready: true,
                                eventCount: window.scheduler.eventStore.count,
                                resourceCount: window.scheduler.resourceStore.count,
                                assignmentCount: window.scheduler.assignmentStore.count
                            });
                            return;
                        }
                        
                        console.log('‚è≥ Waiting for scheduler to load operations...');
                        
                        // Set up timeout
                        const timeoutId = setTimeout(() => {
                            window.removeEventListener('schedulerOperationsLoaded', handleReady);
                            clearInterval(pollInterval);
                            reject(new Error('Timeout waiting for scheduler to be ready'));
                        }, timeout);
                        
                        // Listen for the custom paint event
                        const handleReady = (event) => {
                            clearTimeout(timeoutId);
                            clearInterval(pollInterval);
                            window.removeEventListener('schedulerOperationsLoaded', handleReady);
                            console.log('üé® Scheduler paint event received! Operations loaded:', event.detail);
                            resolve({
                                ready: true,
                                ...event.detail
                            });
                        };
                        
                        window.addEventListener('schedulerOperationsLoaded', handleReady);
                        
                        // Also poll periodically as backup (in case event was already fired)
                        const pollInterval = setInterval(() => {
                            if (window.scheduler?.eventStore?.count > 0) {
                                clearTimeout(timeoutId);
                                clearInterval(pollInterval);
                                window.removeEventListener('schedulerOperationsLoaded', handleReady);
                                console.log('‚úÖ Scheduler ready (detected by polling) with', window.scheduler.eventStore.count, 'operations');
                                resolve({
                                    ready: true,
                                    eventCount: window.scheduler.eventStore.count,
                                    resourceCount: window.scheduler.resourceStore.count,
                                    assignmentCount: window.scheduler.assignmentStore.count
                                });
                            }
                        }, 500);
                    });
                };
                
                // CRITICAL FIX: Define global scheduling functions that were missing
                // These functions are called from elsewhere but weren't defined
                // Add flag to prevent re-entrance
                let isScheduleASAPRunning = false;
                
                window.scheduleASAP = async function() {
                    // Prevent re-entrance if already running
                    if (isScheduleASAPRunning) {
                        console.warn('‚ö†Ô∏è scheduleASAP already in progress, skipping...');
                        return;
                    }
                    
                    isScheduleASAPRunning = true;
                    
                    try {
                        console.log('üìÖ Running ASAP scheduling...');
                        await window.waitForSchedulerReady(); // Wait for operations to be loaded
                        const project = scheduler.project;
                        
                        // Disable auto-calculation BEFORE making changes to prevent loops
                        const wasAutoCalculate = project.autoCalculate;
                        project.autoCalculate = false;
                        
                        // Set scheduling direction
                        project.schedulingDirection = 'forward';
                        
                        // Manually trigger calculation once
                        await project.propagate();
                        
                        // Commit the scheduled changes
                        await project.commitAsync();
                        
                        // Restore previous auto-calculate state (should stay false)
                        project.autoCalculate = wasAutoCalculate;
                        
                        console.log('‚úÖ ASAP scheduling complete');
                        window.updateStatus(); // Use updateStatus instead of updateSchedulerStatus
                    } catch (error) {
                        console.error('‚ùå ASAP scheduling error:', error);
                    } finally {
                        isScheduleASAPRunning = false;
                    }
                };
                
                // Add flag to prevent re-entrance for ALAP
                let isScheduleALAPRunning = false;
                
                window.scheduleALAP = async function() {
                    // Prevent re-entrance if already running
                    if (isScheduleALAPRunning) {
                        console.warn('‚ö†Ô∏è scheduleALAP already in progress, skipping...');
                        return;
                    }
                    
                    isScheduleALAPRunning = true;
                    
                    try {
                        console.log('üìÖ Running ALAP scheduling...');
                        await window.waitForSchedulerReady(); // Wait for operations to be loaded
                        const project = scheduler.project;
                        
                        // Disable auto-calculation BEFORE making changes to prevent loops
                        const wasAutoCalculate = project.autoCalculate;
                        project.autoCalculate = false;
                        
                        // Set scheduling direction
                        project.schedulingDirection = 'backward';
                        
                        // Manually trigger calculation once
                        await project.propagate();
                        
                        // Commit the scheduled changes
                        await project.commitAsync();
                        
                        // Restore previous auto-calculate state (should stay false)
                        project.autoCalculate = wasAutoCalculate;
                        
                        console.log('‚úÖ ALAP scheduling complete');
                        window.updateStatus(); // Use updateStatus instead of updateSchedulerStatus
                    } catch (error) {
                        console.error('‚ùå ALAP scheduling error:', error);
                    } finally {
                        isScheduleALAPRunning = false;
                    }
                };
                
                window.optimizeSchedule = async function(algorithmId) {
                    console.log(`üìÖ Running optimization algorithm: ${algorithmId}...`);
                    await window.waitForSchedulerReady(); // Wait for operations to be loaded
                    // Apply the selected algorithm
                    await applyAlgorithm(scheduler, algorithmId);
                    console.log(`‚úÖ ${algorithmId} optimization complete`);
                    window.updateStatus(); // Use updateStatus instead of updateSchedulerStatus
                };
                
                console.log('[Scheduler] Helper function registered: window.waitForSchedulerReady(timeout)');
                console.log('[Scheduler] Global scheduling functions registered: window.scheduleASAP(), window.scheduleALAP(), window.optimizeSchedule(algorithmId)');
                
                // CRITICAL DATA LOADING FIX: Load the events into the scheduler's event store
                // The events array was created but never actually loaded into the scheduler
                console.log('üìä Loading data into scheduler - resources:', resources.length, 'events:', events.length, 'dependencies:', dependencies.length);
                
                // CRITICAL FIX: First preserve the resource mapping, then remove resourceId from events
                // Step 1: Create assignments using the original events with resourceId
                const assignments = events.map((event) => ({
                    id: `assignment_${event.id}`,
                    eventId: event.id,
                    resourceId: event.resourceId, // Capture resourceId before removing it
                    units: 100 // Units indicate how much of the resource is consumed (100 = 100%)
                }));
                
                console.log('üìä Created assignments:', assignments.length);
                console.log('üìä First 3 assignments:', assignments.slice(0, 3));
                
                // Step 2: NOW create clean events without resourceId for the scheduler
                // This prevents the "multi-assignment mode" error
                const eventsForScheduler = events.map(event => {
                    // Create new object without resourceId property
                    const cleanEvent = {
                        id: event.id,
                        name: event.name,
                        startDate: event.startDate,
                        endDate: event.endDate,
                        duration: event.duration,
                        durationUnit: event.durationUnit,
                        percentDone: event.percentDone,
                        constraintType: event.constraintType,
                        constraintDate: event.constraintDate,
                        eventColor: event.eventColor,
                        jobName: event.jobName,
                        jobId: event.jobId,
                        jobDueDate: event.jobDueDate, // CRITICAL: Preserve job Need-By date for ALAP
                        sequence_number: event.sequence_number, // CRITICAL: Preserve sequence number for ALAP
                        operationId: event.operationId,
                        manually_scheduled: event.manually_scheduled,
                        isUnscheduled: event.isUnscheduled
                    };
                    // Explicitly ensure no resourceId exists
                    delete cleanEvent.resourceId;
                    return cleanEvent;
                });
                
                // Load the inline data into the scheduler project
                // CRITICAL: Bryntum requires specific property names ending with 'Data'
                try {
                    console.log('‚è≥ Loading inline data into scheduler...');
                    console.log('Resources count:', resources.length);
                    console.log('Events count:', eventsForScheduler.length);
                    console.log('Assignments count:', assignments.length);
                    console.log('Dependencies count:', dependencies.length);
                    
                    // Debug overlay removed - was obstructing the view
                    // Keep console logging for debugging if needed
                    console.log(`Loading: ${resources.length} resources, ${eventsForScheduler.length} events, ${assignments.length} assignments`);
                    
                    // Transform PT operations to ensure they have the correct format for Bryntum
                    const transformedEvents = eventsForScheduler.map(event => {
                        // Ensure dates are Date objects - provide default if null
                        let startDate = null;
                        let endDate = null;
                        
                        // If operation has scheduled dates, use them
                        if (event.startDate) {
                            startDate = event.startDate instanceof Date ? event.startDate : new Date(event.startDate);
                        }
                        if (event.endDate) {
                            endDate = event.endDate instanceof Date ? event.endDate : new Date(event.endDate);
                        }
                        
                        // If no scheduled dates, create unscheduled placeholder dates for display
                        // These will be replaced by ASAP/ALAP/Drum algorithms
                        if (!startDate || !endDate) {
                            const today = new Date();
                            today.setHours(8, 0, 0, 0);  // Start at 8 AM
                            startDate = new Date(today);
                            // Use duration if available, otherwise default to 1 hour
                            const durationHours = event.duration || 1;
                            endDate = new Date(startDate.getTime() + durationHours * 60 * 60 * 1000);
                        }
                        
                        return {
                            id: event.id,
                            name: event.name || 'Unnamed Operation',
                            startDate: startDate,
                            endDate: endDate,
                            eventColor: event.eventColor || event.color || 'green',
                            // Remove resourceId from event - it should come from assignments
                            percentDone: event.percentDone || 0,
                            duration: event.duration,
                            durationUnit: event.durationUnit || 'hour',
                            isUnscheduled: !event.startDate || !event.endDate,  // Flag unscheduled operations
                            // CRITICAL: Preserve job information to prevent orphan treatment
                            jobId: event.jobId,
                            jobName: event.jobName,
                            jobPriority: event.jobPriority,
                            jobDueDate: event.jobDueDate,
                            sequence_number: event.sequence_number,
                            operationId: event.operationId,
                            manually_scheduled: event.manually_scheduled
                        };
                    }); // Removed filter - keep all operations for scheduling
                    
                    console.log(`‚úÖ Transformed ${transformedEvents.length} valid events with dates`);
                    
                    // Load data including dependencies (marked as inactive for visual-only)
                    // Transform dependencies to ensure they're inactive/visual-only
                    const visualDependencies = (fetchedDependencies || []).map(dep => ({
                        id: String(dep.id),
                        from: dep.from,
                        to: dep.to,
                        type: parseInt(dep.type) || 2,
                        lag: parseInt(dep.lag) || 0,
                        lagUnit: dep.lagUnit || 'hour',
                        active: false,  // CRITICAL: Mark as inactive for visual-only
                        cls: 'b-inactive visual-dependency'  // Add CSS class for styling
                    }));
                    
                    await scheduler.project.loadInlineData({
                        resourcesData: resources,
                        eventsData: transformedEvents, // Use transformed events
                        assignmentsData: assignments, // Assignments link events to resources
                        dependenciesData: visualDependencies // Load inactive dependencies for visualization
                    });
                    
                    // Keep a copy globally
                    window.originalDependencies = fetchedDependencies || [];
                    
                    // Log dependency loading status
                    console.log(`‚úÖ Loaded ${visualDependencies.length} visual-only dependencies`);
                    if (visualDependencies.length > 0) {
                        const sampleDeps = visualDependencies.slice(0, 3);
                        console.log('Sample dependencies:', sampleDeps.map(d => ({
                            id: d.id,
                            from: d.from,
                            to: d.to,
                            active: d.active
                        })));
                    }
                    
                    console.log(`‚úÖ Loaded! Store has: ${scheduler.eventStore.count} events`);
                    console.log('‚úÖ Inline data loaded successfully');
                    
                    // Save the original stores immediately after loading
                    // This ensures we have the unfiltered data before any filtering occurs
                    window.masterResourceStore = scheduler.project.resourceStore;
                    window.masterEventStore = scheduler.project.eventStore;
                    window.masterAssignmentStore = scheduler.project.assignmentStore;
                    console.log('üì¶ [Initial Load] Master stores saved with all data');
                    
                    // Debug: Check if resources have planning_area field
                    console.log('üîç [Debug] Checking planning_area in master resource store:');
                    const sampleResources = window.masterResourceStore.records.slice(0, 3);
                    sampleResources.forEach(r => {
                        const planningArea = r.planning_area || r.data?.planning_area || r.get?.('planning_area');
                        console.log(`  - ${r.name || r.get?.('name')}: planning_area = ${planningArea}`);
                    });
                    
                    // DISABLED: Commit was triggering automatic propagation/scheduling
                    // Users should manually trigger scheduling via Apply button
                    // await scheduler.project.commitAsync();
                    
                    console.log('‚úÖ Data loaded (not committed - manual scheduling required)');
                    
                    // Log success to console
                    console.log(`‚úÖ Loaded ${scheduler.eventStore.count} operations on ${scheduler.resourceStore.count} resources`);
                    
                    // Update status bar
                    window.updateStatus();
                    
                    // Zoom to fit after loading
                    if (scheduler.zoomToFit) {
                        setTimeout(() => {
                            scheduler.zoomToFit();
                        }, 100);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading data into scheduler:', error);
                    console.error('Error details:', error.message, error.stack);
                }
                
                console.log('‚úÖ Data loaded into scheduler event store:', scheduler.eventStore.count, 'events');
                
                // Show alert to debug data loading
                const eventCount = scheduler.eventStore.count || 0;
                const resourceCount = scheduler.resourceStore.count || 0;
                const assignmentCount = scheduler.assignmentStore.count || 0;
                
                console.warn(`üìä Final counts - Resources: ${resourceCount}, Events: ${eventCount}, Assignments: ${assignmentCount}`);
                
                // CRITICAL: Fire custom event when operations are loaded and ready
                // This allows external code to know when the scheduler is ready without waiting
                if (eventCount > 0) {
                    window.schedulerReady = true;
                    window.dispatchEvent(new CustomEvent('schedulerOperationsLoaded', {
                        detail: {
                            eventCount,
                            resourceCount,
                            assignmentCount,
                            timestamp: Date.now()
                        }
                    }));
                    console.log('üé® Paint event fired: Scheduler operations loaded and ready!');
                    
                    // Auto-zoom to fit whenever operations are loaded
                    setTimeout(() => {
                        if (scheduler.zoomToFit) {
                            scheduler.zoomToFit({ leftMargin: 50, rightMargin: 50 });
                            console.log('‚úÖ Auto-zoomed to fit after operations loaded');
                        }
                    }, 200);
                }
                
                if (eventCount === 0) {
                    console.error('‚ùå NO EVENTS LOADED! Debugging info:');
                    console.error('Resources loaded:', resources.length);
                    console.error('Events to load:', events.length);
                    console.error('First event:', events[0]);
                }
                
                // DISABLED: Auto-ASAP was causing infinite loops
                // Users should manually click Apply button to run scheduling
                console.log('‚ÑπÔ∏è Scheduler loaded. Click "Apply" button to run ASAP scheduling.');
                
                // Periodic status refresh
                setInterval(window.updateStatus, 30000); // Update every 30 seconds
                
                // Hide loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
                
                // Check for pending scheduler commands from Max AI (after navigation)
                const pendingCommand = sessionStorage.getItem('pendingSchedulerCommand');
                if (pendingCommand) {
                    try {
                        const commandData = JSON.parse(pendingCommand);
                        sessionStorage.removeItem('pendingSchedulerCommand');
                        
                        // Execute the pending command after a short delay to ensure page is ready
                        setTimeout(() => {
                            if (commandData.command === 'RUN_ALGORITHM') {
                                window.postMessage({
                                    type: 'RUN_SCHEDULER_ALGORITHM',
                                    algorithm: commandData.algorithm
                                }, '*');
                            } else if (commandData.command === 'VIEW_CONTROL') {
                                window.postMessage({
                                    type: 'SCHEDULER_VIEW_CONTROL',
                                    action: commandData.action
                                }, '*');
                            }
                        }, 500);
                    } catch (error) {
                        console.error('Failed to execute pending scheduler command:', error);
                    }
                }
                
                // Listen for messages from Max AI
                window.addEventListener('message', (event) => {
                    console.log('Production Scheduler received message:', event.data);
                    
                    // Handle algorithm execution from agent bridge
                    if (event.data?.type === 'EXECUTE_SCHEDULING_ALGORITHM') {
                        const algorithm = event.data.data?.algorithm;
                        console.log('ü§ñ Agent Bridge requested algorithm execution:', algorithm);
                        
                        // Set the dropdown to the requested algorithm
                        const algorithmSelect = document.getElementById('schedulingAlgorithm');
                        if (algorithmSelect && algorithm) {
                            algorithmSelect.value = algorithm;
                            
                            // Execute the algorithm
                            setTimeout(() => {
                                if (algorithm === 'asap' && window.asapScheduling) {
                                    console.log('üöÄ Executing ASAP algorithm via Agent Bridge');
                                    window.asapScheduling();
                                } else if (algorithm === 'alap' && window.alapScheduling) {
                                    console.log('üöÄ Executing ALAP algorithm via Agent Bridge');
                                    window.alapScheduling();
                                }
                                
                                // Send confirmation back to parent
                                parent.postMessage({
                                    type: 'ALGORITHM_EXECUTION_COMPLETE',
                                    algorithm: algorithm,
                                    success: true
                                }, '*');
                            }, 100);
                        }
                    }
                    
                    // Handle save schedule request from agent bridge
                    if (event.data?.type === 'SAVE_SCHEDULE') {
                        const name = event.data.data?.name;
                        console.log('ü§ñ Agent Bridge requested schedule save:', name);
                        
                        // TODO: Implement save schedule functionality
                        // For now, just acknowledge
                        parent.postMessage({
                            type: 'SCHEDULE_SAVE_COMPLETE',
                            name: name,
                            success: true
                        }, '*');
                    }
                    
                    // Handle load schedule request from agent bridge
                    if (event.data?.type === 'LOAD_SCHEDULE') {
                        const name = event.data.data?.name;
                        console.log('ü§ñ Agent Bridge requested schedule load:', name);
                        
                        // TODO: Implement load schedule functionality
                        // For now, just acknowledge
                        parent.postMessage({
                            type: 'SCHEDULE_LOAD_COMPLETE',
                            name: name,
                            success: true
                        }, '*');
                    }
                    
                    // Handle load version request from version history component
                    if (event.data?.type === 'LOAD_VERSION') {
                        const version = event.data.version;
                        console.log('üìö Version History requested version load:', version);
                        
                        if (version && window.loadSelectedVersion) {
                            window.loadSelectedVersion(version).then(() => {
                                console.log('‚úÖ Version loaded successfully');
                                parent.postMessage({
                                    type: 'VERSION_LOAD_COMPLETE',
                                    versionId: version.id,
                                    success: true
                                }, '*');
                            }).catch(error => {
                                console.error('‚ùå Failed to load version:', error);
                                parent.postMessage({
                                    type: 'VERSION_LOAD_COMPLETE',
                                    versionId: version.id,
                                    success: false,
                                    error: error.message
                                }, '*');
                            });
                        }
                    }
                    
                    // Handle scheduler commands from Max AI
                    if (event.data?.type === 'SCHEDULER_VIEW_CONTROL') {
                        const action = event.data.action;
                        
                        switch (action) {
                            case 'zoom_in':
                                document.getElementById('zoomIn')?.click();
                                break;
                            case 'zoom_out':
                                document.getElementById('zoomOut')?.click();
                                break;
                            case 'zoom_fit':
                                document.getElementById('zoomToFit')?.click();
                                break;
                            case 'week_view':
                                const viewSelect = document.getElementById('viewPreset');
                                if (viewSelect) {
                                    viewSelect.value = 'dayAndWeek';
                                    viewSelect.dispatchEvent(new Event('change'));
                                }
                                break;
                            case 'day_view':
                                const viewSelectDay = document.getElementById('viewPreset');
                                if (viewSelectDay) {
                                    viewSelectDay.value = 'hourAndDay';
                                    viewSelectDay.dispatchEvent(new Event('change'));
                                }
                                break;
                            case 'month_view':
                                const viewSelectMonth = document.getElementById('viewPreset');
                                if (viewSelectMonth) {
                                    viewSelectMonth.value = 'monthAndYear';
                                    viewSelectMonth.dispatchEvent(new Event('change'));
                                }
                                break;
                        }
                    } else if (event.data?.type === 'RUN_SCHEDULER_ALGORITHM') {
                        const algorithm = event.data.algorithm;
                        const algorithmMap = {
                            'ASAP': 'asap',
                            'ALAP': 'alap',
                            'CRITICAL_PATH': 'criticalPath',
                            'LEVEL_RESOURCES': 'levelResources',
                            'DRUM_TOC': 'drum'
                        };
                        
                        const algorithmValue = algorithmMap[algorithm];
                        if (algorithmValue) {
                            const algorithmSelect = document.getElementById('schedulingAlgorithm');
                            const applyButton = document.getElementById('applyScheduling');
                            
                            if (algorithmSelect && applyButton) {
                                algorithmSelect.value = algorithmValue;
                                applyButton.click();
                                console.log(`Applied scheduling algorithm: ${algorithm}`);
                            }
                        }
                    } else if (event.data?.type === 'SET_THEME') {
                        // Theme toggle removed - using consistent light theme with blue-purple gradient
                        console.log('Theme toggle disabled - using consistent light theme');
                    }
                });
                
            } catch (error) {
                console.error('Failed to initialize scheduler:', error);
                // Only show error if initialization actually failed (not just warnings)
                if (error.message && error.message !== 'undefined') {
                    console.error('Scheduler initialization error details:', error.message);
                }
                // Try to continue with scheduler initialization even if some resources fail
                document.getElementById('loadingOverlay').style.display = 'none';
            } finally {
                // Ensure loading overlay is hidden
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.style.display = 'none';
            }
            }); // End of waitForBryntum callback
        });
    </script>
    
    <!-- Additional Scripts -->
    <script>
        // Constraint modal functions have been removed as constraints are now visual-only
        // Dependencies create lines on the Gantt chart but don't affect scheduling logic
        
        // Setup event listeners when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Apply theme from localStorage on page load
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.className = savedTheme === 'dark' ? 'dark-theme' : '';
            
            // Constraint settings removed - functionality simplified
            // Listen for theme changes from parent window
            window.addEventListener('message', (e) => {
                if (e.data && e.data.type === 'SET_THEME') {
                    document.body.className = e.data.theme === 'dark' ? 'dark-theme' : '';
                    localStorage.setItem('theme', e.data.theme);
                }
            });
            
            // Listen for storage changes (theme changes in main app)
            window.addEventListener('storage', (e) => {
                if (e.key === 'theme') {
                    document.body.className = e.newValue === 'dark' ? 'dark-theme' : '';
                }
            });
            
            // Helper function to collect schedule data
            function collectScheduleData() {
                const resources = scheduler.resourceStore.records.map(r => ({
                    id: String(r.id), // Convert to string for API
                    name: r.name,
                    type: r.type || 'default',
                    capacity: Number(r.capacity) || 1 // Ensure it's a number
                }));
                
                const events = scheduler.eventStore.records
                    .filter(e => e.resourceId !== 'unscheduled')
                    .map(e => ({
                        id: String(e.id), // Convert to string for API
                        name: e.name,
                        resourceId: String(e.resourceId), // Ensure string
                        startDate: e.startDate?.toISOString() || '',
                        endDate: e.endDate?.toISOString() || '',
                        duration: e.durationMS || 0,
                        manuallyScheduled: e.manuallyScheduled || false,
                        locked: e.locked || false,
                        priority: e.priority || 0
                    }));
                
                // Use visual dependency store instead of engine's (which is null)
                const dependencies = window.visualDependencyStore ? 
                    window.visualDependencyStore.records.map(d => ({
                        id: String(d.id), // Convert to string
                        fromEvent: String(d.fromEvent?.id || d.fromEvent), // Extract ID if it's an object
                        toEvent: String(d.toEvent?.id || d.toEvent), // Extract ID if it's an object
                        type: d.type || 2,
                        lag: d.lag || 0,
                        lagUnit: d.lagUnit || 'hour'
                    })) : [];
                
                return {
                    version: `v_${Date.now()}`,
                    snapshot: {
                        resources,
                        events,
                        dependencies,
                        constraints: []
                    },
                    metadata: {
                        plantId: 'plant_1',
                        timestamp: new Date().toISOString(),
                        userId: 'current_user'
                    }
                };
            }
            
            // Helper function to listen for optimization progress via SSE
            async function pollForOptimizationResult(runId, maxAttempts = 60) {
                return new Promise((resolve, reject) => {
                    let timeoutId;
                    let eventSource;
                    
                    // Set a timeout to prevent infinite waiting (30 seconds)
                    const maxTimeout = setTimeout(() => {
                        if (eventSource) {
                            eventSource.close();
                        }
                        reject(new Error('Optimization timed out after 30 seconds. Please try again.'));
                    }, 30000);
                    
                    // Set up SSE connection for progress updates
                    eventSource = new EventSource(`/api/schedules/optimize/${runId}/progress`);
                    
                    // Progress handler
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress' && data.data) {
                                const progress = data.data;
                                console.log(`Optimization progress: ${progress.percentage}% - ${progress.currentStep}`);
                                
                                // Update UI with progress
                                const optimizeBtn = document.getElementById('optimizeSchedule');
                                if (optimizeBtn && optimizeBtn.disabled) {
                                    optimizeBtn.innerHTML = `
                                        <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21 12a9 9 0 11-6-8.49"></path>
                                        </svg>
                                        <span>${progress.percentage}%</span>
                                    `;
                                }
                            } else if (data.type === 'complete') {
                                // Job completed, fetch final status
                                fetch(`/api/schedules/optimize/${runId}`)
                                    .then(res => res.json())
                                    .then(status => {
                                        eventSource.close();
                                        clearTimeout(timeoutId);
                                        clearTimeout(maxTimeout);
                                        resolve(status);
                                    })
                                    .catch(err => {
                                        eventSource.close();
                                        clearTimeout(timeoutId);
                                        clearTimeout(maxTimeout);
                                        reject(err);
                                    });
                            } else if (data.type === 'error') {
                                eventSource.close();
                                clearTimeout(timeoutId);
                                clearTimeout(maxTimeout);
                                reject(new Error(data.error?.message || 'Optimization failed'));
                            }
                        } catch (error) {
                            console.error('Error parsing SSE data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        console.error('SSE error:', error);
                        eventSource.close();
                        
                        // Fallback to polling if SSE fails
                        pollWithFetch();
                    };
                    
                    // Timeout after maxAttempts seconds
                    timeoutId = setTimeout(() => {
                        eventSource.close();
                        reject(new Error('Optimization timeout'));
                    }, maxAttempts * 1000);
                    
                    // Fallback polling function if SSE fails
                    async function pollWithFetch() {
                        clearTimeout(timeoutId);
                        clearTimeout(maxTimeout);
                        for (let i = 0; i < maxAttempts; i++) {
                            try {
                                const response = await fetch(`/api/schedules/optimize/${runId}`);
                                if (!response.ok) throw new Error('Failed to check job status');
                                
                                const status = await response.json();
                                
                                if (status.status === 'completed' || status.status === 'failed') {
                                    clearTimeout(maxTimeout);
                                    resolve(status);
                                    return;
                                }
                                
                                // Update progress if available
                                if (status.progress) {
                                    console.log(`Optimization progress: ${status.progress.percentage}% - ${status.progress.currentStep}`);
                                }
                                
                                // Wait before next poll
                                await new Promise(r => setTimeout(r, 1000));
                            } catch (error) {
                                reject(error);
                                return;
                            }
                        }
                        reject(new Error('Optimization timeout'));
                    }
                });
            }
            
            // Helper function to apply optimization results
            async function applyOptimizationResults(result) {
                scheduler.project.suspendAutoCommit();
                
                try {
                    // Handle both optimization results from server (with operations array)
                    // and local results (with events array)
                    const operations = result.operations || result.events || [];
                    console.log(`üîÑ Applying ${operations.length} optimized operations to scheduler...`);
                    
                    for (const optEvent of operations) {
                        const event = scheduler.eventStore.getById(optEvent.id);
                        if (event) {
                            // Map algorithm fields to Bryntum event fields
                            // Server algorithms return scheduled_start/scheduled_end or startTime/endTime
                            // Bryntum expects startDate/endDate
                            const startTime = optEvent.scheduled_start || optEvent.startTime || optEvent.startDate;
                            const endTime = optEvent.scheduled_end || optEvent.endTime || optEvent.endDate;
                            
                            if (startTime && endTime) {
                                event.set({
                                    startDate: new Date(startTime),
                                    endDate: new Date(endTime),
                                    resourceId: optEvent.resourceId || event.resourceId
                                });
                                event.manuallyScheduled = true;
                                event.cls = (event.cls || '') + ' optimized-event';
                                console.log(`‚úÖ Updated event ${event.name}: ${new Date(startTime).toLocaleString()} - ${new Date(endTime).toLocaleString()}`);
                            } else {
                                console.warn(`‚ö†Ô∏è Skipping event ${event.name} - missing time data`);
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è Event ${optEvent.id} not found in scheduler store`);
                        }
                    }
                    
                    scheduler.project.resumeAutoCommit();
                    await scheduler.project.commitAsync();
                    console.log('‚úÖ Optimization results applied successfully!');
                } catch (error) {
                    scheduler.project.resumeAutoCommit();
                    console.error('‚ùå Error applying optimization results:', error);
                    throw error;
                }
            }
            
            // Helper function to show notifications
            function showNotification(message, type = 'info') {
                const colors = {
                    success: '#4CAF50',
                    error: '#f44336',
                    info: '#2196F3'
                };
                
                if (scheduler.features.toast) {
                    scheduler.toast({
                        html: message,
                        timeout: 5000,
                        style: `background-color: ${colors[type]}`
                    });
                } else {
                    console.log(`[${type.toUpperCase()}] ${message}`);
                }
            }
            
            // REMOVED DUPLICATE EVENT LISTENER
            // This was causing the ASAP infinite loop because there were two event listeners
            // for the same button. The original listener is at line 3198.
            // Keeping only the first event listener to prevent duplicate scheduling calls.
            
            /* DUPLICATE CODE REMOVED - SEE LINE 3198 FOR THE ACTIVE EVENT LISTENER
            document.getElementById('applyScheduling').addEventListener('click', async () => {
                // This entire block was commented out to prevent duplicate event listener
                // The working event listener is at line 3198
            });
            
            The following block from lines 4903-5158 contained duplicate scheduling logic:*/
            
            // END OF SCHEDULING ALGORITHM HANDLER
            
            // The following section used to contain manual ASAP/ALAP scheduling logic
            // but has been replaced with Bryntum's built-in scheduling engine
            
            /* OLD MANUAL CODE REMOVED - Replaced with Bryntum's propagate() method
                                // ASAP scheduling - schedule as soon as possible (simplified approach)
                                console.log('üöÄ Applying ASAP scheduling with simplified resource tracking...');
                                
                                // Get stores
                                const eventStore = window.scheduler.eventStore;
                                const dependencyStore = window.scheduler.dependencyStore;
                                
                                // Build dependency maps
                                const predecessors = {};
                                dependencyStore.records.forEach(dep => {
                                    if (!predecessors[dep.to]) predecessors[dep.to] = [];
                                    predecessors[dep.to].push(dep.from);
                                });
                                
                                // Project start time
                                const projectStart = new Date();
                                projectStart.setHours(8, 0, 0, 0);
                                
                                // Track the latest end time for each resource (simple timeline)
                                const resourceTimelines = new Map();
                                
                                // Process all events multiple times until all are scheduled
                                const maxIterations = 10;
                                const scheduled = new Set();
                                
                                for (let iteration = 0; iteration < maxIterations && scheduled.size < eventStore.count; iteration++) {
                                    console.log(`\nüìå Iteration ${iteration + 1}`);
                                    
                                    eventStore.records.forEach(event => {
                                        if (scheduled.has(event.id)) return;
                                        
                                        // Check if all dependencies are scheduled
                                        const deps = predecessors[event.id] || [];
                                        const allDepsScheduled = deps.every(depId => scheduled.has(depId));
                                        
                                        if (!allDepsScheduled) return;
                                        
                                        // Calculate duration
                                        const durationMs = event.duration * 60 * 60 * 1000;
                                        
                                        // Get the resource ID - Bryntum stores it as a string
                                        const resourceId = String(event.resourceId);
                                        
                                        // Find earliest start based on dependencies
                                        let earliestStart = projectStart.getTime();
                                        deps.forEach(depId => {
                                            const dep = eventStore.getById(depId);
                                            if (dep && dep.endDate) {
                                                earliestStart = Math.max(earliestStart, dep.endDate.getTime());
                                            }
                                        });
                                        
                                        // Check resource availability
                                        const resourceAvailable = resourceTimelines.get(resourceId) || projectStart.getTime();
                                        const actualStart = Math.max(earliestStart, resourceAvailable);
                                        
                                        // Schedule the event
                                        event.startDate = new Date(actualStart);
                                        event.endDate = new Date(actualStart + durationMs);
                                        
                                        // Update resource timeline
                                        resourceTimelines.set(resourceId, event.endDate.getTime());
                                        
                                        // Mark as scheduled
                                        scheduled.add(event.id);
                                        
                                        console.log(`‚úÖ Scheduled "${event.name}" on Resource ${resourceId}: ${event.startDate.toLocaleString()}`);
                                    });
                                }
                                
                                if (scheduled.size < eventStore.count) {
                                    console.warn(`‚ö†Ô∏è Could not schedule ${eventStore.count - scheduled.size} events due to circular dependencies`);
                                }
                                
                                // Force a refresh of the scheduler view
                                window.scheduler.refresh();
                                
                                console.log(`\n‚úÖ ASAP scheduling completed! Scheduled ${scheduled.size}/${eventStore.count} events`);
                                console.log('Resource timelines:', Object.fromEntries(resourceTimelines));
                                break;
                            case 'alap':
                                // ALAP scheduling - schedule as late as possible
                                console.log('üöÄ Applying ALAP scheduling...');
                                
                                // Get the event store and dependency store
                                const eventStoreALAP = window.scheduler.eventStore;
                                const dependencyStoreALAP = window.scheduler.dependencyStore;
                                
                                // First, collect all events and their resource assignments
                                const eventsByResourceALAP = {};
                                eventStoreALAP.records.forEach(event => {
                                    const resourceId = event.resourceId;
                                    if (!eventsByResourceALAP[resourceId]) {
                                        eventsByResourceALAP[resourceId] = [];
                                    }
                                    eventsByResourceALAP[resourceId].push(event);
                                });
                                
                                // Build a reverse dependency graph (successors for each event)
                                const successorGraph = {};
                                const hasSuccessor = new Set();
                                dependencyStoreALAP.records.forEach(dep => {
                                    if (!successorGraph[dep.to]) {
                                        successorGraph[dep.to] = [];
                                    }
                                    successorGraph[dep.to].push(dep.from);
                                    hasSuccessor.add(dep.from);
                                });
                                
                                // Find ending events (no outgoing dependencies)
                                const endingEvents = eventStoreALAP.records.filter(event => 
                                    !hasSuccessor.has(event.id)
                                );
                                
                                // Set project end date (e.g., 30 days from now)
                                const projectEnd = new Date();
                                projectEnd.setDate(projectEnd.getDate() + 30);
                                projectEnd.setHours(17, 0, 0, 0); // End at 5 PM
                                
                                // Process each resource's events separately to avoid overlaps
                                Object.entries(eventsByResourceALAP).forEach(([resourceId, resourceEvents]) => {
                                    // Sort events by their current end date in reverse (or by ID if no end date)
                                    resourceEvents.sort((a, b) => {
                                        if (b.endDate && a.endDate) {
                                            return b.endDate.getTime() - a.endDate.getTime();
                                        }
                                        return b.id - a.id;
                                    });
                                    
                                    // Track the latest available time for this resource (working backwards)
                                    let resourceLatestTime = projectEnd.getTime();
                                    
                                    // Schedule each event on this resource (working backwards)
                                    resourceEvents.forEach((event, index) => {
                                        // Calculate duration in milliseconds
                                        const durationMs = event.duration * 60 * 60 * 1000; // Convert hours to ms
                                        
                                        // Check for dependencies - if this event has a successor, must finish before it starts
                                        let latestEnd = resourceLatestTime;
                                        
                                        // Check all dependencies where this event is the predecessor
                                        dependencyStoreALAP.records.forEach(dep => {
                                            if (dep.from === event.id) {
                                                const successor = eventStoreALAP.getById(dep.to);
                                                if (successor && successor.startDate) {
                                                    const successorStartTime = successor.startDate.getTime();
                                                    // Subtract lag if specified
                                                    const lagMs = (dep.lag || 0) * 60 * 60 * 1000;
                                                    latestEnd = Math.min(latestEnd, successorStartTime - lagMs);
                                                }
                                            }
                                        });
                                        
                                        // Set the event end time (ALAP = latest possible)
                                        event.endDate = new Date(latestEnd);
                                        event.startDate = new Date(latestEnd - durationMs);
                                        
                                        // Update resource availability for previous event (working backwards)
                                        resourceLatestTime = event.startDate.getTime();
                                        
                                        console.log(`‚úÖ Scheduled "${event.name}" on ${resourceId}: ${event.startDate.toLocaleString()} - ${event.endDate.toLocaleString()}`);
                                    });
                                });
                                
                                // Force a refresh of the scheduler view
                                window.scheduler.refresh();
                                
                                console.log('‚úÖ ALAP scheduling completed - no overlaps!');
                                break;
                            case 'criticalPath':
                                // Critical path method
                                if (window.scheduler.project.calculateCriticalPath) {
                                    window.scheduler.project.calculateCriticalPath();
                                } else {
                                    console.warn('Critical path calculation not available');
                                }
                                break;
                            case 'levelResources':
                                // Resource leveling
                                if (window.scheduler.project.levelResources) {
                                    window.scheduler.project.levelResources();
                                } else {
                                    console.warn('Resource leveling not available');
                                }
                                break;
                            case 'drum':
                                // Theory of Constraints / Drum scheduling
                                console.log('Drum/TOC scheduling - custom implementation needed');
                                break;
                            default:
                                console.warn('Unknown algorithm:', algorithm);
                        }
                        
                        // Re-enable state saving if it was enabled
                        if (originalStateId) {
                            window.scheduler.stateId = originalStateId;
                        }
                        
                        // Show success feedback
                        const notification = document.createElement('div');
                        notification.className = 'scheduler-notification success';
                        notification.textContent = `‚úÖ ${algorithm.toUpperCase()} algorithm applied successfully`;
                        notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000; animation: slideIn 0.3s ease-out;';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            notification.style.animation = 'slideOut 0.3s ease-out';
                            setTimeout(() => notification.remove(), 300);
                        }, 3000);
                    } else {
                        console.error('Scheduler not initialized');
                    }
                } catch (error) {
                    console.error('‚ùå Error applying algorithm:', error);
                    
                    // Show error notification
                    const errorNotification = document.createElement('div');
                    errorNotification.className = 'scheduler-notification error';
                    errorNotification.textContent = `‚ùå Failed to apply algorithm: ${error.message || 'Unknown error'}`;
                    errorNotification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ef4444; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000; animation: slideIn 0.3s ease-out;';
                    document.body.appendChild(errorNotification);
                    
                    setTimeout(() => {
                        errorNotification.style.animation = 'slideOut 0.3s ease-out';
                        setTimeout(() => errorNotification.remove(), 300);
                    }, 5000);
                }
            });
            */ // END OF OLD MANUAL CODE BLOCK
            
            // Add functionality for Save button to update main database
            document.getElementById('saveSchedule').addEventListener('click', async () => {
                try {
                    // Show saving status
                    const saveBtn = document.getElementById('saveSchedule');
                    const originalHTML = saveBtn.innerHTML;
                    saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin"><path d="M21 12a9 9 0 1 1-6-8.485"></path></svg><span>Saving...</span>';
                    saveBtn.disabled = true;
                    
                    // Collect all events with their scheduled times
                    if (window.scheduler && window.scheduler.eventStore) {
                        const events = window.scheduler.eventStore.records;
                        
                        // Prepare operations update data - filter out unscheduled operations
                        const operations = events
                            .filter(event => event.resourceId !== 'unscheduled' && event.startDate && event.endDate)
                            .map(event => {
                                // The event.id corresponds to the ptjoboperations table ID
                                const op = {
                                    id: parseInt(event.id), // Ensure it's a number for the database
                                    start: event.startDate ? event.startDate.toISOString() : null,
                                    end: event.endDate ? event.endDate.toISOString() : null,
                                    manuallyScheduled: event.manuallyScheduled || false
                                };
                                console.log(`üìù Saving operation: ${event.name} (ID: ${op.id}) - Start: ${op.start}, End: ${op.end}`);
                                return op;
                            });
                        
                        if (operations.length === 0) {
                            alert('No scheduled operations to save. Please schedule some operations first.');
                            saveBtn.innerHTML = originalHTML;
                            saveBtn.disabled = false;
                            return;
                        }
                        
                        console.log(`üìù Updating ${operations.length} scheduled operations in database...`);
                        
                        // Get auth token using helper function
                        const authToken = getAuthToken();
                        
                        // Update main database with new schedule times
                        const response = await fetch('/api/pt-operations/schedule', {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': authToken ? `Bearer ${authToken}` : ''
                            },
                            body: JSON.stringify({ operations })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            // Update last update time
                            document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                            
                            console.log(`‚úÖ Updated ${result.updated}/${result.total} operations in database`);
                            
                            // Show success message
                            saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg><span>Schedule Updated!</span>';
                            
                            // Create version history entry for the manual save
                            try {
                                console.log('üìù Creating version history entry for manual save...');
                                const authToken = getAuthToken();
                                
                                // Get the current user's ID from the token
                                let userId = null;
                                try {
                                    // Parse the JWT token to get the user ID
                                    const tokenParts = authToken.split('.');
                                    if (tokenParts.length === 3) {
                                        const payload = JSON.parse(atob(tokenParts[1]));
                                        userId = payload.id || payload.userId || payload.sub;
                                        console.log('üìù Extracted userId from token:', userId);
                                    }
                                } catch (e) {
                                    console.warn('Could not extract userId from token, will let server determine user');
                                }
                                
                                const versionData = {
                                    scheduleName: 'Main Schedule',
                                    changeType: 'manual_save',
                                    changeDescription: 'Schedule manually saved by user',
                                    comment: `${result.updated} operations updated`,
                                    userId: userId // Use extracted userId or let server determine from auth
                                };
                                
                                console.log('üìù Sending version history request with data:', versionData);
                                
                                const versionResponse = await fetch('/api/schedules/1/versions', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': authToken ? `Bearer ${authToken}` : ''
                                    },
                                    body: JSON.stringify(versionData)
                                });
                                
                                console.log('üìù Version history response status:', versionResponse.status);
                                
                                if (versionResponse.ok) {
                                    const versionResult = await versionResponse.json();
                                    console.log('‚úÖ Version history entry created for manual save:', versionResult);
                                    
                                    // Auto-load the newly created version if autoLoad flag is set
                                    if (versionResult.autoLoad && versionResult.version) {
                                        console.log('üîÑ Auto-loading newly saved version...');
                                        if (window.loadSelectedVersion) {
                                            await window.loadSelectedVersion(versionResult.version);
                                            console.log('‚úÖ Manual save auto-loaded successfully');
                                        }
                                    }
                                } else {
                                    const errorText = await versionResponse.text();
                                    console.error('‚ùå Failed to create version history entry:', errorText);
                                    console.error('Response status:', versionResponse.status);
                                }
                            } catch (error) {
                                console.error('‚ùå Exception creating version history entry:', error);
                                console.error('Error stack:', error.stack);
                            }
                            
                            // Optional: Also save a version/snapshot for history
                            // This happens automatically with the existing saved-schedules system
                            try {
                                // Safely extract schedule data with fallbacks
                                let eventsData = [];
                                let resourcesData = [];
                                let dependenciesData = [];
                                
                                try {
                                    // Try to get events data - fallback to manual extraction if toJSON fails
                                    if (window.scheduler.eventStore.toJSON) {
                                        eventsData = window.scheduler.eventStore.toJSON();
                                    }
                                } catch (e) {
                                    console.warn('Could not serialize events with toJSON, using fallback:', e);
                                    // Fallback: manually extract essential event data
                                    eventsData = window.scheduler.eventStore.records.map(event => ({
                                        id: event.id,
                                        name: event.name,
                                        startDate: event.startDate ? event.startDate.toISOString() : null,
                                        endDate: event.endDate ? event.endDate.toISOString() : null,
                                        resourceId: event.resourceId,
                                        duration: event.duration,
                                        durationUnit: event.durationUnit
                                    }));
                                }
                                
                                try {
                                    // Try to get resources data - fallback to manual extraction if toJSON fails
                                    if (window.scheduler.resourceStore.toJSON) {
                                        resourcesData = window.scheduler.resourceStore.toJSON();
                                    }
                                } catch (e) {
                                    console.warn('Could not serialize resources with toJSON, using fallback:', e);
                                    // Fallback: manually extract essential resource data
                                    resourcesData = window.scheduler.resourceStore.records.map(resource => ({
                                        id: resource.id,
                                        name: resource.name
                                    }));
                                }
                                
                                try {
                                    // Try to get dependencies data if visual store exists
                                    if (window.visualDependencyStore && window.visualDependencyStore.toJSON) {
                                        dependenciesData = window.visualDependencyStore.toJSON();
                                    }
                                } catch (e) {
                                    console.warn('Could not serialize dependencies:', e);
                                    // Dependencies are optional, so just leave as empty array
                                }
                                
                                const scheduleData = {
                                    name: `Auto-save - ${new Date().toLocaleString()}`,
                                    description: `Algorithm: ${document.getElementById('schedulingAlgorithm').options[document.getElementById('schedulingAlgorithm').selectedIndex].text}`,
                                    scheduleData: {
                                        events: eventsData,
                                        resources: resourcesData,
                                        dependencies: dependenciesData
                                    },
                                    metadata: {
                                        algorithm: document.getElementById('schedulingAlgorithm').value,
                                        savedAt: new Date().toISOString(),
                                        stats: {
                                            operations: result.updated,
                                            utilization: window.currentResourceUtilization || 0,
                                            totalHours: window.currentTotalHours || 0,
                                            resources: window.scheduler.resourceStore.count
                                        }
                                    }
                                };
                                
                                // Save as a proper version history entry (with dependencies)
                                fetch('/api/schedules/1/versions', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': authToken ? `Bearer ${authToken}` : ''
                                    },
                                    body: JSON.stringify({
                                        changeType: 'optimization',
                                        changeDescription: `Applied ${document.getElementById('schedulingAlgorithm').options[document.getElementById('schedulingAlgorithm').selectedIndex].text} algorithm`,
                                        comment: `Auto-save after optimization - ${new Date().toLocaleString()}`,
                                        userId: parseInt(localStorage.getItem('userId')) || 1
                                    })
                                }).then(async res => {
                                    if (res.ok) {
                                        const result = await res.json();
                                        console.log('‚úÖ Schedule version saved with dependencies', result);
                                        
                                        // Auto-load the newly created version if autoLoad flag is set
                                        if (result.autoLoad && result.version) {
                                            console.log('üîÑ Auto-loading newly created version...');
                                            if (window.loadSelectedVersion) {
                                                await window.loadSelectedVersion(result.version);
                                                console.log('‚úÖ Version auto-loaded successfully');
                                            }
                                        }
                                    }
                                }).catch(err => {
                                    console.warn('Failed to save schedule version:', err);
                                });
                            } catch (versionError) {
                                // Silently fail version save - main update already succeeded
                                console.warn('Could not save schedule version:', versionError);
                            }
                        } else {
                            const error = await response.text();
                            console.error('Failed to update schedule:', error);
                            
                            // Show error
                            saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><span>Update Failed</span>';
                            
                            alert('Failed to update schedule in database. Please try again.');
                        }
                        
                        // Reset button after delay
                        setTimeout(() => {
                            saveBtn.innerHTML = originalHTML;
                            saveBtn.disabled = false;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('‚ùå Error updating schedule:', error);
                    alert('Failed to update schedule. Please check console for details.');
                    
                    // Properly reset the save button
                    const saveBtn = document.getElementById('saveSchedule');
                    if (saveBtn) {
                        saveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg><span>Save Schedule</span>';
                        saveBtn.disabled = false;
                    }
                }
            });
            
            // Add Load Schedule functionality - opens version history panel
            window.loadSchedule = function() {
                console.log('üìö Opening version history panel for schedule loading...');
                
                // Send message to parent React app to open version history
                // This will open the version history panel where each version has a Load button
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'OPEN_VERSION_HISTORY',
                        source: 'production-scheduler',
                        message: 'User requested to load a schedule version'
                    }, '*');
                    
                    // Show a toast notification if Bryntum is available
                    if (window.scheduler && window.scheduler.bryntum) {
                        window.scheduler.bryntum.Toast.show({
                            html: 'Opening Version History panel...',
                            color: 'b-blue',
                            timeout: 2000
                        });
                    }
                } else {
                    // If not in iframe, inform user to use Version History panel
                    if (window.scheduler && window.scheduler.bryntum) {
                        window.scheduler.bryntum.MessageDialog.alert({
                            title: 'Load from Version History',
                            message: 'Please open the Version History panel from the toolbar to load a specific schedule version. Each version has its own Load button.'
                        });
                    } else {
                        alert('Please open the Version History panel from the toolbar to load a specific schedule version.');
                    }
                }
            };
            
            // Helper function to load a selected version from version history
            async function loadSelectedVersion(selectedVersion) {
                try {
                    console.log('üìö Loading version:', selectedVersion);
                    
                    // Parse the snapshot data from the version
                    const snapshotData = typeof selectedVersion.snapshotData === 'string' 
                        ? JSON.parse(selectedVersion.snapshotData) 
                        : selectedVersion.snapshotData;
                    
                    // Load the schedule data including dependencies
                    if (window.scheduler && window.scheduler.project) {
                        try {
                            // First, we need to reload the operations to get the scheduled times from the version
                            // The version contains operations with their scheduled start/end times
                            const operations = snapshotData.operations || [];
                            const dependencies = snapshotData.dependencies || [];
                            
                            console.log(`üìö Loading ${operations.length} operations and ${dependencies.length} dependencies from version`);
                            
                            // Update operations with their scheduled times from the version
                            operations.forEach(op => {
                                const event = window.scheduler.eventStore.getById(op.id);
                                if (event && op.scheduledStart && op.scheduledEnd) {
                                    event.startDate = new Date(op.scheduledStart);
                                    event.endDate = new Date(op.scheduledEnd);
                                    event.manuallyScheduled = op.manuallyScheduled || false;
                                    console.log(`‚úÖ Updated operation ${op.id} with times from version`);
                                }
                            });
                            
                            // Load dependencies if visual store exists
                            if (window.visualDependencyStore && dependencies.length > 0) {
                                console.log('üìö Loading dependencies into visual store...');
                                window.visualDependencyStore.data = dependencies;
                                console.log(`‚úÖ Loaded ${dependencies.length} dependencies`);
                            }
                            
                            // Refresh the scheduler view
                            window.scheduler.refresh();
                            
                            console.log('‚úÖ Version loaded successfully');
                            
                            // Show success message
                            if (window.scheduler && window.scheduler.bryntum) {
                                window.scheduler.bryntum.Toast.show({
                                    html: `Loaded version ${selectedVersion.versionNumber} with ${dependencies.length} dependencies`,
                                    color: 'b-green',
                                    timeout: 3000
                                });
                            }
                        } catch (loadError) {
                            console.warn('Could not use loadInlineData, trying manual load:', loadError);
                            
                            // Fallback: manually load the data into stores
                            try {
                                // Clear existing data first
                                window.scheduler.eventStore.removeAll();
                                
                                // Load events manually
                                if (selectedSchedule.scheduleData.events && Array.isArray(selectedSchedule.scheduleData.events)) {
                                    const events = selectedSchedule.scheduleData.events.map(event => {
                                        // Ensure dates are properly parsed
                                        return {
                                            ...event,
                                            startDate: event.startDate ? new Date(event.startDate) : null,
                                            endDate: event.endDate ? new Date(event.endDate) : null
                                        };
                                    });
                                    window.scheduler.eventStore.add(events);
                                    loadSuccess = true;
                                }
                                
                                // Resources should already be loaded from the API, so skip loading them
                                // This prevents overwriting the current resource structure
                                
                                // Dependencies are visual-only and optional, skip them to avoid errors
                            } catch (manualLoadError) {
                                console.error('Manual load also failed:', manualLoadError);
                                throw new Error('Could not load schedule data');
                            }
                        }
                        
                        if (!loadSuccess) {
                            throw new Error('Failed to load schedule data');
                        }
                        
                        // Restore metadata if available
                        if (selectedSchedule.metadata) {
                            if (selectedSchedule.metadata.algorithm) {
                                document.getElementById('schedulingAlgorithm').value = selectedSchedule.metadata.algorithm;
                            }
                            if (selectedSchedule.metadata.constraints) {
                                window.activeConstraints = selectedSchedule.metadata.constraints;
                            }
                        }
                        
                        // Store the schedule ID for future updates
                        window.currentScheduleId = selectedSchedule.id;
                        
                        // Zoom to fit the entire schedule in view
                        const events = window.scheduler.eventStore.records;
                    if (events && events.length > 0) {
                        // Find the earliest and latest dates in the schedule
                        let minDate = null;
                        let maxDate = null;
                        
                        events.forEach(event => {
                            if (!minDate || event.startDate < minDate) {
                                minDate = new Date(event.startDate);
                            }
                            if (!maxDate || event.endDate > maxDate) {
                                maxDate = new Date(event.endDate);
                            }
                        });
                        
                        if (minDate && maxDate) {
                            // Add some padding (1 day before and after)
                            minDate.setDate(minDate.getDate() - 1);
                            maxDate.setDate(maxDate.getDate() + 1);
                            
                            // Set the time span to show all events
                            window.scheduler.setTimeSpan(minDate, maxDate);
                            
                            // Adjust zoom level to fit the view
                            // Calculate the number of days to show
                            const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
                            
                            // Set appropriate zoom level based on days
                            if (daysDiff <= 7) {
                                window.scheduler.zoomLevel = 10; // Hour view
                            } else if (daysDiff <= 14) {
                                window.scheduler.zoomLevel = 8; // Day view
                            } else if (daysDiff <= 30) {
                                window.scheduler.zoomLevel = 6; // Week view
                            } else {
                                window.scheduler.zoomLevel = 4; // Month view
                            }
                        }
                    }
                    
                        // Update status
                        document.getElementById('lastUpdate').textContent = `Loaded: ${selectedSchedule.name}`;
                        window.updateStatus();
                        
                        console.log('‚úÖ Schedule loaded successfully:', selectedSchedule.name);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading schedule:', error);
                    alert(`Failed to load schedule: ${error.message || 'Unknown error'}. Please try again or select a different schedule.`);
                }
            }
            
            // Helper function to load local schedules from localStorage - DEPRECATED
            // This function is no longer used. Load button now opens the Version History panel
            // where each version has its own Load button for better user experience
            /*
            async function loadLocalSchedules() {
                try {
                    // Fallback to localStorage
                    const localSchedules = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('savedSchedule_') || key.startsWith('scheduleBackup_'))) {
                            try {
                                const data = JSON.parse(localStorage.getItem(key));
                                localSchedules.push({ key, data });
                            } catch (e) {}
                        }
                    }
                    
                    if (localSchedules.length > 0) {
                        const scheduleList = localSchedules.map((s, i) => 
                            `${i + 1}. ${s.data.name || 'Unnamed'} (Local)`
                        ).join('\n');
                        
                        const selection = prompt(`Select a local schedule to load:\n\n${scheduleList}\n\nEnter number:`);
                        if (selection) {
                            const index = parseInt(selection) - 1;
                            if (index >= 0 && index < localSchedules.length) {
                                const selectedSchedule = localSchedules[index].data;
                                if (selectedSchedule.scheduleData || selectedSchedule.data) {
                                    await window.scheduler.project.loadInlineData(selectedSchedule.scheduleData || selectedSchedule.data);
                                        
                                        // Zoom to fit the entire schedule in view
                                        const events = window.scheduler.eventStore.records;
                                        if (events && events.length > 0) {
                                            // Find the earliest and latest dates in the schedule
                                            let minDate = null;
                                            let maxDate = null;
                                            
                                            events.forEach(event => {
                                                if (!minDate || event.startDate < minDate) {
                                                    minDate = new Date(event.startDate);
                                                }
                                                if (!maxDate || event.endDate > maxDate) {
                                                    maxDate = new Date(event.endDate);
                                                }
                                            });
                                            
                                            if (minDate && maxDate) {
                                                // Add some padding (1 day before and after)
                                                minDate.setDate(minDate.getDate() - 1);
                                                maxDate.setDate(maxDate.getDate() + 1);
                                                
                                                // Set the time span to show all events
                                                window.scheduler.setTimeSpan(minDate, maxDate);
                                                
                                                // Adjust zoom level to fit the view
                                                // Calculate the number of days to show
                                                const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
                                                
                                                // Set appropriate zoom level based on days
                                                if (daysDiff <= 7) {
                                                    window.scheduler.zoomLevel = 10; // Hour view
                                                } else if (daysDiff <= 14) {
                                                    window.scheduler.zoomLevel = 8; // Day view
                                                } else if (daysDiff <= 30) {
                                                    window.scheduler.zoomLevel = 6; // Week view
                                                } else {
                                                    window.scheduler.zoomLevel = 4; // Month view
                                                }
                                            }
                                        }
                                        
                                        console.log('‚úÖ Local schedule loaded');
                                    }
                                }
                            }
                    } else {
                        alert('No local schedules found');
                    }
                } catch (error) {
                    console.error('‚ùå Error loading local schedules:', error);
                    alert('Failed to load local schedules. Please try again.');
                }
            }
            */
            
            // Add functionality for Refresh button - simply reload the page
            document.getElementById('refreshSchedule').addEventListener('click', () => {
                // Show refreshing status
                const refreshBtn = document.getElementById('refreshSchedule');
                refreshBtn.classList.add('animate-spin');
                refreshBtn.disabled = true;
                
                console.log('üîÑ Refreshing schedule data...');
                
                // Simply reload the page to get fresh data
                // This ensures all data is fetched with proper authentication
                setTimeout(() => {
                    window.location.reload(true); // Force reload from server, not cache
                }, 300); // Small delay for visual feedback
            });
        });
    </script>
</body>
</html>
